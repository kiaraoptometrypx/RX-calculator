<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=160, initial-scale=0.7, maximum-scale=.9, user-scalable=yes">
<title>Kiara Optometry Prescription Calculator</title>
<style>
* {
  font-size: 12px;
  letter-spacing: 1px;
}

html, body {
  font-size: 20px; /* your base */
	  -webkit-text-size-adjust: none; /* prevents Safari scaling */

}

body { 
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
  font-size: 20px;
  margin: 0;
  background: #f8f8f5;
  color: black;
}

table td:first-child,
table th:first-child {
  width: 80px;
}

table td:nth-child(2),
table th:nth-child(2){
  max-width: 40px;
  width: 40px;
}

table td:nth-child(3),
table th:nth-child(3) {
  min-width: 90px;
  width: 90px;
  white-space: nowrap;
}

table td:nth-child(4),
table th:nth-child(4) {
  min-width: 90px;
  width: 90px;
  white-space: nowrap;
}

table td:nth-child(5),
table th:nth-child(5) {
  min-width: 90px;
  width: 90px;
  white-space: nowrap;
}

table td:nth-child(6),
table th:nth-child(6) {
  min-width: 50px;
  width: 50px;
  white-space: nowrap;
}

table td:nth-child(7),
table th:nth-child(7) {
  min-width: 50px;
  width: 50px;
  white-space: nowrap;
}

h2 { 
  text-align:center; 
  margin-bottom:10px; 
}

table { 
  border-collapse: collapse;
  table-layout: fixed;
  width: 95%; /* keep your width */ 
  margin:0 auto; 
  font-size: 20px; 

}

th, td { 
  border:0.5px solid #999; 
  padding:5px; 
  text-align:center; 
  vertical-align: middle;
  white-space: normal;   /* allow line wrapping */
  word-wrap: break-word; /* legacy */
  overflow-wrap: break-word; /* modern */
}

th {   background:#d9d9d9; 
  color: black;}

input {   width:80px; 
  padding:2px; 
  text-align:center; 
  box-sizing: border-box;}

.now td { background: #F5F5F5; }
.now-comfort td { background: #F5F5F5 ;}
.white td { background: #d9d9d9; }
.fc-results td { background: #EFF5E6; }
.dc-bal td { background: #fff; }
.paleviolet td { background: #D0C5DB }

.table-headernow {  background: #E8D1A0;}

.comfort {  background: #E5F0D1;}
.offwhite { background: #f8f8f5; }

.sph-btn, .addMinus025 {
  user-select: none;      /* prevent text highlight */
  -webkit-user-select: none; /* Safari */
  -moz-user-select: none;    /* Firefox */
}


/* üîí Overlay for blackout */
#overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: #EDEADF;
  color: black;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  z-index: 9999;
}

.choice-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.choice-group input[type="radio"] {
  display: none; /* hide the default bullet */
}

.choice-group label {
  padding: 1px 1px;
  border: 1px solid #888;
  cursor: pointer;
  user-select: none;
  background: #f9f9f9;
}

.choice-group input[type="radio"]:not(:checked) + label {
  text-decoration: line-through;
  color: grey;
}

.choice-group input[type="radio"]:checked + label {
  background: darkgrey;   /* active color */
  color: black;
  border-color: #285C00;
}

#apply-controls { text-align:left; margin-bottom:10px; margin-top:10px; margin-left:10px }
#addMinus025 { cursor:pointer; color:black; text-decoration:underline; user-select:none; }

.custom-link {
  color: #101F01;       /* text color */
  font-weight: bold;    /* normal | bold | lighter | 100-900 */
  font-style: normal;   /* normal | italic | oblique */
  text-decoration: none; /* none | underline | overline | line-through */
}


</style>
</head>
<body>

<!-- üîí Locked screen -->
<div id="overlay">üîí Entering password...</div>

<script>
  function checkPassword() {
    let password = "";
    const correctPassword = ""; // change this

    while (password !== correctPassword) {
      password = prompt("Please enter password to use:");
      if (password === null) {
        document.getElementById("overlay").innerHTML = "Sorry, Access Denied.";
        return false;
      }
      if (password !== correctPassword) {
        alert("Wrong password. Try again.");
      }
    }
    return true;
  }

  window.onload = function () {
    if (checkPassword()) {
      document.getElementById("overlay").style.display = "none";
      // there's no #content in your original but leaving safe
      const c = document.getElementById("content");
      if(c) c.style.display = "block";
    }
  };
</script>
<div style="height:20px;"></div>

<table>
<tr>
  <td colspan="1" style="padding:0px; border:1px solid lightgrey; color: #101F01; text-align:left;">
</td>
</tr>
</table>

<table>
<tr class="offwhite">
	<td colspan="2" style="color:#182E00; border:none; text-align:left; padding:10px;">
</td></tr>
</tr>
<td colspan="2" style="color:#182E00; border:none; text-align:left; padding:0px;">
 <span class="toggle-btn" data-target="toggle-section-fcdc-errormargin"
          style="cursor:pointer; color: grey; user-select:none;">
      <i>‚ñº‚ñ≤ How-to FC DC Error </i>

</span>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;


       
 <span class="toggle-btn" data-target="toggle-section-guide-comfort"
          style="cursor:pointer; color: grey; user-select:none;">
 <i>‚ñº‚ñ≤ How-to Algorithm Refraction </i>

</span>
</td>
</tr>







<tbody class="toggle-section-fcdc-errormargin" style="display:none;">

<tr class="offwhite">
  <td colspan="2" style="padding:5px; border:none; color:#182E00; text-align:left;"></td></tr>

<tr><td colspan="2" style="padding:10px; border:1px solid lightgrey; color:#182E00; text-align:left;">
<b>‚óè Guide for FC DC Error test</b><br><br>
<b>Glossary:</b><br>
  -<b>Fan Chart (FC):</b> Detects astigmatism and line orientation errors. Must be balanced first.<br>
  -<b>Duochrome (DC):</b> Red/green balance test to refine spherical power.<br>
  -<b>Over-Refraction (OR):</b> Trial lenses added on top of the patient‚Äôs current correction to test residual error.<br><br>

<b>Purpose:</b><br>
FC‚ÄìDC Error Test maps how far the visual system is from a true <b>balanced prescription</b>. Using a series of trial lenses (usually 5‚Äì10 steps) we locate areas of over- and under-correction, then calculate the balanced RX. The test can be done binocularly or monocularly and works with glasses or contacts.<br><br>

<b>Important concept:</b><br>
Fan Chart (FC) and Duochrome (DC) are <b>inter-related</b>. The FC reveals astigmatic/line errors; if FC is not balanced, DC results will be unreliable. Correct the FC grossly first ‚Äî this usually requires a slight under-correction; letters in red should be clearer, or make vision blurry by using Over-Refraction (OR) +1.00 lenses. When FC is somewhat corrected, the DC test will function more efficiently <b>red</b> during the balancing step.<br><br> 

<b>Materials:</b><br>
1. Fan Chart (FC) and Duochrome (DC) charts.<br>
2. Sphere Trial lenses (+1.00, +0.50, 0, -0.50, -1.00).<br>
3. Cyl Trial lenses (+0.50, +1.00, +1.50).<br>
4. Calculator to enter FC/DC balance values.<br><br>

<b>How to do:</b><br>

<b>1. Explain & position:</b> Ask the patient to view the FC/DC chart and tell them you‚Äôll try several lenses. Encourage quick, instinctive answers.<br>

<b>2. Balance the Fan Chart (FC) first:</b> Always check the FC before using DC. If parts of the fan look darker or blurred, place plus cylinder (in steps of +0.50 CYL) on the darker region to bring the fan into balance. Do not proceed to DC until the FC looks fairly evenly blurred.<br><br>

<img src="https://raw.githubusercontent.com/kiaraoptometrypx/RX-calculator/main/FCDCchart1.png"
         alt="Fc Dc Chart 1" style="max-width:90%;">
<br><br>

<b>3. Perform the Duochrome (DC) sequence:</b> Present lenses steps around the current RX (example: +1.00, +0.50, 0, -0.50, -1.00). For each step ask: ‚ÄúWhich side is clearer ‚Äî red or green?‚Äù Record quick responses.<br>

<b>4. Constantly check FC at every DC sequence:</b> Everytime the DC is performed, check the FC to ensure that no one group of parallel lines are darker than the other. If there are, balance it with OR cylinder lenses. <br><br>

<img src="https://raw.githubusercontent.com/kiaraoptometrypx/RX-calculator/main/cylerror.png"
         alt="Fc Dc Chart 1" style="max-width:90%;"><br><br>

<b>5. Interpret results:</b> Identify the lens position where balance or smallest difference occurs. That lens value is the <b>sphere to balance DC</b> ‚Äî enter it into the calculator along with the FC adjustments.<br>
   <i>Example:</i> +1.00 red clearer, +0.50 both same, 0 green clearer, -0.50 green clearer, -1.00 both blur ‚Üí here +0.50 is the SPH to balance DC.<br>

<b>6. Map & record:</b> Log the FC results (cyl and axis to balance) and DC (sphere to balance). Use the calculator to compute the Balanced RX.<br>

<b>7. Always use Horizon Enhance:</b> This applies cyl and axis power along the horizontal meridian to enhance clarity.<br>

<b>8. Lastly, adjust S value:</b> Adjust the sphere values to match the current DC status of the glasses if you want to ensure seamless comfort. Otherwise, adjust it according to the visual needs such as needing to see further or nearer than the current prescription.<br><br>

<b>Tips & troubleshooting:</b><br>
- Always grossly balance FC before DC ‚Äî FC errors will invalidate DC readings.<br>
- Aim for a slight under-correction when fixing FC (less minus / more plus). When done correctly, DC should lean clearer to red during balancing ‚Äî this indicates the FC adjustment moved the eye into the correct region for DC testing.<br>
- Ask for quick answers. Long, uncertain replies reduce test reliability. Repeat if responses are inconsistent.<br>
- Keep step sizes consistent (0.50 D) and record which steps were used.<br><br>

<b>Note:</b> This test measures the additional power needed to reach balance ‚Äî discuss the visual needs with the person before finalising any prescription.<br><br>

<br><i><b>- End of FC DC Error Test -</b></i><br><br>--- --- --- --- ---<br><br>
&nbsp;&nbsp;
 <span class="toggle-btn" data-target="toggle-section-fcdc-errormargin"
          style="cursor:pointer; color: #101F01; user-select:none;">
      <i>‚ñº‚ñ≤ toggle</i>
</span>


</td>
</tr>

</tbody>
<tr>
<td colspan="2" style="color:#182E00; border:none; text-align:left; padding:5px;">
</tr>


<tbody class="toggle-section-guide-comfort" style="display:none;">
<tr class="offwhite">

<td colspan="2" style="padding:10px; border:1px solid lightgrey; color:#182E00; text-align:left;">
<b>‚óè How to use the Algorithm Refraction</B><br><br>
First, <b>chooose the type of test</b> based on their needs:<br>
    <b>- Comfy Clearer Test</b><br>
    Keeps both eyes working together comfortably while still making things clearer. 
    Best for people who prefer natural, easy vision without the prescription feeling too strong.
  <br>
    <b>- Sharpest Ever Test</b><br>
    Pushes vision to the crispest and sharpest level possible. 
    Best for people who want maximum clarity, even if it may take a little more time to adjust.
<br>
<br>--- --- --- --- ---<br><br>

<b>- Comfy Clearer Test</b><br>
<b>Purpose:</b>Maintains comfortable binocular balance while still giving a noticeable boost in clarity. It is especially suitable for people who dislike prescriptions that feel too ‚Äústrong‚Äù or ‚Äúartificial‚Äù but still want vision that is clearer than their current glasses.<br><br>
<b>How to do</b><br>

1. Begin with the patient <b>wearing their current glasses or prescription</b>.<br>
2. Keep <b>both eyes open</b> during the test (to maintain natural binocular vision).<br>
3. <b>Change lenses equally</b> for both eyes at the same time.<br>
4. This keeps the <b>prismatic effect balanced</b>, even if the prescription changes.<br>
5. Perform the <B>FC DC Error test</b>.<br>
6. Use the <b>Fan Chart (FC)</b> to find the <b> cyl and axis to bal </b> values, then enter those into the calculator.<br>
7. The calculator will give you the <b>Balance RX</b> (the true and full prescription).<br>
8. Apply the ‚óã <b>Horizon Enhance</b> function.<br>
9. If the wearer has special needs (e.g. wants sharper distance or near vision), make slight <b>sphere adjustments</b>.<br>
10. If no special needs, keep the same <b>DC status</b> as before.<br><br>

<b>Note:</b> When checking each eye separately, <b>one eye may still show some error.</b> 
This is <b>normal</b> because the <b>test corrects binocularly</b>, not monocularly.  
The small error in one eye <b>does not affect daily vision</b>.<br><br><i><b>- End of Comfy Clearer -</b></i><br><br>--- --- --- --- ---<br><br>
        

<b>- Sharpest Ever Test</b><br>
<b>Purpose:</b>Prioritizes maximum possible clarity by pushing the prescription closer to the eye‚Äôs sharpest potential. It is suitable for people who want the crispest vision possible, even if it comes with a slight trade-off in comfort or adaptation time.<br><br>
<b>How to do</b><br>
1. Begin with the patient‚Äôs <b>current prescription</b>.<br>
2. For the sharpest possible vision,<b>perform FC DC Error test on each eye separately</b> (monocular testing).<br>
3. This may cause the two eyes to become <b>imbalanced</b>, since one eye‚Äôs prescription can change more than the other.<br>
4. Use <b>SE Diff</b> (Spherical Equivalent Difference) to track the difference in prescription strength between the two eyes.<br>
5. A new SE Diff introduces a <b>prismatic effect</b> when looking away from the lens center.<br>
6. An SE Diff change of <b>0.25</b> usually requires about a week of adaptation.<br>
7. Most people can tolerate up to <b>0.50 SE Diff change</b> without major issues.<br>
8. Beyond this, adaptation becomes difficult and may lead to <b>adaptation failure</b>.<br>
9. Tolerance is linked to <b>accommodation</b> (the eye‚Äôs focusing ability).<br>
10. <b>Younger patients</b> generally adapt better to larger SE Diff changes.<br><br><i><b>- End of Sharpest Ever -</b></i><br><br>--- --- --- --- ---<br><br>

&nbsp;&nbsp;
<span class="toggle-btn" data-target="toggle-section-guide-comfort"
          style="cursor:pointer; color: #101F01; user-select:none;">
<i>‚ñº‚ñ≤ toggle</i>

     
</td>
</tr>
</tbody>
<tr>
<td colspan="1" style="color:#182E00; border:none; text-align:left; padding:5px;">
</tr>
</table>


<!-- Toggle function -->
<script>
function toggleSection(id) {
  const section = document.getElementById(id);
  section.style.display = (section.style.display === "none") ? "table-row" : "none";
}
</script>


<table>
<tr>
  <td colspan="1" style="padding:0px; border:1px solid lightgrey; color: #101F01; text-align:left;">
</td>
</tr>
</table>
<div style="height:20px;"></div>

<h2>Welcome to Kiara Optometry's Algorithm Refraction.</h2>
<table>

<div style="height:10px;"></div>

  <tr class="white">
    <th>Current RX</th>
    <th>Sides</th>
    <th>Sph</th>
    <th>Cyl</th>
    <th>Axis</th>
    <th>SE Diff</th>
    <th>DC</th>
  </tr>

  <!-- Now RX -->
  <tr class="white">
<td rowspan="2">
  <div class="choice-group">
    <input type="radio" id="wear-glasses" name="wearType" value="glasses">
    <label for="wear-glasses">Glasses</label>

    <input type="radio" id="wear-contacts" name="wearType" value="contacts">
    <label for="wear-contacts">Contact Lens</label>
  </div>
</td>
    <td>Right</td>
    <td><input id="s1_od" placeholder="+0.00"></td>
    <td><input id="c1_od" placeholder="+0.00"></td>
    <td><input id="a1_od" placeholder="0"></td>
    <td id="now-se-diff-od">‚Äî</td>
    <td>‚Äî</td>
  </tr>

  <tr class="white">
    <td>Left</td>
    <td><input id="s1_os" placeholder="+0.00"></td>
    <td><input id="c1_os" placeholder="+0.00"></td>
    <td><input id="a1_os" placeholder="0"></td>
    <td>‚Äî</td>
    <td>‚Äî</td>
  </tr>

<tr>
<td colspan="7" style="padding:5px; border:none;"></td>
</tr>

<tr class="comfort">
  <td colspan="7" style="padding:10px; color: #101F01; text-align:left;">
<span class="toggle-btn" data-target="toggle-section-comfort"
          style="cursor:pointer; color: #101F01; user-select:none; margin-right:15px;">
<b>Comfy Clearer Rx</b> 
</span>

<span id="testToggle1" style="cursor:pointer; user-select:none; color: #101F01; margin-left:px;">
  ‚óè Test Not Done
</span>
</td>

<tbody class="toggle-section-comfort" style="display:none;">
<tr class="comfort">
 <td colspan="7" style="padding:5px; color: #101F01; text-align:left;">
    <span style="margin-left:15px;  margin-right:15px; text-decoration:none; cursor:pointer; color:#101F01; user-select:none;"
          onclick="event.stopPropagation(); let t=document.getElementById('deficit-rows-comfort'); t.style.display=t.style.display==='none'?'table-row-group':'none';">
     ‚ñº‚ñ≤ Test
    </span>

<span class="toggle-btn" data-target="toggle-section-comfort-rx"
          style="cursor:pointer; color: #101F01; user-select:none; margin-right:15px;">
      ‚ñº‚ñ≤ Results 
    </span>
  </td>
</tr>
</tbody>

  <tbody id="deficit-rows-comfort" style="display:none;">

  <!-- Deficit Rows -->
<tr class="white">
<th colspan="1">Test</th>
<th>Sides</th>
<th>Sph</th>
<th colspan="1">Cyl</th>
<th>Axis</th>
<th>SE Diff</th>
<th>DC</th>
  </tr>
 
<tr class="white">
    <td rowspan="1">FC DC Error<br>Notes</td>
<td>Both</td>

    <td><input id="dc-sph-ou-notes" placeholder="+0.00"></td>
    <td><input id="c2_ou_notes" placeholder="+0.00"></td>
    <td><input id="a2_ou_notes" placeholder="0"></td>
    <td id="def-se-diff-ou-notes">‚Äî</td>
    <td id="now-dc-ou-notes">BAL</td> 
  </tr>
<script>
function formatToNearestQuarter(value) {
  let num = parseFloat(value);
  if (isNaN(num)) return "+0.00";
  // round to nearest 0.25
  let rounded = Math.round(num / 0.25) * 0.25;
  return (rounded >= 0 ? "+" : "") + rounded.toFixed(2);
}

function formatAxis(value) {
  let num = parseInt(value, 10);
  if (isNaN(num)) return "180";
  if (num <= 0) return "180";
  if (num > 180) return "180";
  return String(num);
}

function attachNoteHandlers() {
  const ids = [
    "dc-sph-ou-notes", "c2_ou_notes", "a2_ou_notes"
  ];

  ids.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;

    el.addEventListener("blur", () => {
      let val = el.value.trim();

      if (id.includes("a2_")) {
        // axis formatting
        el.value = formatAxis(val);
      } else {
        // sph/cyl formatting
        el.value = formatToNearestQuarter(val);
      }
    });
  });
}

// Run after DOM is ready
document.addEventListener("DOMContentLoaded", attachNoteHandlers);
</script>



<tr class="paleviolet">
    <td><b>Adjusted<br>FC DC Error<b></td>
<td>Both</td>
    <td><input id="dc-sph-ou" placeholder="+0.00"></td>
    <td><input id="c2_ou" placeholder="+0.00"></td>
    <td><input id="a2_ou" placeholder="0"></td>
    <td id="def-se-diff-ou">‚Äî</td>
    <td id="dc-ou">‚Äî</td>
  </tr>

<tr class="now">
  <td rowspan="2">FC DC<br>Balance</td>
<td>Right</td>
  <td id="final-sph-ou-re">0.00</td>
  <td id="final-cyl-ou-re">0.00</td>
  <td id="final-axis-ou-re">0</td>
  <td id="final-se-ou-re" style="display:none;">‚Äî</td>
  <td id="bypass-final-ou">‚Äî</td>
  <td id="final-dc-ou-re">‚Äî</td>
</tr>
<tr class="now-comfort">
 <td>Left</td>

  <td id="final-sph-ou-le">0.00</td>
  <td id="final-cyl-ou-le">0.00</td>
  <td id="final-axis-ou-le">0</td>
  <td id="final-se-ou-le" style="display:none;">‚Äî</td>
  <td>‚Äî</td>
  <td id="final-dc-ou-le">‚Äî</td>
</tr>

<tr class="now-comfort">
  <td>
Adjustments
</td>
<td>Both</td>
<td colspan="5" style="padding:1px; text-align:left;">
    <div>
<!-- Clickable control to apply -0.25 x 180 -->
    <span class="addMinus025" role="button" 
          style="cursor:pointer; user-select:none; margin-right:30px; margin-left:20px;">
      Apply -0.25 √ó 180
    </span>

‚óè
<span class="sph-btn" data-group="ou" data-step="-0.25"
          style="cursor:pointer; text-decoration:none; color:green; margin-right:5px; margin-left:0x;">
     S-0.25
   </span>

<span class="sph-btn" data-group="ou" data-step="0.25"
          style="cursor:pointer; text-decoration:none; color:red; margin-right:30px; margin-left:0px;">
     S+0.25
</span>

‚óè
<span class="testStatus" style="cursor:pointer; color: #101F01; user-select:none; text-decoration:none; margin-right:2px; margin-left:0px;">
  Test ongoing
</span>


</td>
</div>
</tr>

</tbody>


<tbody class="toggle-section-comfort-rx" style="display:none;">
<tr>
<td colspan="7" style="padding:1px; border:none;"></td>
</tr>
<tr class="comfort">
<td><b>Results</b></td>
<td><b>Sides</b></td>
<td><b>Sph</b></td>
<td><b>Cyl</b></td>
<td><b>Axis</b></td>
<td><b>SE Diff</b></td>
<td><b>DC</b></td>
  </tr>

<tr class="comfort">
    <td rowspan="2">Final RX</td>
<td>Right</td>

    <td id="res-sph-ou-re">0.00</td>
    <td id="res-cyl-ou-re">0.00</td>
    <td id="res-axis-ou-re">0</td>
    <td id="res-se-diff-ou-re">‚Äî</td>
    <td id="res-dc-ou-re">BAL</td>
  </tr>

<tr class="comfort">
 <td>Left</td>
    <td id="res-sph-ou-le">0.00</td>
    <td id="res-cyl-ou-le">0.00</td>
    <td id="res-axis-ou-le">0</td>
    <td >‚Äî</td>
    <td id="res-dc-ou-le">BAL</td>
  </tr>

<tr class="comfort">
    <td id="analysis-ou" colspan="7" style="text-align:left; padding-left:20px;">
    <!-- Combined analysis text for OU will appear here -->
  </td>
</tr>
</tbody>


<tr>
<td colspan="7" style="padding:5px; border:none;"></td>
</tr>




<tr class="table-headernow">
<td colspan="7" style="padding:10px; color: #241D0C; text-align:left;">
<b>Sharpest Ever Rx</b>
    
<span style="margin-left:15px; margin-right:15px; text-decoration:none; cursor:pointer; color:#241D0C; user-select:none;"
          onclick="event.stopPropagation(); let t=document.getElementById('deficit-rows-sharper'); t.style.display=t.style.display==='none'?'table-row-group':'none';">
      ‚ñº‚ñ≤ Test
    </span>

 <span class="toggle-btn" data-target="toggle-section-sharper-rx" 
      style="margin-left:0px; margin-right:15px; cursor:pointer; color: #241D0C; user-select:none;">
‚ñº‚ñ≤ Results
</span>

<span id="testToggle2" style="cursor:pointer; user-select:none; color: #241D0C;">
  ‚óè Test Not Done
</span>

</td>
</tr>





<script>
document.querySelectorAll('.toggle-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const target = btn.getAttribute('data-target');
    document.querySelectorAll(`.${target}`).forEach(el => {
      el.style.display = (el.style.display === 'none' || el.style.display === '') ? 'table-row-group' : 'none';
    });
  });
});
</script>
<script>
function makeToggle(spanId) {
  const span = document.getElementById(spanId);
  let testDone = false; // initial state

  span.addEventListener("click", () => {
    testDone = !testDone; // toggle state

    if (testDone) {
      span.textContent = "‚óè Test Completed ‚úî";
      span.style.textDecoration = "none"; // underline when done
      span.style.fontStyle = "normal";         // normal font
    } else {
      span.textContent = "  ‚óè Test Not Done";
      span.style.textDecoration = "none";      // remove underline
      span.style.fontStyle = "normal";         // 
    }
  });
}

// Apply to both spans
makeToggle("testToggle1");
makeToggle("testToggle2");
</script>


<!-- Deficit Rows (wrapped in toggle container) -->
<tbody id="deficit-rows-sharper" style="display:none;">


  <tr class="white">
<td colspan="1"><b>Test</b></td>
<td><b>Sides</b></td>
<td><b>Sph to Bal DC</b></td>
<td colspan="2"><b>Cyl & Axis to Bal FC</b></td>
<td><b>SE Diff</b></td>
<td><b>DC</b></td>

  </tr>

  <tr class="white">
    <td rowspan="2">FC DC Error<br>Notes</td>
<td>Right</td>

    <td><input id="dc-sph-od-notes" placeholder="+0.00"></td>
    <td><input id="c2_od_notes" placeholder="+0.00"></td>
    <td><input id="a2_od_notes" placeholder="0"></td>
    <td id="def-se-diff-od-notes">‚Äî</td>
    <td id="now-dc-od-notes">BAL</td> 
  </tr>

  <tr class="white">
<td>Left</td>

    <td><input id="dc-sph-os-notes" placeholder="+0.00"></td>
    <td><input id="c2_os_notes" placeholder="+0.00"></td>
    <td><input id="a2_os_notes" placeholder="0"></td>
    <td id="def-se-diff-os-notes">‚Äî</td>
    <td id="now-dc-os-notes">BAL</td> 
  </tr>

<script>
function formatToNearestQuarter(value) {
  let num = parseFloat(value);
  if (isNaN(num)) return "+0.00";
  // round to nearest 0.25
  let rounded = Math.round(num / 0.25) * 0.25;
  return (rounded >= 0 ? "+" : "") + rounded.toFixed(2);
}

function formatAxis(value) {
  let num = parseInt(value, 10);
  if (isNaN(num)) return "180";
  if (num <= 0) return "180";
  if (num > 180) return "180";
  return String(num);
}

function attachNoteHandlers() {
  const ids = [
    "dc-sph-od-notes", "c2_od_notes", "a2_od_notes",
    "dc-sph-os-notes", "c2_os_notes", "a2_os_notes"
  ];

  ids.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;

    el.addEventListener("blur", () => {
      let val = el.value.trim();

      if (id.includes("a2_")) {
        // axis formatting
        el.value = formatAxis(val);
      } else {
        // sph/cyl formatting
        el.value = formatToNearestQuarter(val);
      }
    });
  });
}

// Run after DOM is ready
document.addEventListener("DOMContentLoaded", attachNoteHandlers);
</script>


  <tr class="paleviolet">
    <td rowspan="2"><B>Adjusted<br>FC DC Error</b></td>
<td>Right</td>

    <td><input id="dc-sph-od" placeholder="+0.00"></td>
    <td><input id="c2_od" placeholder="+0.00"></td>
    <td><input id="a2_od" placeholder="0"></td>
    <td id="def-se-diff-od">‚Äî</td>
    <td id="now-dc-od">‚Äî</td> 
  </tr>

  <tr class="paleviolet">
<td>Left</td>

    <td><input id="dc-sph-os" placeholder="+0.00"></td>
    <td><input id="c2_os" placeholder="+0.00"></td>
    <td><input id="a2_os" placeholder="0"></td>
    <td id="def-se-diff-os">‚Äî</td>
    <td id="now-dc-os">‚Äî</td> 
  </tr>

  <tr class="now">
    <td rowspan="2">FC DC<br>Balance</td>
<td>Right</td>

    <td id="final-sph-od">0.00</td>
    <td id="final-cyl-od">0.00</td>
    <td id="final-axis-od">0</td>
    <td id="final-se-od" style="display:none;">‚Äî</td>
    <td id="bypass-final-mono">‚Äî</td>
    <td id="final-dc-od">BAL </td>
  
  </tr>
  <tr class="now">
    <td>Left</td>
    <td id="final-sph-os">0.00</td>
    <td id="final-cyl-os">0.00</td>
    <td id="final-axis-os">0</td>
    <td id="final-se-os" style="display:none;">‚Äî</td>
    <td>‚Äî</td>
    <td id="final-dc-os">BAL </td>
    
  </tr>

  <tr class="now">
<td rowspan="3">
Adjustments
</td>
<td style="display:none;">Both</td>
<td colspan="5" style="padding:7px; text-align:left; display:none;">
 <!-- Clickable control to apply -0.25 x 180 -->

    <span class="addMinus025" role="button" 
          style="cursor:pointer; user-select:none; margin-right:30px; margin-left:20px;">
      Apply -0.25 √ó 180
    </span> 
‚óè
<!-- SPH Controls -->
    <span class="sph-btn" data-group="mono" data-step="-0.25"
          style="cursor:pointer; text-decoration:none; color:green; margin-right:5px; margin-left:0px;">
     S-0.25
   </span>
    <span class="sph-btn" data-group="mono" data-step="0.25"
          style="cursor:pointer; text-decoration:none; color:red; margin-right:30px; margin-left:0px;">
     S+0.25
</span>

‚óè
<span class="testStatus" style="cursor:pointer; color: #101F01; user-select:none; text-decoration:none; margin-right:2px; margin-left:0px;">
  Test ongoing..
</span>



</td>
</tr>
<tr><td>Right</td>
<td colspan="5" style="padding:7px; text-align:left;">
    <span class="addMinus025" role="button" 
          style="cursor:pointer; user-select:none; margin-right:30px; margin-left:20px;">
      Apply -0.25 √ó 180
    </span> 
‚óè
<span class="sph-btn-mono" data-eye="od" data-step="-0.25"
          style="cursor:pointer; user-select:none; text-decoration:none; color:green; margin-right:5px; margin-left:0px;">
     S-0.25
   </span>
<span class="sph-btn-mono" data-eye="od" data-step="0.25"
          style="cursor:pointer; user-select:none; text-decoration:none; color:red; margin-right:30px; margin-left:0px;">
     S+0.25
</span>
‚óè
<span class="testStatus" style="cursor:pointer; color: #101F01; user-select:none; text-decoration:none; margin-right:2px; margin-left:0px;">
  Test ongoing..
</span>
</td></tr>


<tr><td>Left</td>
<td colspan="5" style="padding:7px; text-align:left;">
    <span class="addMinus025" role="button" 
          style="cursor:pointer; user-select:none; margin-right:30px; margin-left:20px;">
      Apply -0.25 √ó 180
    </span> 
‚óè
<span class="sph-btn-mono" data-eye="os" data-step="-0.25"
          style="cursor:pointer; user-select:none; text-decoration:none; color:green; margin-right:5px; margin-left:0px;">
     S-0.25
   </span>
<span class="sph-btn-mono" data-eye="os" data-step="0.25"
          style="cursor:pointer; user-select:none; text-decoration:none; color:red; margin-right:30px; margin-left:0px;">
     S+0.25
</span>
‚óè
<span class="testStatus" style="cursor:pointer; color: #101F01; user-select:none; text-decoration:none; margin-right:2px; margin-left:0px;">
  Test ongoing..
</span>
</td></tr>

</tbody>


<tbody class="toggle-section-sharper-rx" style="display:none;">
<tr>
<td colspan="7" style="padding:1px; border:none;"></td>
</tr>
<tr class="table-headernow">
<td><b>Results</b></td>
<td><b>Sides</b></td>
<td><b>Sph</b></td>
<td><b>Cyl</b></td>
<td><b>Axis</b></td>
<td><b>SE Diff</b></td>
<td><b>DC</b></td>
  </tr>

  <tr class="table-headernow">
    <td rowspan="2">Final RX</td>
<td>Right</td>
    <td id="res-sph-od-2">0.00</td>
    <td id="res-cyl-od-2">0.00</td>
    <td id="res-axis-od-2">0</td>
    <td id="res-se-od-2" style="display:none;">‚Äî</td>
    <td id="bypass">‚Äî</td>
    <td id="res-dc-od-2">BAL</td> 
  </tr>
  <tr class="table-headernow">
    <td>Left</td>
    <td id="res-sph-os-2">0.00</td>
    <td id="res-cyl-os-2">0.00</td>
    <td id="res-axis-os-2">0</td>
    <td>‚Äî</td>    
    <td id="res-se-os-2" style="display:none;">‚Äî</td>
    <td id="res-dc-os-2">BAL</td> 
  </tr>

</tbody>



</table>




<script>
document.addEventListener("DOMContentLoaded", () => {

  // Shared state for all mirrors
  let testDone = false;

  // Function to update all mirrors
  function updateTestStatusMirrors() {
    document.querySelectorAll(".testStatus").forEach(el => {
      el.textContent = testDone ? "Test done" : "Test ongoing..";
      el.style.color = testDone ? "green" : "black";
    });
  }

  // Attach click listener to all current and future mirrors
  function attachMirrorListeners() {
    document.querySelectorAll(".testStatus").forEach(el => {
      if(!el.dataset.listenerAttached){
        el.addEventListener("click", () => {
          testDone = !testDone;
          updateTestStatusMirrors();
        });
        el.dataset.listenerAttached = "true";
      }
    });
  }

  // Initial setup
  attachMirrorListeners();
  updateTestStatusMirrors();

  // Optional: observe DOM changes to attach listeners to newly added mirrors
  const observer = new MutationObserver(() => {
    attachMirrorListeners();
  });
  observer.observe(document.body, { childList: true, subtree: true });

});
</script>

<script>
document.addEventListener("DOMContentLoaded", () => {

  let testDone = false; // shared state

  function updateMirrors() {
  document.querySelectorAll(".testStatus").forEach(el => {
    if (testDone) {
      el.textContent = "RX Finalized";
      el.style.textDecoration = "none";  // 
      el.style.fontStyle = "normal";          // normal font
      el.style.color = "#285C00";
    } else {
      el.textContent = "RX Not Final";
      el.style.textDecoration = "none";       // remove underline
      el.style.fontStyle = "italic";          // italic for ongoing
      el.style.color = "#6E0900";
    }
  });
}

  // Mirror click behavior: toggle
  document.querySelectorAll(".testStatus").forEach(el => {
    el.addEventListener("click", () => {
      testDone = !testDone; // toggle on click
      updateMirrors();
    });
  });

  // Reset mirrors whenever a calculator input changes
  const inputIds = [
    "s1_od","c1_od","a1_od",
    "s1_os","c1_os","a1_os",
    "dc-sph-od","c2_od","a2_od",
    "dc-sph-os","c2_os","a2_os",
    "dc-sph-ou","c2_ou","a2_ou"
  ];

  inputIds.forEach(id => {
    const el = document.getElementById(id);
    if(el) el.addEventListener("input", () => {
      testDone = false; // revert
      updateMirrors();
    });
  });

  // Reset mirrors on adjustment buttons (Cyl -0.25, S -0.25, S +0.25)
  const adjustmentButtons = document.querySelectorAll(".addMinus025, .sph-btn, .sph-btn-mono");
  adjustmentButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      testDone = false; // revert
      updateMirrors();
    });
  });

  updateMirrors(); // initialize
});
</script>



<script>
document.addEventListener("DOMContentLoaded", () => {

// ---------- Toggle for extra -0.25 @ 180 (mirror buttons) ----------
let extraMinus025 = false;

// helper to update all mirror buttons' label + color so they stay in sync
function updateMinus025Buttons() {
  document.querySelectorAll('.addMinus025').forEach(b => {
    b.style.color = extraMinus025 ? 'red' : 'black';
    b.textContent = extraMinus025 ? '‚óè Horizon Enhance' : '‚óè All Angles Even';
  });
}

// attach listener to every mirror button
document.querySelectorAll('.addMinus025').forEach(btn => {
  btn.addEventListener('click', () => {
    extraMinus025 = !extraMinus025;
    updateMinus025Buttons();
    combineAll();
  });
});

// set initial text/color for any buttons (in case they exist on load)
updateMinus025Buttons();

  // ---------- Helpers ----------
function combineEyeWithout025(S_now, C_now, A_now, DC_S, C2, A2){
  const savedExtra = extraMinus025;       // save current state
  extraMinus025 = false;                  // temporarily disable -0.25
  const result = combineEyeWithDeficit(S_now, C_now, A_now, DC_S, C2, A2);
  extraMinus025 = savedExtra;             // restore state
  return result;
}

  // ---------- Helpers ----------
  function safeParseFloat(v){
    if(v === null || v === undefined) return 0;
    if(typeof v === "number") return Number.isFinite(v) ? v : 0;
    v = String(v).trim();
    if(v === "" || v === "‚Äî" || v === "‚Äì") return 0;
    v = v.replace(',', '.');
    const n = parseFloat(v);
    if(!Number.isNaN(n)) return n;
    const m = v.match(/[+-]?(?:\d+\.?\d*|\.\d+)/);
    return m ? parseFloat(m[0]) : 0;
  }

  function roundQuarterNumber(n){ return Math.round(safeParseFloat(n) * 4) / 4; }
  function formatValueForDisplay(n){ const val = roundQuarterNumber(n); return (val >= 0 ? "+" : "") + val.toFixed(2); }

  function calcSENumber(S, C){ S = safeParseFloat(S); C = safeParseFloat(C); return S + C/2; }
  function formatSEforDisplay(n){ return (n >= 0 ? "+" : "") + n.toFixed(2); }

  function formatSEDiffForDisplay(n){
    const num = safeParseFloat(n);
    if (isNaN(num)) return "‚Äî";
    return (num >= 0 ? "+" : "") + num.toFixed(2);
  }

  function deg2rad(d){ return d * Math.PI / 180; }
  function rad2deg(r){ return r * 180 / Math.PI; }

  function toMinusCyl({S, C, A}) {
    S = safeParseFloat(S); C = safeParseFloat(C); A = Math.round(safeParseFloat(A) || 0);
    if (C > 0) { S = S + C; C = -C; A = (A + 90) % 180; }
    A = ((A % 180) + 180) % 180;
    return { S, C, A };
  }

  function setIf(id, val){
    const el = document.getElementById(id);
    if(el) el.textContent = val;
  }

  function dcStatusText(val){
    let v = roundQuarterNumber(val);
    if(v === 0) return { text: "BAL", color: "black" };
    const absVal = Math.abs(v);
    const level = Math.max(Math.round(absVal / 0.25), 1);
    if(v > 0) return { text: `G${level} Over -${absVal.toFixed(2)}`, color: "green" };
    return { text: `R${level} Under -${absVal.toFixed(2)}`, color: "red" };
  }

  function updateDCSummaryForEye(dcInputId, dcDisplayId, nowDCId){
    const inputEl = document.getElementById(dcInputId);
    const displayEl = document.getElementById(dcDisplayId);
    const nowDCEl = document.getElementById(nowDCId);
    if(!inputEl) return;
    const val = safeParseFloat(inputEl.value);
    const info = dcStatusText(val);
    if(displayEl){ displayEl.textContent = info.text; displayEl.style.color = info.color; }
    if(nowDCEl){ nowDCEl.textContent = info.text.split(' ')[0]; nowDCEl.style.color = info.color; }
  }

  // ---------- Core vector combine function ----------
  // Combines NowRx (S1,C1,A1) with fan-chart cylinder (C2,A2) and DC sphere (DC_S)
  function combineEyeWithDeficit(S_now, C_now, A_now, DC_S, C2, A2){
    const rx1 = toMinusCyl({ S: S_now, C: C_now, A: A_now });
    const S2_from_FC = -safeParseFloat(C2) / 2;
    const rx2 = toMinusCyl({ S: S2_from_FC, C: C2, A: A2 });

    const M1 = rx1.S + rx1.C / 2;
    const J01 = -rx1.C/2 * Math.cos(2 * deg2rad(rx1.A));
    const J451 = -rx1.C/2 * Math.sin(2 * deg2rad(rx1.A));

    const M2 = rx2.S + rx2.C / 2;
    const J02 = -rx2.C/2 * Math.cos(2 * deg2rad(rx2.A));
    const J452 = -rx2.C/2 * Math.sin(2 * deg2rad(rx2.A));

    let M_total = M1 + M2 + safeParseFloat(DC_S);
    let J0_total = J01 + J02;
    let J45_total = J451 + J452;

    if (extraMinus025) {
    // Add cyl-only vector for -0.25 √ó 180 (J0 = +0.25)
    M_total -= 0.0625;
    J0_total += 0.125;
    }
    
    

    const C_total_raw = -2 * Math.sqrt(J0_total * J0_total + J45_total * J45_total);
    const S_total_raw = M_total - C_total_raw / 2;
    let A_total = 0.5 * rad2deg(Math.atan2(J45_total, J0_total));
    if(A_total < 0) A_total += 180;
    A_total = Math.round(A_total); // axis to nearest 1 degree

    const S_total_q = roundQuarterNumber(S_total_raw);
    const C_total_q = roundQuarterNumber(C_total_raw);

    const SE_numeric = S_total_q + C_total_q / 2;

    return { S: S_total_q, C: C_total_q, A: A_total, SE: SE_numeric };
  }

  // ---------- Main combine function (updates OU + Mono + SE diffs + DC summaries) ----------
  function combineAll(){
    try {


      // --- Read Now Rx ---
      const S_RE = safeParseFloat(document.getElementById("s1_od")?.value || 0);
      const C_RE = safeParseFloat(document.getElementById("c1_od")?.value || 0);
      const A_RE = Math.round(safeParseFloat(document.getElementById("a1_od")?.value || 0));

      const S_LE = safeParseFloat(document.getElementById("s1_os")?.value || 0);
      const C_LE = safeParseFloat(document.getElementById("c1_os")?.value || 0);
      const A_LE = Math.round(safeParseFloat(document.getElementById("a1_os")?.value || 0));

      // write Now SE (numeric) into any existing now-se ids
      const nowSE_RE_num = calcSENumber(S_RE, C_RE);
      const nowSE_LE_num = calcSENumber(S_LE, C_LE);
      setIf("now-se-od", formatSEforDisplay(nowSE_RE_num));
      setIf("now-se-os", formatSEforDisplay(nowSE_LE_num));
      setIf("now-se-od-2", formatSEforDisplay(nowSE_RE_num));
      setIf("now-se-os-2", formatSEforDisplay(nowSE_LE_num));

      // baseline now diff (RE - LE) ‚Äî high sensitivity (0.01)
      const nowDiff = nowSE_RE_num - nowSE_LE_num;
      setIf("now-se-diff", formatSEDiffForDisplay(nowDiff));
      setIf("now-se-diff-od", formatSEDiffForDisplay(nowDiff));
      setIf("now-se-diff-os", formatSEDiffForDisplay(nowDiff));

      // --- Read Deficit OU ---
      const DC_OU = safeParseFloat(document.getElementById("dc-sph-ou")?.value || 0);
      const C2_OU = safeParseFloat(document.getElementById("c2_ou")?.value || 0);
      const A2_OU = Math.round(safeParseFloat(document.getElementById("a2_ou")?.value || 0));

      // OU combine for each eye (Now Rx + OU deficit vectorially)
      const RE_ou = combineEyeWithDeficit(S_RE, C_RE, A_RE, DC_OU, C2_OU, A2_OU);
      const LE_ou = combineEyeWithDeficit(S_LE, C_LE, A_LE, DC_OU, C2_OU, A2_OU);

      // write OU result fields
      setIf("res-sph-ou-re", formatValueForDisplay(RE_ou.S));
      setIf("res-cyl-ou-re", formatValueForDisplay(RE_ou.C));
const axisRE_OU = (Math.abs(RE_ou.C) < 0.001) ? "‚Äî" : (RE_ou.A === 0 ? "180" : String(RE_ou.A));
setIf("res-axis-ou-re", axisRE_OU);
setIf("res-se-ou-re", formatSEforDisplay(RE_ou.SE));

      setIf("res-sph-ou-le", formatValueForDisplay(LE_ou.S));
      setIf("res-cyl-ou-le", formatValueForDisplay(LE_ou.C));
const axisLE_OU = (Math.abs(LE_ou.C) < 0.001) ? "‚Äî" : (LE_ou.A === 0 ? "180" : String(LE_ou.A));
setIf("res-axis-ou-le", axisLE_OU);
setIf("res-se-ou-le", formatSEforDisplay(LE_ou.SE));

// persist OU baseline sph so SPH buttons always reference the true base
const elResSphOuRe = document.getElementById("res-sph-ou-re");
if (elResSphOuRe) elResSphOuRe.dataset.base = String(RE_ou.S);
const elResSphOuLe = document.getElementById("res-sph-ou-le");
if (elResSphOuLe) elResSphOuLe.dataset.base = String(LE_ou.S);


      // OU SE diff ‚Äî high sensitivity (0.01)
      const ouDiff = RE_ou.SE - LE_ou.SE;
      setIf("res-se-diff-ou", formatSEDiffForDisplay(ouDiff));
      setIf("res-se-diff-ou-re", formatSEDiffForDisplay(ouDiff));
      setIf("res-se-diff-ou-le", formatSEDiffForDisplay(ouDiff));

      // --- Mono combines (per-eye deficits) ---
      const DC_RE = safeParseFloat(document.getElementById("dc-sph-od")?.value || 0);
      const C2_RE = safeParseFloat(document.getElementById("c2_od")?.value || 0);
      const A2_RE = Math.round(safeParseFloat(document.getElementById("a2_od")?.value || 0));

      const DC_LE = safeParseFloat(document.getElementById("dc-sph-os")?.value || 0);
      const C2_LE = safeParseFloat(document.getElementById("c2_os")?.value || 0);
      const A2_LE = Math.round(safeParseFloat(document.getElementById("a2_os")?.value || 0));

      const RE_mono = combineEyeWithDeficit(S_RE, C_RE, A_RE, DC_RE, C2_RE, A2_RE);
      const LE_mono = combineEyeWithDeficit(S_LE, C_LE, A_LE, DC_LE, C2_LE, A2_LE);

      // write Mono result fields
      setIf("res-sph-od-2", formatValueForDisplay(RE_mono.S));
      setIf("res-cyl-od-2", formatValueForDisplay(RE_mono.C));
const axisOD_MONO = (Math.abs(RE_mono.C) < 0.001) ? "‚Äî" : (RE_mono.A === 0 ? "180" : String(RE_mono.A));
setIf("res-axis-od-2", axisOD_MONO);
setIf("res-se-od-2", formatSEforDisplay(RE_mono.SE));

      setIf("res-sph-os-2", formatValueForDisplay(LE_mono.S));
      setIf("res-cyl-os-2", formatValueForDisplay(LE_mono.C));
const axisOS_MONO = (Math.abs(LE_mono.C) < 0.001) ? "‚Äî" : (LE_mono.A === 0 ? "180" : String(LE_mono.A));
setIf("res-axis-os-2", axisOS_MONO);
setIf("res-se-os-2", formatSEforDisplay(LE_mono.SE));

// persist Mono baseline sph
const elResSphOd2 = document.getElementById("res-sph-od-2");
if (elResSphOd2) elResSphOd2.dataset.base = String(RE_mono.S);
const elResSphOs2 = document.getElementById("res-sph-os-2");
if (elResSphOs2) elResSphOs2.dataset.base = String(LE_mono.S);

      // Mono SE diff ‚Äî high sensitivity (0.01)
      const monoDiff = RE_mono.SE - LE_mono.SE;
      setIf("res-se-diff-2", formatSEDiffForDisplay(monoDiff));
      setIf("res-se-diff-od-2", formatSEDiffForDisplay(monoDiff));
      setIf("res-se-diff-os-2", formatSEDiffForDisplay(monoDiff));

// ---------- Final OU (no -0.25) ----------
const final_RE_ou = combineEyeWithout025(S_RE, C_RE, A_RE, DC_OU, C2_OU, A2_OU);
const final_LE_ou = combineEyeWithout025(S_LE, C_LE, A_LE, DC_OU, C2_OU, A2_OU);

setIf("final-sph-ou-re", formatValueForDisplay(final_RE_ou.S));
setIf("final-cyl-ou-re", formatValueForDisplay(final_RE_ou.C));
setIf("final-axis-ou-re", (Math.abs(final_RE_ou.C)<0.001)?"‚Äî":(final_RE_ou.A===0?"180":final_RE_ou.A));
setIf("final-se-ou-re", formatSEforDisplay(final_RE_ou.SE));
setIf("final-dc-ou-re","BAL");

setIf("final-sph-ou-le", formatValueForDisplay(final_LE_ou.S));
setIf("final-cyl-ou-le", formatValueForDisplay(final_LE_ou.C));
setIf("final-axis-ou-le", (Math.abs(final_LE_ou.C)<0.001)?"‚Äî":(final_LE_ou.A===0?"180":final_LE_ou.A));
setIf("final-se-ou-le", formatSEforDisplay(final_LE_ou.SE));
setIf("final-dc-ou-le","BAL");

// ---------- Final Mono (no -0.25) ----------
const final_RE_mono = combineEyeWithout025(S_RE, C_RE, A_RE, DC_RE, C2_RE, A2_RE);
const final_LE_mono = combineEyeWithout025(S_LE, C_LE, A_LE, DC_LE, C2_LE, A2_LE);

setIf("final-sph-od", formatValueForDisplay(final_RE_mono.S));
setIf("final-cyl-od", formatValueForDisplay(final_RE_mono.C));
setIf("final-axis-od", (Math.abs(final_RE_mono.C)<0.001)?"‚Äî":(final_RE_mono.A===0?"180":final_RE_mono.A));
setIf("final-se-od", formatSEforDisplay(final_RE_mono.SE));
setIf("final-dc-od","BAL");

setIf("final-sph-os", formatValueForDisplay(final_LE_mono.S));
setIf("final-cyl-os", formatValueForDisplay(final_LE_mono.C));
setIf("final-axis-os", (Math.abs(final_LE_mono.C)<0.001)?"‚Äî":(final_LE_mono.A===0?"180":final_LE_mono.A));
setIf("final-se-os", formatSEforDisplay(final_LE_mono.SE));
setIf("final-dc-os","BAL");



// --- Bypass calculation (rounded to nearest 0.25 D) ---
// Mono (OD/OS)
const bypassRE = safeParseFloat(document.getElementById("res-se-od-2")?.textContent);
const bypassLE = safeParseFloat(document.getElementById("res-se-os-2")?.textContent);

if (!Number.isNaN(bypassRE) && !Number.isNaN(bypassLE)) {
  let bypassDiff = bypassRE - bypassLE;
  bypassDiff = Math.round(bypassDiff * 8) / 8; // round to nearest 0.125 D
  setIf("bypass", formatSEDiffForDisplay(bypassDiff));
}

// Final Mono (OD/OS)
const finalMonoRE = safeParseFloat(document.getElementById("final-se-od")?.textContent);
const finalMonoLE = safeParseFloat(document.getElementById("final-se-os")?.textContent);

if (!Number.isNaN(finalMonoRE) && !Number.isNaN(finalMonoLE)) {
  let bypassDiffMono = finalMonoRE - finalMonoLE;
  bypassDiffMono = Math.round(bypassDiffMono * 8) / 8; // nearest 0.125 D
  setIf("bypass-final-mono", formatSEDiffForDisplay(bypassDiffMono));
}

// Final OU (RE/LE)
const finalOuRE = safeParseFloat(document.getElementById("final-se-ou-re")?.textContent);
const finalOuLE = safeParseFloat(document.getElementById("final-se-ou-le")?.textContent);

if (!Number.isNaN(finalOuRE) && !Number.isNaN(finalOuLE)) {
  let bypassDiffOu = finalOuRE - finalOuLE;
  bypassDiffOu = Math.round(bypassDiffOu * 8) / 8; // nearest 0.125 D
  setIf("bypass-final-ou", formatSEDiffForDisplay(bypassDiffOu));
}



// Track offsets in 0.25 steps for OU and Mono
const sphOffsets = { ou: 0, mono: 0 };

document.querySelectorAll('.sph-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const group = btn.dataset.group;   // "ou" or "mono"
    const step = parseFloat(btn.dataset.step); // -0.25 or +0.25

    // Update offset
    sphOffsets[group] += step;

    // Reapply adjustment
    applySphOffset(group);
  });
});


// Call this after your main OU/Mono results are calculated
function applySphOffset(group) {
  const ids = (group === "ou")
    ? { right: "res-sph-ou-re", left: "res-sph-ou-le", dcr: "res-dc-ou-re", dcl: "res-dc-ou-le" }
    : { right: "res-sph-od-2", left: "res-sph-os-2", dcr: "res-dc-od-2", dcl: "res-dc-os-2" };

  const rightCell = document.getElementById(ids.right);
  const leftCell  = document.getElementById(ids.left);
  const dcRight   = document.getElementById(ids.dcr);
  const dcLeft    = document.getElementById(ids.dcl);

  if (!rightCell || !leftCell) return;

  // Preserve the original base (only set once)
  if (!rightCell.dataset.base) rightCell.dataset.base = rightCell.textContent.trim() || "0";
  if (!leftCell.dataset.base)  leftCell.dataset.base  = leftCell.textContent.trim() || "0";

  const baseRight = parseFloat(rightCell.dataset.base) || 0;
  const baseLeft  = parseFloat(leftCell.dataset.base) || 0;

// Formatter: always show + for positives
function formatSigned(value) {
  const num = parseFloat(value).toFixed(2);
  if (num > 0) return "+" + num;
  return num; // negatives already have -, zero stays 0.00
}

// Apply offset math (fixed so it doesn‚Äôt jump)
const newRight = baseRight + sphOffsets[group];
const newLeft  = baseLeft + sphOffsets[group];

rightCell.textContent = formatSigned(newRight);
leftCell.textContent  = formatSigned(newLeft);


  // Update DC label + color
  const label = getDcLabel(sphOffsets[group]);
  if (dcRight) {
    dcRight.textContent = label.text;
    dcRight.style.color = label.color;
    dcRight.style.fontWeight = "none";
  }
  if (dcLeft) {
    dcLeft.textContent = label.text;
    dcLeft.style.color = label.color;
    dcLeft.style.fontWeight = "none";
  }
}

function getDcLabel(offset) {
  if (offset === 0) return { text: "BAL", color: "black" };
  if (offset < 0) return { text: "G" + Math.abs(offset / 0.25), color: "green" };
  return { text: "R" + (offset / 0.25), color: "red" };
}


      // --- Update DC summary for eyes (ensure OU updates dc-ou) ---
      updateDCSummaryForEye("dc-sph-od", "dc-summary", "now-dc-od");
      updateDCSummaryForEye("dc-sph-os", "dc-summary", "now-dc-os");
      updateDCSummaryForEye("dc-sph-ou", "dc-summary", "dc-ou");

// --- RESET PRESCRIBED DC STATUS TO BAL ---
const prescribedDCEyes = [
  "res-dc-ou-re", "res-dc-ou-le",
  "res-dc-od-2", "res-dc-os-2"
];

prescribedDCEyes.forEach(id => {
  const el = document.getElementById(id);
  if(el) {
    el.textContent = "BAL";
    el.style.color = "black";
    el.style.fontWeight = "none";
  }
});




    } catch (err) {
      console.error("combineAll error:", err);
    }
  }

  // ---------- formatting on blur / axis handling ----------
  function isAxisId(id){
    if(!id) return false;
    return id.startsWith("a");
  }

  function autoFormatInput(el){
    if(!el) return;
    const id = el.id || "";
    let raw = String(el.value || "").trim();
    if(raw === "") return;
    if(isAxisId(id)){
      let num = parseInt(raw, 10);
      if(Number.isNaN(num)) num = 0;
      num = Math.max(0, Math.min(180, num));
      el.value = String(num);
    } else {
      let n = roundQuarterNumber(raw);
      el.value = (n >= 0 ? "+" : "") + n.toFixed(2);
    }
  }

  // ---------- Attach listeners ----------
  const inputIds = [
    "s1_od","c1_od","a1_od",
    "s1_os","c1_os","a1_os",
    "dc-sph-od","c2_od","a2_od",
    "dc-sph-os","c2_os","a2_os",
    "dc-sph-ou","c2_ou","a2_ou"
  ];

  inputIds.forEach(id => {
    const el = document.getElementById(id);
    if(!el) return;
    // live update as you type
    el.addEventListener("input", combineAll);
    // format on blur/enter
    el.addEventListener("blur", (e) => { autoFormatInput(e.target); combineAll(); });
    el.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){ e.preventDefault(); autoFormatInput(e.target); combineAll(); }
    });
  });

  // Also ensure duochrome inputs update summary live
  ["dc-sph-od","dc-sph-os","dc-sph-ou"].forEach(id => {
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener("input", () => {
      updateDCSummaryForEye("dc-sph-od","dc-summary","now-dc-od");
      updateDCSummaryForEye("dc-sph-os","dc-summary","now-dc-os");
      updateDCSummaryForEye("dc-sph-ou","dc-summary","dc-ou");
    });
  });

  // initial run
  combineAll();
});

</script>

<script>
// ---------------- Monocular Adjustments (per eye, live adjust) ----------------

// Attach listeners to monocular sph adjustment buttons
document.querySelectorAll('.sph-btn-mono').forEach(btn => {
  btn.addEventListener('click', () => {
    const eye = btn.dataset.eye;        // "od" or "os"
    const step = parseFloat(btn.dataset.step); // -0.25 or +0.25
    applySphOffsetMonoLive(eye, step);
  });
});

function applySphOffsetMonoLive(eye, step) {
  const ids = (eye === "od")
    ? { sph: "res-sph-od-2", dc: "res-dc-od-2" }
    : { sph: "res-sph-os-2", dc: "res-dc-os-2" };

  const sphCell = document.getElementById(ids.sph);
  const dcCell  = document.getElementById(ids.dc);
  if (!sphCell || !dcCell) return;

  // --- Adjust SPH directly from what's currently shown ---
  const currentVal = parseFloat(sphCell.textContent) || 0;
  const newVal = currentVal + step;
  sphCell.textContent = formatSigned(newVal);

  // --- Adjust DC purely by observing current label and nudging by 1 step ---
  const currentLabel = (dcCell.textContent || "").trim();
  const newLabel = getNextDcLabelByNudge(currentLabel, step);
  dcCell.textContent = newLabel.text;
  dcCell.style.color = newLabel.color;
  dcCell.style.fontWeight = "none";
}

// Format numbers with sign
function formatSigned(value) {
  // ensure standard +/‚àí two-decimal format
  const num = Number(value);
  if (Number.isNaN(num)) return "+0.00";
  const s = num.toFixed(2);
  return (num >= 0 ? "+" : "") + s;
}

// Parse DC string into a numeric offset: BAL -> 0, Rn -> +n, Gn -> -n
function parseDcToNumber(current) {
  const s = String(current || "").toUpperCase().trim();
  if (s === "BAL") return 0;

  // find first R or G and the following number (e.g. "R2", "G10", or "R 1")
  const m = s.match(/([RG])\s*([-]?\d+)/i);
  if (!m) return 0;

  const dir = m[1].toUpperCase();
  const num = parseInt(m[2], 10) || 0;
  return dir === "R" ? num : -num;
}

// Convert numeric offset back to label object
function numberToDcLabel(n) {
  if (!n) return { text: "BAL", color: "black" };
  if (n > 0) return { text: "R" + n, color: "red" };
  return { text: "G" + Math.abs(n), color: "green" };
}

// Nudge the DC label by one step in the direction of `step`
// (step > 0 increments numeric by +1; step < 0 decrements numeric by 1)
function getNextDcLabelByNudge(current, step) {
  const n = parseDcToNumber(current);
  const delta = (step > 0) ? 1 : -1;
  const next = n + delta;

  return numberToDcLabel(next);
}
</script>



<script>
// --- COMFY CLEARER RX ANALYSIS & PLAN STARTING
// --- Parse DC input (same as before) ---
function parseDC(dc) {
  if (dc === null || dc === undefined) return null;
  let s = String(dc).trim();
  if (!s) return null;

  s = s.replace(/‚àí/g, '-').toUpperCase(); // normalize minus sign

  if (s === 'BAL') return { kind: 'BAL', diopter: 0, stepVal: 0, raw: s };

  const codeMatch = s.match(/^([RG])\s*(\d+)$/i);
  if (codeMatch) {
    const type = codeMatch[1].toUpperCase();
    const step = parseInt(codeMatch[2], 10);
    const diopter = (type === 'R') ? -(step * 0.25) : (step * 0.25);
    const stepVal = (type === 'R') ? -step : step;
    return { kind: 'CODE', type, step, stepVal, diopter, raw: s };
  }

  const numStr = s.replace(/[^\d\.\-+]/g, '');
  const n = parseFloat(numStr);
  if (!Number.isNaN(n)) {
    const stepVal = n / 0.25;
    return { kind: 'NUMERIC', diopter: n, stepVal, raw: s };
  }

  return { kind: 'UNKNOWN', raw: s };
}

// --- Consumer-friendly descriptions (unchanged except colour labels) ---
function describeDC(dc, label = 'Current') {
  if (!dc) return '';
  const parsed = parseDC(dc);
  if (!parsed) return `${label} RX: ${dc}`;

  if (parsed.kind === 'BAL') {
    return `${label} RX is true balance between far and near vision.`;
  }

  if (parsed.kind === 'CODE') {
    const absD = Math.abs(parsed.diopter).toFixed(2);
    const colourLabel = `<span style="color:${parsed.type === 'R' ? 'red' : 'green'}; font-weight:normal;">${parsed.raw}</span>`;

    if (parsed.type === 'R') {
      return `${label} RX under by -${absD} (${colourLabel}); perfect for near and room distance, but not able to see very far.`;
    } else {
      if (parsed.step === 1) {
        return `${label} RX over by +${absD} (${colourLabel}); perfect for seeing as far as possible.`;
      }
      return `${label} RX over by +${absD} (${colourLabel}); over the healthy limit of +0.25 (<span style="color: green; font-weight:normal;">G1</span>). Prolonged use may cause blurry vision, tiredness and headaches.`;
    }
  }

  if (parsed.kind === 'NUMERIC') {
    const d = parsed.diopter.toFixed(2);
    if (Math.abs(parsed.diopter) < 0.0001) return `${label} RX balances far & near vision.`;
    if (parsed.diopter < 0) return `${label} RX under by ${d}.`; 
    if (Math.abs(parsed.diopter - 0.25) < 0.0001) {
      return `${label} RX over by ${d}; perfect for seeing as far as possible.`;
    }
    return `${label} RX over by ${d}; Limit for healthy vision is +0.25 (<span style="color: green; font-weight:normal;">G1</span>); Unnecessary over will cause blurry vision & headaches.`;
  }

  return `${label} RX: ${dc}`;
}

// --- NEW: Deeper analysis of DC status based on your 4 rules ---
// Accepts optional parsed objects as 3rd/4th args for efficiency (getDCShiftText already passes them)
function getDeeperAnalysis(fromDC, toDC, prevParsed, toParsed) {
  const f = (prevParsed && typeof prevParsed === 'object') ? prevParsed : parseDC(fromDC);
  const t = (toParsed && typeof toParsed === 'object') ? toParsed : parseDC(toDC);
  if (!f || !t || f.kind === 'UNKNOWN' || t.kind === 'UNKNOWN') return '';

  // Numeric diopters and stepVal (safe fallbacks)
  const fromDiopter = (typeof f.diopter === 'number') ? f.diopter : ((typeof f.stepVal === 'number') ? f.stepVal * 0.25 : 0);
  const toDiopter = (typeof t.diopter === 'number') ? t.diopter : ((typeof t.stepVal === 'number') ? t.stepVal * 0.25 : 0);
  const fromStepVal = (typeof f.stepVal === 'number') ? f.stepVal : (typeof f.diopter === 'number' ? f.diopter / 0.25 : 0);
  const toStepVal = (typeof t.stepVal === 'number') ? t.stepVal : (typeof t.diopter === 'number' ? t.diopter / 0.25 : 0);

  // Collect messages (we may return multiple lines, separated by <br>)
  const parts = [];

  // ---- Exclusive "no change" cases (return immediately) ----
  if (f.kind === 'BAL' && t.kind === 'BAL') {
    return '- No changes in the far and near vision.';
  }
  if (f.type === 'R' && t.type === 'R' && typeof f.step === 'number' && typeof t.step === 'number' && f.step === t.step) {
    return `- No changes in the far and near vision.`;
  }

  // --- Rule 1: G ‚Üí G (handle when both are G codes) ---
  if (f.type === 'G' && t.type === 'G') {
    if (typeof f.step === 'number' && typeof t.step === 'number' && (f.step - t.step === 1)) {
      parts.push('- No loss of distance clarity. Near vision comfort improves slightly.');
    } else if (typeof f.step === 'number' && typeof t.step === 'number' && t.step < f.step) {
      parts.push('- No loss of distance clarity. Significant improvement in near vision comfort.');
    } else if (typeof f.step === 'number' && typeof t.step === 'number' && t.step > f.step) {
      parts.push('- No loss of distance clarity but worsening of near vision comfort. Not recommended to prescribe.');
    }
    // continue ‚Äî other rules below may also apply in borderline cases
  }



// --- Rule 4: Distance improvement (cases that increase distance clarity) ---
const distanceImprovementCond =
  (f.kind === 'BAL' && t.type === 'G') ||
  (f.type === 'R' && t.kind === 'BAL') ||
  (f.type === 'R' && t.type === 'R' && typeof t.step === 'number' && typeof f.step === 'number' && t.step < f.step) ||
  (f.type === 'R' && t.type === 'G' && t.step === 1); // NEW: R ‚Üí G1 improves distance


if (distanceImprovementCond) {
  // Special case: G1 or higher (G2, G3, ...)
  if (t.type === 'G' && typeof t.step === 'number' && t.step >= 1) {
    if (t.step === 1) {
      parts.push(`- Distance clarity is  maximum; see as far as possible.`);
    } else {
      parts.push(`- Distance clarity does not improve further beyond G1 (already maximized).`);
    }
  } else {
    let gainDist = 20; // default
    if (t.kind === 'BAL') gainDist = 20;
    if (t.type === 'R' && typeof t.step === 'number') {
      gainDist = 20 / Math.pow(2, t.step - 1); // R1=10, R2=5, ...
    }
    parts.push(`- However, distance clarity improves. Objects up to ${gainDist} feet will appear clearer.`);
  }
}


  // --- Rule 2: Any ‚Üí BAL or R (distance reduction) ---
  // Only add reduction when we did NOT already decide distance improves (to avoid contradiction)
  const distanceReductionCond = (t.kind === 'BAL' || t.type === 'R') && !distanceImprovementCond;
  if (distanceReductionCond) {
    let lossDist = 20; // default for BAL
    if (t.type === 'R' && typeof t.step === 'number') {
      lossDist = 20 / Math.pow(2, t.step - 1); // R1=10, R2=5...
    }
    parts.push(`- However, distance clarity will be reduced. Vision becomes blurry beyond ${lossDist} feet.`);
  }

  // Join lines with <br> for HTML display; or return empty if nothing matched
  return parts.length ? parts.join('<br>') : '';
}

// --- Deep analysis wrapper (uses both old shift + new deeper analysis) ---
function getDCShiftText(fromDC, toDC) {
  if (!fromDC || !toDC) return '';

  const f = parseDC(fromDC);
  const t = parseDC(toDC);
  if (!f || !t || f.kind === 'UNKNOWN' || t.kind === 'UNKNOWN') return '';

  const fromStepVal = (typeof f.stepVal === 'number') ? f.stepVal : (f.diopter / 0.25);
  const toStepVal = (typeof t.stepVal === 'number') ? t.stepVal : (t.diopter / 0.25);

  const stepDiff = toStepVal - fromStepVal;
  const diopterShift = stepDiff * 0.25;

  const line1 = describeDC(fromDC, '- Current');

  let line2 = '';
  if (Math.abs(diopterShift) < 0.0001) {
    line2 = '- No changes of far and near vision.';
 } else {
  const mag = Math.abs(diopterShift).toFixed(2);
  const direction = (stepDiff < 0) ? '+' : '-';

  // Base message
  line2 = `- A change of ${direction}${mag}. `;

  // Adaptation analysis
  if (Math.abs(diopterShift) <= 0.25 + 0.001) {
    line2 += 'Easy adaptation and takes less than 1 week. ';
  } else if (Math.abs(diopterShift) <= 0.50 + 0.001) {
    line2 += 'Takes below 2 weeks to adapt; max amount to adapt comfortably. ';
  } else {
    line2 += 'Takes above 2 weeks to adapt; above common tolerant shift 0.50 ';
  }

  // Extra near-vision comfort analysis
  if (diopterShift > 0) {
    line2 += '<br>- More minus reduces near vision comfort and range.';
  } else if (diopterShift < 0) {
    line2 += '<br>- More plus improves near vision comfort and range.';
  }
}

let lineDash = '<b>---------------------</b>';
let lineAnalysis = '<b>Analysis:</b>';
let linePlan = '<b>Plan</b>';

  let line3 = '';
  if (t.kind === 'BAL') {
    line3 = '- New RX is true balance between distance and near vision.';
  } else {
    const newD = (typeof t.diopter === 'number') ? t.diopter : (t.stepVal * 0.25);
    const mag = Math.abs(newD).toFixed(2);

    let codeLabel = '';
    if (t.kind === 'CODE') {
      const color = (t.type === 'R') ? 'red' : 'green';
      codeLabel = `(<span style="color:${color}; font-weight:normal;">${t.type}${t.step}</span>)`;
    }

    if (newD < 0) {
      line3 = `- New RX prioritizes near vision; under by -${mag} ${codeLabel}.`;
    } else {
      line3 = `- New RX prioritizes distance vision; over by +${mag} ${codeLabel}.`;
    }
  }

  // pass parsed f/t in to avoid re-parsing internally
  const line4 = getDeeperAnalysis(fromDC, toDC, f, t);

  return [lineAnalysis, line1, line3, lineDash, linePlan, line2, line4].filter(Boolean).join('<br>');
}

// --- Update analysis in real-time ---
function updateDCAnalysis() {
  const binoErrorDC = document.getElementById('dc-ou')?.textContent.trim();
  const prescribedDC = document.getElementById('res-dc-ou-re')?.textContent.trim();
  if (!binoErrorDC || !prescribedDC) return;

  const analysisEl = document.getElementById('analysis-ou');
  if (!analysisEl) return;

  const text = getDCShiftText(binoErrorDC, prescribedDC);
  analysisEl.innerHTML = text;
  analysisEl.style.textAlign = 'left';
}

setInterval(updateDCAnalysis, 300);
// --- COMFY CLEARER RX ANALYSIS & PLAN ENDING
</script>

<script>
function updateSEDiffLive() {
  const seOD = parseFloat(document.getElementById("res-se-od-2")?.textContent) || 0;
  const seOS = parseFloat(document.getElementById("res-se-os-2")?.textContent) || 0;
  const diff = seOD - seOS;

  // Update all relevant SE diff displays
  ["res-se-diff-2", "res-se-diff-od-2", "res-se-diff-os-2"].forEach(id => {
    const el = document.getElementById(id);
    if(el) el.textContent = formatSEDiffForDisplay(diff);
  });
}

// Patch your existing monocular SPH adjustment function
function applySphOffsetMonoLive(eye, step) {
  const ids = (eye === "od")
    ? { sph: "res-sph-od-2", dc: "res-dc-od-2" }
    : { sph: "res-sph-os-2", dc: "res-dc-os-2" };

  const sphCell = document.getElementById(ids.sph);
  const dcCell  = document.getElementById(ids.dc);
  if (!sphCell || !dcCell) return;

  const currentVal = parseFloat(sphCell.textContent) || 0;
  const newVal = currentVal + step;
  sphCell.textContent = formatSigned(newVal);

  const currentLabel = (dcCell.textContent || "").trim();
  const newLabel = getNextDcLabelByNudge(currentLabel, step);
  dcCell.textContent = newLabel.text;
  dcCell.style.color = newLabel.color;
  dcCell.style.fontWeight = "none";

  // --- NEW: update SE DIFF live ---
  updateSEDiffLive();
}

// Optional: if you also allow typing directly in the SPH input, attach a listener
document.querySelectorAll("#res-sph-od-2, #res-sph-os-2").forEach(el => {
  el.addEventListener("input", updateSEDiffLive);
});
</script>

<script>
function updateBypass(eye, step) {
    const bypassCell = document.getElementById('bypass');
    if (!bypassCell) return;

    // Get current value
    let current = parseFloat(bypassCell.textContent) || 0;

    // Determine the change based on eye and step
    let delta = 0;
    if (eye === 'od') delta = step;   // Right eye: normal
    if (eye === 'os') delta = -step;  // Left eye: reverse

    const newVal = current + delta;
    bypassCell.textContent = (newVal >= 0 ? "+" : "") + newVal.toFixed(2);
}

// Attach observer to the existing monocular buttons
document.querySelectorAll('.sph-btn-mono').forEach(btn => {
    btn.addEventListener('click', () => {
        const eye = btn.dataset.eye;        
        const step = parseFloat(btn.dataset.step); 
        updateBypass(eye, step);
    });
});
</script>




<!-- Spacer at the bottom for scrolling -->
<div style="height:300px;"></div>



</body>
</html>








