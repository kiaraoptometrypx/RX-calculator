<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=160, initial-scale=0.95, maximum-scale=1.0, user-scalable=yes">
<title>Kiara Optometry Algorithm Refraction</title>
<style>
.lens-card {
  border: 1px solid #ddd;
  border-radius: 12px;
  padding: 12px 15px;
  margin-bottom: 12px;
  background: #fff;
  box-shadow: 0 1px 4px rgba(0,0,0,0.06);
  transition: all 0.0s ease;
}

.hidden-stock {
  display: none;
}

.lens-card:hover {
  box-shadow: 0 2px 6px rgba(0,0,0,0.12);
}
.lens-header {
  margin-bottom: 6px;
}
.lens-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 6px;
}
.tag {
  padding: 2px 8px;
  border-radius: 8px;
}
.tag.index { background: #d9f0ff; }
.tag.type { background: #f6f0d9; }
.tag.func { background: #f6f0d9; }
.tag.brand{ background: #d9f0ff;}
.tag.tint {background: #CFEDBB;}
.tag.coating {background: #CFEDBB;}


.lens-price {
  margin: 4px 0;
  font-weight: 700;
  letter-spacing: 0.5em;
}
.lens-note {
  margin-bottom: 6px;
}
.select-btn {
  border: none;
  background: #0b3d2e;
  color: white;
  padding: 5px 12px;
  border-radius: 6px;
  cursor: pointer;
}
.lens-tint { background: BDFFB0; }xxxx

.select-btn:hover {
  background: #145b43;
}


  :root{
    --green:#0b3d2e;
    --pale:#ffffe0;
    --off:#f8f8f5;
    --line:#d7d7cf;
    --warn:#B42318;
    --barOD:#7EABD6;
    --barOS:#7EABD6;
    --frame:#915140;
  }

  
 h1{font-size:10px;text-align:center;margin:12px 0 10px;}
  h3{font-size:10px;margin:0 0 8px;}
  
  .row{align-items:center}
  .field{gap:0px}
  .field.w90{width:90px}
  .tiny{font-size:10px;opacity:1}
  .muted{opacity:1}


  button:focus{outline:2px solid #fff4; outline-offset:2px;}
  button:hover{filter:brightness(1);}
  button:active{transform:translateY(1px);}


  .pane h4{margin:0 0 8px;font-size:10px}

  /* Bars */
  .bar-row{display:flex;align-items:flex-start;gap:20px;margin:30px 0;flex-wrap:wrap}
  .bar-label{width:20px;text-align:right;font-weight:bold; margin-bottom:30px;} <!-- change height between bars --!>
  .bar-pair{display:flex;gap:0px;align-items:flex-start;flex-wrap:wrap} /* visual gap between OD & OS */

  .bar-block{display:flex;
flex-direction:column;gap:0px;min-width:70px}
.bar {  position: absolute;
  top: 0;
  left: 0;
  height: 10px;
  background: lightblue;
  z-index: 1; /* lens below */
}
  .bar-frame{
 position: absolute;
  top: 0;
  left: 0;
  height: 10px;
  background: #a8733b;
  z-index: 2; /* frame on top */
}
.bar-stock {
  position: absolute;
  top: 0;
  left: 0;
  height: 10px;
  background: darkblue;    
  z-index: 0;           /* behind main lens bar */
}

.bar-track {
  position: relative;
  height: 10px;
  overflow: visible;           /* allow bar to render fully */

}

.bar-track.reverse {
  transform: scaleX(-1);
  transform-origin: left center;  /* stay anchored on left */
}

.bar, .bar-stock, .bar-frame {
margin-top: 5px;
  position: absolute;
  top:0 ;
  left: 0;
  height: 30px;

}
.eye-arrow {
  font-size: 23px;          /* smaller eye glyph */
  min-width: 20px;
 margin-top:11px;
  text-align: right;
  margin-right: 4px;
  user-select: none;
  position: relative;
  top: 2px;                 /* 👈 nudges it down visually */
  line-height: 10px;        /* matches bar height */
  display: flex;
  align-items: center;      /* vertical centering within flex row */
}
.your-eye {
  font-size: 10px;         
  min-width: 20px;
 margin-top:8px;
  text-align: right;
  margin-right: 2px;
  user-select: none;
  position: relative;
  line-height: 10px;        /* matches bar height */
  display: flex;
  align-items: center;      /* vertical centering within flex row */
}



  .bar-text{font-size:10px;}

  /* Filters inside panes */
  .filters{display:flex;flex-wrap:wrap;gap:8px;margin:6px 0 2px}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border:1px solid var(--line);border-radius:4px;background:#fff}

  @media(max-width:1200px){
    .row{flex-direction:column;align-items:flex-start}
    .bar-block{min-width:100px}
  }

.bar-block {
  position: relative;
  height: 10px; /* same as bar height */
}



* {
  font-size: 10px;
  letter-spacing: 0.15em;
  color: #241D0C;
}

html, body {
  font-size: 20px; /* your base */
	  -webkit-text-size-adjust: none; /* prevents Safari scaling */

}

/* Remove number input spinners for Chrome, Safari, Edge */
input[type=number]::-webkit-inner-spin-button, 
input[type=number]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

/* Remove for Firefox */
input[type=number] {
  -moz-appearance: textfield;
}

body { 
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
  font-size: 20px;
  margin: 0;
  background: #f8f8f5;
  color: black;
}

table td:first-child,
table th:first-child {

}

table td:nth-child(2),
table th:nth-child(2){
  max-width: 80px;
  width: 50px;
}

table td:nth-child(3),
table th:nth-child(3) {
  white-space: nowrap;
}

table td:nth-child(4),
table th:nth-child(4) {
  white-space: nowrap;
}

table td:nth-child(5),
table th:nth-child(5) {
  white-space: nowrap;
}

table td:nth-child(6),
table th:nth-child(6) {
  white-space: nowrap;
}

table td:nth-child(7),
table th:nth-child(7) {
  white-space: nowrap;
}

h2 { 
  text-align:center; 
  margin-bottom:10px; 
}

table { 
  border-collapse: collapse;
  table-layout: fixed;
  width: 95%; /* keep your width */ 
  margin:0 auto; 
  font-size: 20px; 

}

th, td { 
  border:1px solid #999; 
  padding:5px; 
  text-align:center; 
  vertical-align: middle;
  white-space: normal;   /* allow line wrapping */
  word-wrap: break-word; /* legacy */
  overflow-wrap: break-word; /* modern */

}




th {   background:#d9d9d9; 
  color: black;}

input {   width:80px;
  height:30px; 
  padding:2px; 
  text-align:center; 
  box-sizing: border-box;}

.calibrator tr {background: #F5F5F5; border:none;}
.calibrator td,
.calibrator th {
  border: none !important;}

.wrap{width:97%;max-width:2000px;margin:0 auto;padding:0px;}
.now td { background: #F5F5F5; }
.adjustments td {height:25px;}
.now-comfort td { background: #F5F5F5 ;}
.white td { background: #d9d9d9; }
.fc-results td { background: #EFF5E6; }
.dc-bal td { background: #fff; }
.paleviolet td { background: #D0C5DB }
.paleblue td { background: #D8EFF8 }

.table-headernow {  background: #E8D1A0;}

.comfort {  background: #E5F0D1;}
.offwhite { background: #f8f8f5; }

.sph-btn, .addMinus025 {
  user-select: none;      /* prevent text highlight */
  -webkit-user-select: none; /* Safari */
  -moz-user-select: none;    /* Firefox */
}


/* 🔒 Overlay for blackout */
#overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: #EDEADF;
  color: black;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  z-index: 9999;
}

.choice-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.choice-group input[type="radio"] {
  display: none; /* hide the default bullet */
}

.choice-group label {
  display: block;           /* makes width effective */
  width: 80%;               /* fixed width */
  margin: 1px auto;         /* centers horizontally */
  padding: 1px 1px;         /* slightly bigger padding for readability */
  border: 1px solid #888;
  cursor: pointer;
  user-select: none;
  background: #f9f9f9;
  text-align: center;       /* center text inside */
  border-radius: 4px;

}

.choice-group input[type="radio"]:not(:checked) + label {
  text-decoration: line-through;
  color: grey;
}

.choice-group input[type="radio"]:checked + label {
  background: LIGHTGREY;   /* active color */
  background: #444;
  color: #fff;
  border-color: #222;
}

#apply-controls { text-align:left; margin-bottom:10px; margin-top:10px; margin-left:10px }
#addMinus025 { cursor:pointer; color:black; text-decoration:underline; user-select:none; }

.custom-link {
  color: #101F01;       /* text color */
  font-weight: bold;    /* normal | bold | lighter | 100-900 */
  font-style: normal;   /* normal | italic | oblique */
  text-decoration: none; /* none | underline | overline | line-through */
}

/* Font size classes */
.font-S * { font-size: 10px !important; }
.font-M * { font-size: 14px !important; }
.font-L * { font-size: 18px !important; }
.font-XL * { font-size: 22px !important; }


/* Buttons */
.font-btn {
  padding: 2px 20px 2px 20px;
  margin: 4px;
  background: #eee;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px !important; /* stays fixed */
  color: black;
  border: 1px solid #999;   /* 🔹 border thickness + colour */
}

.normal-btn {

  padding: 2px 20px 2px 20px;
  margin: 10px 0px 10px 0px;
  background: #eee;
  border-radius: 30px;
  cursor: pointer;
  font-size: 10px;
  color: black;
  border: 1px solid #999;   /* 🔹 border thickness + colour */
}

.normal-btn:focus {
  outline: none;
  box-shadow: none;
  background: #444;
  color: #fff;
  border-color: #222;

}

.small-normal-btn {
  padding: 5px 10px 5px 10px;
  margin: 0px 0px 0px 0px;
  background: #eee;
  border-radius: 30px;
  cursor: pointer;
  font-size: 10px;
  color: black;
  border: 1px solid #999;   /* 🔹 border thickness + colour */
}

.font-btn.active {
  background: #444;
  color: #fff;
  border-color: #222;
}

table input {
  width: 80%;
  box-sizing: border-box;
  padding: 3px 3px;
  font-size: 10px;
  border-radius: 4px;
  border: 1px solid #999;
  text-align: center;
}

.fixed-label {
  font-size: 12px !important;   /* stays fixed regardless */
 
}
/* Default select look */
.dc-select {
  width: 80%;
  box-sizing: border-box;
  padding: 3px 3px;
  font-size: 10px;
  border-radius: 4px;
  border: 1px solid #999;
  text-align: center;
}

 
.pane{
  background:#fff;
  border:1px solid var(--line);
  border-radius:10px;
  padding:5px;
}

  .pane h4{margin:0 0 8px;font-size:10px}

  .section{background:var(--pale);border:1px solid var(--line);border-radius:10px;padding:12px;margin:10px 0;}



/* Colorize each option individually */
.dc-select option[value^="R"] { color: red; }
.dc-select option[value^="G"] { color: green; }
.dc-select option[value="BAL"] { color: black; }


/* --- Unified Checkbox Style (All Filter Types: SV + MF) --- */
.fl-appear[type="checkbox"],
.fl-index[type="checkbox"],
.fl-func[type="checkbox"],
.fl-clarity[type="checkbox"],
.fl-brand[type="checkbox"],
.fl-durability[type="checkbox"],
.fl-sv-pers[type="checkbox"],
.fl-viewing[type="checkbox"],
.fl-opti[type="checkbox"],
.fl-mf-view[type="checkbox"],
.fl-mf-swim[type="checkbox"],
.fl-mf-zone[type="checkbox"],
.fl-mf-pers[type="checkbox"],

.fl-mf-tier[type="checkbox"] {
  appearance: none;
  -webkit-appearance: none;
  width: 10px;
  height: 10px;
  border: 1px solid black;
  border-radius: 40%;          /* rounded look */
  cursor: pointer;
  position: relative;
  background: #fff;
  transition: all 0.0s ease-in-out;
}

/* Checked state */
.fl-appear[type="checkbox"]:checked,
.fl-index[type="checkbox"]:checked,
.fl-func[type="checkbox"]:checked,
.fl-clarity[type="checkbox"]:checked,
.fl-brand[type="checkbox"]:checked,
.fl-sv-pers[type="checkbox"]:checked,
.fl-durability[type="checkbox"]:checked,
.fl-viewing[type="checkbox"]:checked,
.fl-opti[type="checkbox"]:checked,
.fl-mf-view[type="checkbox"]:checked,
.fl-mf-swim[type="checkbox"]:checked,
.fl-mf-zone[type="checkbox"]:checked,
.fl-mf-pers[type="checkbox"]:checked,
.fl-mf-tier[type="checkbox"]:checked {
  background: #8BAD79;         /* filled green */
  border-color: #5f7f56;
}



label {
  display: flex;
  align-items: center;
  gap: 4px;
  background: var(--off, #f8f8f5);
  padding: 5px 5px;
  border-radius: 4px;
  border: 1px solid #d7d7cf;
  user-select: none;
}

label:hover {
  background: #ffffe0;     /* pale yellow hover */
}



</style>
</head>
<body>

<!-- 🔒 Locked screen -->
<div id="overlay">🔒 Entering password...</div>

<script>
  function checkPassword() {
    let password = "";
    const correctPassword = ""; // change this

    while (password !== correctPassword) {
      password = prompt("Please enter password to use:");
      if (password === null) {
        document.getElementById("overlay").innerHTML = "Sorry, Access Denied.";
        return false;
      }
      if (password !== correctPassword) {
        alert("Wrong password. Try again.");
      }
    }
    return true;
  }

  window.onload = function () {
    if (checkPassword()) {
      document.getElementById("overlay").style.display = "none";
      // there's no #content in your original but leaving safe
      const c = document.getElementById("content");
      if(c) c.style.display = "block";
    }
  };
</script>

<div style="height:20px;"></div>
<div class="wrap">

  <!-- Right side: Font controls -->
  <div style="text-align:right;">
    <span class="fixed-label" style="cursor:pointer;user-select:none; margin-right:10px;">
      Font:
    </span>
    <button class="font-btn" onclick="setFontSize('S', this)">S</button>
    <button class="font-btn" onclick="setFontSize('M', this)">M</button>
    <button class="font-btn" onclick="setFontSize('L', this)">L</button>
    <button class="font-btn" onclick="setFontSize('XL', this)">XL</button>
  </div>

<script>
function setFontSize(size, btn) {
  document.body.classList.remove(
    'font-S','font-M','font-L','font-XL'
  );
  document.body.classList.add('font-' + size);

  // remove active from all buttons
  document.querySelectorAll('.font-btn').forEach(b => b.classList.remove('active'));
  // set active to clicked one
  btn.classList.add('active');
}
</script>
</div>



<div class="wrap">
<div class="section" style="text-align:center;">
  <span class="fixed-label"
        style="user-select:none; font-weight:bold; display:inline-block;">
    Welcome to Kiara Optometry's Algorithm Refraction
  </span>

</div>



<div class="section" >
<div style="display:flex; justify-content:space-between; align-items:center; width:95%; margin:0px auto;">
  
  <span id="toggle-settings-block" style="cursor:pointer; user-select:none;">
   ▼ Eye Exam & Algorithm Guide
  </span>

</div>




<div id="settings-block" style="display:none; margin-top:10px;">

<table>
<tr>
  <td colspan="2" style="padding:0px; border:1px solid lightgrey;">
</td>
</tr>
<tr class="offwhite">
	<td colspan="2" style="color: grey; border:none; padding:0px;">


</td></tr>



<tr>
<td colspan="2" style="color:#182E00; border:none; text-align:center; padding:8px;"></td>
</tr>
<td colspan="2" style="color:#182E00; border:none; text-align:left; padding:0px;">
 <span class="toggle-btn" data-target="toggle-section-fcdc-errormargin"
          style="cursor:pointer; color: grey; user-select:none;">
      <i><b>▼▲ ● 1. Guide for FC DC Error Test</b> </i>

</span>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;


       
 <span class="toggle-btn" data-target="toggle-section-guide-comfort"
          style="cursor:pointer; color: grey; user-select:none;">
 <i><b>▼▲ ● 2. How to use the Algorithm Refraction</b> </i>

</span>
</td>
</tr>







<tbody class="toggle-section-fcdc-errormargin" style="display:none;">

<tr>
<td colspan="2" style="color:#182E00; border:none; text-align:center; padding:5px;">
</tr>


<tr class="offwhite">

<td colspan="2" style="padding:10px; border:1px solid lightgrey; text-align:left; padding:20px;">
<b>● 1. Guide for FC DC Error test</b><br><br>

<b>Glossary:</b><br>
  -<b>Fan Chart (FC):</b> Detects astigmatism and line orientation errors. Must be balanced first.<br>
  -<b>Duochrome (DC):</b> Red/green balance test to refine spherical power.<br>
  -<b>Over-Refraction (OR):</b> Trial lenses added on top of the patient’s current correction to test residual error.<br><br>

<b>Purpose:</b><br>
FC–DC Error Test maps how far the visual system is from a true <b>balanced prescription</b>. Using a series of trial lenses (usually 5–10 steps) we locate areas of over- and under-correction, then calculate the balanced RX. The test can be done binocularly or monocularly and works with glasses or contacts.<br><br>

<b>Important concept:</b><br>
Fan Chart (FC) and Duochrome (DC) are <b>inter-related</b>. The FC reveals astigmatic/line errors; if FC is not balanced, DC results will be unreliable. Correct the FC grossly first — this usually requires a slight under-correction; letters in red should be clearer, or make vision blurry by using Over-Refraction (OR) +1.00 lenses. When FC is somewhat corrected, the DC test will function more efficiently <b>red</b> during the balancing step.<br><br> 

<b>Materials:</b><br>
1. Fan Chart (FC) and Duochrome (DC) charts.<br>
2. Sphere Trial lenses (+1.00, +0.50, 0, -0.50, -1.00).<br>
3. Cyl Trial lenses (+0.50, +1.00, +1.50).<br>
4. Calculator to enter FC/DC balance values.<br><br>

<b>How to do:</b><br>

<b>1. Explain & position:</b> Ask the patient to view the FC/DC chart and tell them you’ll try several lenses. Encourage quick, instinctive answers.<br>

<b>2. Balance the Fan Chart (FC) first:</b> Always check the FC before using DC. If parts of the fan look darker or blurred, place plus cylinder (in steps of +0.50 CYL) on the darker region to bring the fan into balance. Do not proceed to DC until the FC looks fairly evenly blurred.<br><br>

<img src="https://raw.githubusercontent.com/kiaraoptometrypx/RX-calculator/main/FCDCchart1.png"
         alt="Fc Dc Chart 1" style="max-width:90%;">
<br><br>

<b>3. Perform the Duochrome (DC) sequence:</b> Present lenses steps around the current RX (example: +1.00, +0.50, 0, -0.50, -1.00). For each step ask: “Which side is clearer — red or green?” Record quick responses.<br>

<b>4. Constantly check FC at every DC sequence:</b> Everytime the DC is performed, check the FC to ensure that no one group of parallel lines are darker than the other. If there are, balance it with OR cylinder lenses. <br><br>

<img src="https://raw.githubusercontent.com/kiaraoptometrypx/RX-calculator/main/cylerror.png"
         alt="Fc Dc Chart 1" style="max-width:90%;"><br><br>

<b>5. Interpret results:</b> Identify the lens position where balance or smallest difference occurs. That lens value is the <b>sphere to balance DC</b> — enter it into the calculator along with the FC adjustments.<br>
   <i>Example:</i> +1.00 red clearer, +0.50 both same, 0 green clearer, -0.50 green clearer, -1.00 both blur → here +0.50 is the SPH to balance DC.<br>

<b>6. Map & record:</b> Log the FC results (cyl and axis to balance) and DC (sphere to balance). Use the calculator to compute the Balanced RX.<br>

<b>7. Always use Horizon Enhance:</b> This applies cyl and axis power along the horizontal meridian to enhance clarity.<br>

<b>8. Lastly, adjust S value:</b> Adjust the sphere values to match the current DC status of the glasses if you want to ensure seamless comfort. Otherwise, adjust it according to the visual needs such as needing to see further or nearer than the current prescription.<br><br>

<b>Tips & troubleshooting:</b><br>
- Always grossly balance FC before DC — FC errors will invalidate DC readings.<br>
- Aim for a slight under-correction when fixing FC (less minus / more plus). When done correctly, DC should lean clearer to red during balancing — this indicates the FC adjustment moved the eye into the correct region for DC testing.<br>
- Ask for quick answers. Long, uncertain replies reduce test reliability. Repeat if responses are inconsistent.<br>
- Keep step sizes consistent (0.50 D) and record which steps were used.<br><br>

<b>Note:</b> This test measures the additional power needed to reach balance — discuss the visual needs with the person before finalising any prescription.<br><br>

<br><i><b>- End of FC DC Error Test -</b></i><br><br>--- --- --- --- ---<br><br>
&nbsp;&nbsp;
 <span class="toggle-btn" data-target="toggle-section-fcdc-errormargin"
          style="cursor:pointer; color: #101F01; user-select:none;">
      <i>▼▲ toggle</i>
</span>

</td>
</tr>

</tbody>
<tr>
<td colspan="2" style="color:#182E00; border:none; text-align:center; padding:5px;">
</tr>


<tbody class="toggle-section-guide-comfort" style="display:none;">
<tr class="offwhite">

<td colspan="2" style="padding:20px; border:1px solid lightgrey; text-align:left;">
<b>● 2. How to use the Algorithm Refraction</B><br><br>
First, <b>chooose the type of test</b> based on their needs:<br>
    <b>- Comfy Clearer Test</b><br>
    Keeps both eyes working together comfortably while still making things clearer. 
    Best for people who prefer natural, easy vision without the prescription feeling too strong.
  <br>
    <b>- Sharpest Ever Test</b><br>
    Pushes vision to the crispest and sharpest level possible. 
    Best for people who want maximum clarity, even if it may take a little more time to adjust.
<br>
<br>--- --- --- --- ---<br><br>

<b>- Comfy Clearer Test</b><br>
<b>Purpose:</b>Maintains comfortable binocular balance while still giving a noticeable boost in clarity. It is especially suitable for people who dislike prescriptions that feel too “strong” or “artificial” but still want vision that is clearer than their current glasses.<br><br>
<b>How to do</b><br>

1. Begin with the patient <b>wearing their current glasses or prescription</b>.<br>
2. Keep <b>both eyes open</b> during the test (to maintain natural binocular vision).<br>
3. <b>Change lenses equally</b> for both eyes at the same time.<br>
4. This keeps the <b>prismatic effect balanced</b>, even if the prescription changes.<br>
5. Perform the <B>FC DC Error test</b>.<br>
6. Use the <b>Fan Chart (FC)</b> to find the <b> cyl and axis to bal </b> values, then enter those into the calculator.<br>
7. The calculator will give you the <b>Balance RX</b> (the true and full prescription).<br>
8. Apply the ○ <b>Horizon Enhance</b> function.<br>
9. If the wearer has special needs (e.g. wants sharper distance or near vision), make slight <b>sphere adjustments</b>.<br>
10. If no special needs, keep the same <b>DC status</b> as before.<br><br>

<b>Note:</b> When checking each eye separately, <b>one eye may still show some error.</b> 
This is <b>normal</b> because the <b>test corrects binocularly</b>, not monocularly.  
The small error in one eye <b>does not affect daily vision</b>.<br><br><i><b>- End of Comfy Clearer -</b></i><br><br>--- --- --- --- ---<br><br>
        

<b>- Sharpest Ever Test</b><br>
<b>Purpose:</b>Prioritizes maximum possible clarity by pushing the prescription closer to the eye’s sharpest potential. It is suitable for people who want the crispest vision possible, even if it comes with a slight trade-off in comfort or adaptation time.<br><br>
<b>How to do</b><br>
1. Begin with the patient’s <b>current prescription</b>.<br>
2. For the sharpest possible vision,<b>perform FC DC Error test on each eye separately</b> (monocular testing).<br>
3. This may cause the two eyes to become <b>imbalanced</b>, since one eye’s prescription can change more than the other.<br>
4. Use <b>SE Diff</b> (Spherical Equivalent Difference) to track the difference in prescription strength between the two eyes.<br>
5. A new SE Diff introduces a <b>prismatic effect</b> when looking away from the lens center.<br>
6. An SE Diff change of <b>0.25</b> usually requires about a week of adaptation.<br>
7. Most people can tolerate up to <b>0.50 SE Diff change</b> without major issues.<br>
8. Beyond this, adaptation becomes difficult and may lead to <b>adaptation failure</b>.<br>
9. Tolerance is linked to <b>accommodation</b> (the eye’s focusing ability).<br>
10. <b>Younger patients</b> generally adapt better to larger SE Diff changes.<br><br><i><b>- End of Sharpest Ever -</b></i><br><br>--- --- --- --- ---<br><br>





<span class="toggle-btn" data-target="toggle-section-guide-comfort"
          style="cursor:pointer; color: #101F01; user-select:none;">

<i>▼▲ toggle</i>

     
</td>
</tr>
</tbody>
</table>



<!-- Toggle function -->
<script>
function toggleSection(id) {
  const section = document.getElementById(id);
  section.style.display = (section.style.display === "none") ? "table-row" : "none";
}
</script>


<script>
function toggleSection(id) {
  const section = document.getElementById(id);
  section.style.display = (section.style.display === "none") ? "block" : "none";
}
</script>


</div>


<br>

<div class="pane" style="padding:10px;">

<div style="display:flex; justify-content:center;">
  <b><span
    id="toggle-customer-details"
    style="cursor:pointer; user-select:none; text-align:center;">
    ▼ Customer Details & Eye exam
  </span></b>
</div>



<div id="customer-details" style="display:none;">
<div style="height:10px;"></div>

<div class="pane">







<table>
<tr class="calibrator">
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
</tr>
<tr class="white">
  <td colspan="1"><b>Suffix</b></td>

  <td colspan="3"><b>Name</b></td>
  <td colspan="2"><b>Whatsapp</b></td>
  <td><b>Age</b></td>
</tr>

<tr>
  <!-- Suffix input -->
  <td colspan="1">
    <input type="text" id="Suffix" placeholder="Mr, Mrs">
  </td>


  <!-- Name input -->
  <td colspan="3">
    <input type="text" id="nameInput" placeholder="Aaron B. Carlson">
  </td>
<!-- Contact number input -->
  <td colspan="2">
    <input type="text" id="contactInput" placeholder="Contact Number">
  </td>

    <!-- Age -->
  <td colspan="1"><input type="number" id="ageInput" min="1" max="120" oninput="calcAA()" placeholder="Years"></td>

</tr>


<tr>
<td colspan="5" style="padding:5px; border:none;"></td>
</tr>
</table>



<table>
<tr class="white">
    <td><b>Current RX</b></td>
    <td><b>R/L</b></td>
    <td><b>Sph</b></td>
    <td><b>Cyl</b></td>
    <td><b>Axis</b></td>
    <td><b>SE Diff</b></td>
    <td><b>Add</b></td>
</tr>


  <!-- Now RX -->
  <tr>
<td style="border-bottom:none;">
  <div class="choice-group">
    <input type="radio" id="current-wear-glasses" name="current-wearType" value="glasses">
    <label for="current-wear-glasses">Glasses</label>
</div>
</td>
    <td>R</td>
    <td><input id="s1_od" placeholder="+0.00"></td>
    <td><input id="c1_od" placeholder="+0.00"></td>
    <td><input id="a1_od" placeholder="0"></td>
    <td id="now-se-diff-od">—</td>
<td rowspan="2">
<span class="toggle-btn" data-target="toggle-section-near-rx"
          style="cursor:pointer; color: #101F01; user-select:none; text-align:middle;">
    Near Vision<br>Details<br> ▼▲
    </span>
</div></td>
  </tr>

  <tr>
<td style="border-top:none;">
  <div class="choice-group">
    <input type="radio" id="current-wear-contacts" name="current-wearType" value="contacts">
    <label for="current-wear-contacts">Contacts</label>
  </div>
    <td>L</td>
    <td><input id="s1_os" placeholder="+0.00"></td>
    <td><input id="c1_os" placeholder="+0.00"></td>
    <td><input id="a1_os" placeholder="0"></td>
    <td>—</td>



<tr><td colspan="7" style="padding:5px; border:none;"></td></tr>

  <tbody class="toggle-section-near-rx" style="display:none;">

<tr class="white">
    <td><b>Current Add</b></td>
    <td colspan="3"><b>Phone Length (cm) & Add Needed</b></td>
    <td colspan="3"><b>Screen Length (cm) & Add Needed</b></td>
</tr>
<tr>

    <td><input id="add-ou" placeholder="+0.00"></td>

    <td colspan="3" style="text-align:left;">
    <label for="targetDistInput" style="display:none;">Book</label>
    <input type="number" id="targetDistInput" min="0" placeholder="33" style="max-width:35px; margin: 0px 0px 0px 10px">
    &nbsp;&nbsp;&nbsp;<span id="addOutput">–</span>
    </td>
    <td colspan="3" style="text-align:left;">
    <label for="targetDistInput2" style="display:none;">Screen:</label>
    <input type="number" id="targetDistInput2" min="0" placeholder="50" style="max-width:35px; margin: 0px 0px 0px 10px">
    &nbsp;&nbsp;&nbsp;<span id="addOutput2">–</span>
    </td>
</tr>

  <td colspan="1" id="toleranceOutput" style="display:none;">–</td>
  <td style="display:none;"><b>AA Dist</b></td>
  <td style="display:none;"></td>
  <td style="display:none;"><span id="distOutput">–</span></td>
  <td style="display:none;"colspan="1" id="healthyDistOutput">–</td>
  <td style="display:none;">Current Eye Strength: <span id="aaOutput">–</span>
</td>
</tr>
<tr><td colspan="7" style="padding:5px; border:none;"></td></tr>

</table>
</tbody>

</div>

<div style="height:10px;"></div>

    <div class="pane" style="padding:0 0 10px 0;">

<table>
<tr class="calibrator">
  <td style="border:none;"></td>
</tr>
<tr class="white">
<td colspan="1"><b>Eye Exam Types</b></td>
<td style="border-right:none">
<span id="toggle-manual" style="cursor:pointer; font-weight:bold; user-select:none;">
  ▼ Manual Exam
</span>
</td>
<td style="border-right:none; border-left:none;">
<span id="toggle-comfy" style="cursor:pointer; font-weight:bold; user-select:none;">
  ▼ Comfy Exam
</span>
</td>
<td style="border-left:none;">
<span id="toggle-sharpest" style="cursor:pointer; font-weight:bold; user-select:none; display:none;">
  ▼ Sharpest Exam
</span>
</td>
</tr>
</table>


<div id="exam-manual" style="display:none;">

<table>
<tr class="calibrator">
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
</tr>
<tr class="paleblue">
  <td colspan="2" style="padding:10px; color: #241D0C; text-align:left; border-right:none;">
<b>Manual Input Rx</b></td>
<td colspan="2" style="text-align:left; border-left:none;">
<span id="testToggle2" style="cursor:pointer; user-select:none; color: #101F01;">
  <b><i>● Status?</i></B>
</td>
<td colspan="3" style="padding:10px; text-align:left;">
    <span style="margin-left:15px;  margin-right:15px; text-decoration:none; cursor:pointer; color:#101F01; user-select:none;"
          onclick="event.stopPropagation(); let t=document.getElementById('deficit-rows-manual'); t.style.display=t.style.display==='none'?'table-row-group':'none';">
     ▼▲ Test
    </span>

<span class="toggle-btn" data-target="toggle-section-manual-rx"
          style="cursor:pointer; color: #101F01; user-select:none;">
      ▼▲ Results 
    </span>
</td>
</tr>


  <tbody id="deficit-rows-manual" style="display:none;">



<tr><td colspan="7">
<span style="margin-left:20px; cursor:pointer; user-select:none;" id="toggle-reference">
  ▼ FC DC Reference & Calculator
</span>
<div id="reference" style="display:none;">

<div id="axis-dc-spot-1"></div>
</div>
</td></tr>

  <tr class="white">
<td colspan="1"><b>Test</b></td>
<td><b>R/L</b></td>
<td><b>Sph</b></td>
<td colspan="1"><b>Cyl</b></td>
<td colspan="1"><b>Axis</b></td>
<td><b>SE Diff</b></td>
<td><b>DC</b></td>
  </tr>
<tr class="white">
    <td row>FC DC Error<br>Notes</td>
<td>R</td>

    <td><input id="dc-sph-ou-manual-notes" placeholder="+0.00"></td>
    <td><input id="c2_ou_manual_notes" placeholder="+0.00"></td>
    <td><input id="a2_ou_manual_notes" placeholder="0"></td>
    <td id="def-se-diff-ou-notes">—</td>
    <td id="now-dc-ou-notes">BAL</td> 
  </tr>

<tbody class="toggle-section-manual-rx" style="display:none;">

<tr class="paleblue">
  <td><b>Final Rx</b></td>
  <td><b>R/L</b></td>
  <td><b>Sph</b></td>
  <td><b>Cyl</b></td>
  <td><b>Axis</b></td>
  <td><b>SE Diff</b></td>
  <td><b>DC</b></td>
</tr>

<!-- Right Eye -->
<tr class="paleblue">
  <td style="border-bottom:none;">
    <div class="choice-group">
      <input type="radio" id="manual-ou-wear-glasses" name="manual-ou-wear" value="glasses">
      <label for="manual-ou-wear-glasses">Glasses</label>
    </div>
  </td>
  <td>R</td>
  <!-- use text so + is allowed; keep numeric keypad -->
  <td><input type="text" id="manual-sph-ou-od" placeholder="+0.00" inputmode="decimal" pattern="^[+\-]?\d*\.?\d*$"></td>
  <td><input type="text" id="manual-cyl-ou-od" placeholder="+0.00" inputmode="decimal" pattern="^[+\-]?\d*\.?\d*$"></td>
  <td><input type="number" id="manual-axis-ou-od" placeholder="0" step="1" min="0" max="180"></td>
  <td id="manual-se-diff-ou">+0.00</td>
  <td>
<select id="manual-dc-ou-od" class="dc-select">
  <option value="BAL">BAL</option>
  <option value="R1">R1</option>
  <option value="R2">R2</option>
  <option value="R3">R3</option>
  <option value="R4">R4</option>
  <option value="R5">R5</option>
  <option value="G1">G1</option>
  <option value="G2">G2</option>
  <option value="G3">G3</option>
  <option value="G4">G4</option>
  <option value="G5">G5</option>
</select>
  </td>
</tr>

<!-- Left Eye -->
<tr class="paleblue">
  <td style="border-top:none;">
    <div class="choice-group">
      <input type="radio" id="manual-ou-wear-contacts" name="manual-ou-wear" value="contacts">
      <label for="manual-ou-wear-contacts">Contacts</label>
    </div>
  </td>
  <td>L</td>
  <td><input type="text" id="manual-sph-ou-os" placeholder="+0.00" inputmode="decimal" pattern="^[+\-]?\d*\.?\d*$"></td>
  <td><input type="text" id="manual-cyl-ou-os" placeholder="+0.00" inputmode="decimal" pattern="^[+\-]?\d*\.?\d*$"></td>
  <td><input type="number" id="manual-axis-ou-os" placeholder="0" step="1" min="0" max="180"></td>
  <!-- If you don't actually want per-eye SE shown, you can remove this cell; code guards it. -->
  <td>—</td>
  <td>
<select id="manual-dc-ou-od" class="dc-select">
  <option value="BAL">BAL</option>
  <option value="R1">R1</option>
  <option value="R2">R2</option>
  <option value="R3">R3</option>
  <option value="R4">R4</option>
  <option value="R5">R5</option>
  <option value="G1">G1</option>
  <option value="G2">G2</option>
  <option value="G3">G3</option>
  <option value="G4">G4</option>
  <option value="G5">G5</option>
</select>
  </td>
</tr>
<tr class="paleblue">
  <!-- This cell spans 2 rows -->
  <td rowspan="2" colspan="1"><b>Extra Notes:</b></td>
  <td colspan="6" rowspan="2">
    <textarea id="extra-notes" rows="2" placeholder="Type anything here..." 
  style="width:95%; height:40px; box-sizing:border-box;"></textarea>

  </td>
</tr>
<tr></tr>


<tr class="paleblue">
  <td colspan="7" style="padding:2px;"><i>~ End ~</i></td>
</tr>
</tbody>

</table>
</div>



<div id="exam-comfy" style="display:none;">
<table>
<tr class="calibrator">
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
</tr>
<tr class="comfort">
    <td colspan="2" style="padding:10px; color: #241D0C; text-align:left; border-right:none;">
<b>Comfy Clearer Rx</b></td>
<td colspan="2" style="text-align:left; border-left:none;">
<span id="testToggle1" style="cursor:pointer; user-select:none; color: #101F01; margin-left:px;">
  <b><i>● Status?</i></B>


</td>
<td colspan="3" style="padding:10px; color: #241D0C; text-align:left;">
    <span style="margin-left:15px;  margin-right:15px; text-decoration:none; cursor:pointer; user-select:none;"
          onclick="event.stopPropagation(); let t=document.getElementById('deficit-rows-comfort'); t.style.display=t.style.display==='none'?'table-row-group':'none';">
     ▼▲ Test
    </span>

<span class="toggle-btn" data-target="toggle-section-comfort-rx"
          style="cursor:pointer; color: #101F01; user-select:none; margin-right:15px;">
      ▼▲ Results 
    </span>

</td>

  </td>
</tr>




  <tbody id="deficit-rows-comfort" style="display:none;">

<tr><td colspan="7">
<span style="margin-left:20px; cursor:pointer; user-select:none;" id="toggle-reference2">
  ▼ FC DC Reference & Calculator
</span>
<div id="reference2" style="display:none;">

<div id="axis-dc-spot-2"></div>
</div>
</td></tr>



  <!-- Deficit Rows -->
  <tr class="white">
<td colspan="1"><b>Test</b></td>
<td><b>R/L</b></td>
<td><b>Sph</b></td>
<td colspan="1"><b>Cyl</b></td>
<td colspan="1"><b>Axis</b></td>
<td><b>SE Diff</b></td>
<td><b>DC</b></td>
 
<tr class="white">
    <td rowspan="1">FC DC Error<br>Notes</td>
<td>B</td>

    <td><input id="dc-sph-ou-notes" placeholder="+0.00"></td>
    <td><input id="c2_ou_notes" placeholder="+0.00"></td>
    <td><input id="a2_ou_notes" placeholder="0"></td>
    <td id="def-se-diff-ou-notes">—</td>
    <td id="now-dc-ou-notes">BAL</td> 
  </tr>

<tr class="now">
    <td><b>Adjusted<br>FC DC Error<b></td>
<td>B</td>
    <td><input id="dc-sph-ou" placeholder="+0.00"></td>
    <td><input id="c2_ou" placeholder="+0.00"></td>
    <td><input id="a2_ou" placeholder="0"></td>
    <td id="def-se-diff-ou">—</td>
    <td id="dc-ou">—</td>
  </tr>

<tr class="now">
  <td rowspan="2">FC DC<br>Balance</td>
<td>R</td>
  <td id="final-sph-ou-re">0.00</td>
  <td id="final-cyl-ou-re">0.00</td>
  <td id="final-axis-ou-re">0</td>
  <td id="final-se-ou-re" style="display:none;">—</td>
  <td id="bypass-final-ou">—</td>
  <td id="final-dc-ou-re">—</td>
</tr>
<tr class="now">
 <td>L</td>

  <td id="final-sph-ou-le">0.00</td>
  <td id="final-cyl-ou-le">0.00</td>
  <td id="final-axis-ou-le">0</td>
  <td id="final-se-ou-le" style="display:none;">—</td>
  <td>—</td>
  <td id="final-dc-ou-le">—</td>
</tr>




</tbody>


<tbody class="toggle-section-comfort-rx" style="display:none;">


<tr class="comfort">
<td><b>Final RX</b></td>
<td><b>R/L</b></td>
<td><b>Sph</b></td>
<td><b>Cyl</b></td>
<td><b>Axis</b></td>
<td><b>SE Diff</b></td>
<td><b>DC</b></td>
  </tr>

<tr class="comfort">
<td style="border-bottom:none;">
  <div class="choice-group">
    <input type="radio" id="wear-glasses" name="wearType" value="glasses">
    <label for="wear-glasses">Glasses</label>
</div>
</td>

<td>R</td>

    <td id="res-sph-ou-re">0.00</td>
    <td id="res-cyl-ou-re">0.00</td>
    <td id="res-axis-ou-re">0</td>
    <td id="res-se-diff-ou-re">—</td>
    <td id="res-dc-ou-re">BAL</td>
  </tr>

<tr class="comfort">
<td style="border-top:none;">
  <div class="choice-group">
    <input type="radio" id="wear-contacts" name="wearType" value="contacts">
    <label for="wear-contacts">Contacts</label>
  </div>
</td>
 <td>L</td>
    <td id="res-sph-ou-le">0.00</td>
    <td id="res-cyl-ou-le">0.00</td>
    <td id="res-axis-ou-le">0</td>
    <td >—</td>
    <td id="res-dc-ou-le">BAL</td>
  </tr>
<tr class="adjustments">
<td colspan="7">
<span onclick="toggleRow('adjustments-row-1')" 
   style="cursor:pointer; color:black; user-select:none; margin:0px 30px;">
  ▼▲ Adjustments
</span>

 <span class="toggle-btn" data-target="toggle-section-comfort-analysis" 
      style="margin-left:0px; margin-right:15px; user-select:none; cursor:pointer; color: #241D0C; user-select:none;">
▼▲ Analysis
</span>

</td>
</tr>



<tr class="adjustments" id="adjustments-row-1" style="display:none;">
  <td>Adjustments</td>
  <td>B</td>
  <td colspan="5" style="padding:0px; text-align:left;">
    <div>
      <!-- Clickable control to apply -0.25 x 180 -->
      <span class="addMinus025" role="button" 
            style="cursor:pointer; user-select:none; margin-right:10px; margin-left:20px;">
        Apply -0.25 × 180
      </span>

      ● 
     <span class="sph-btn" data-group="ou" data-step="-0.25"
            style="cursor:pointer; text-decoration:none; color:green; margin-right:5px;">
        S-0.25
      </span>

      <span class="sph-btn" data-group="ou" data-step="0.25"
            style="cursor:pointer; text-decoration:none; color:red; margin-right:10px;">
        S+0.25
      </span>= <span id="dc-advice" style=" font-weight:normal; color:black;">
  <!-- DC advice will show here -->
</span>
    </div>

  </td>
</tr>
<tr class="comfort">
  <td rowspan="2" colspan="1"><b>Extra Notes:</b></td>
  <td colspan="6" rowspan="2">
    <textarea id="extra-notes" rows="2" placeholder="Type anything here..." 
  style="width:95%; height:100px; box-sizing:border-box;"></textarea>  </td>
</tr>


<tr></tr>

<tr class="comfort">
  <td colspan="7" style="padding:2px;"><i>~ End ~</i></td>
</tr>

<tbody class="toggle-section-comfort-analysis" style="display:none;">

<tr class="comfort">
<td id="analysis-ou" colspan="7" style="text-align:left; padding-left:20px; border-bottom:none;"></td>
</td>
</tr>
<tr class="comfort">
<td id="analysis-ou-sph" colspan="7" style="text-align:left; padding-left:20px; border-bottom:none; border-top:none;"></td>
</tr>
<tr class="comfort">
<td colspan="7" style="text-align:left; padding-left:20px; border-top:none;">
<span id="analysis-ou-cylax"></span><br><br>
</td>
</tr>


</tbody>
</tbody>

</table>

</div>

</div>








<!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ----><!--- Sharper RX ---->




<div id="exam-sharpest" style="display:none;">


<table>
<tr class="calibrator">
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
</tr>
<tr class="paleviolet">
  <td colspan="2" style="padding:10px; color: #241D0C; text-align:left; border-right:none;">
<b>Sharpest Ever Rx</b></td>
<td colspan="2" style="text-align:left; border-left:none;">
<span id="testToggle2" style="cursor:pointer; user-select:none; color: #241D0C;">
  <b><i>● Status?</i></B>
</span>&nbsp;&nbsp;&nbsp;

</td>
<td colspan="3" style="padding:10px; color: #241D0C; text-align:left;">
<span style="margin-left:15px; margin-right:15px; text-decoration:none; cursor:pointer; color:#241D0C; user-select:none;"
          onclick="event.stopPropagation(); let t=document.getElementById('deficit-rows-sharper'); t.style.display=t.style.display==='none'?'table-row-group':'none';">
      ▼▲ Test
    </span>

 <span class="toggle-btn" data-target="toggle-section-sharper-rx" 
      style="margin-left:0px; margin-right:15px; user-select:none; cursor:pointer; color: #241D0C; user-select:none;">
▼▲ Results
</span>

</td>
</tr>

<!-- Deficit Rows (wrapped in toggle container) -->
<tbody id="deficit-rows-sharper" style="display:none;">
<tr>
<td colspan="7" style="padding:1px; border:none;"></td>
</tr>

  <tr class="white">
<td colspan="1"><b>Test</b></td>
<td><b>R/L</b></td>
<td><b>Sph</b></td>
<td colspan="1"><b>Cyl</b></td>
<td colspan="1"><b>Axis</b></td>
<td><b>SE Diff</b></td>
<td><b>DC</b></td>

  </tr>

  <tr class="white">
    <td rowspan="2">FC DC Error<br>Notes</td>
<td>R</td>

    <td><input id="dc-sph-od-notes" placeholder="+0.00"></td>
    <td><input id="c2_od_notes" placeholder="+0.00"></td>
    <td><input id="a2_od_notes" placeholder="0"></td>
    <td id="def-se-diff-od-notes">—</td>
    <td id="now-dc-od-notes">BAL</td> 
  </tr>

  <tr class="white">
<td>L</td>

    <td><input id="dc-sph-os-notes" placeholder="+0.00"></td>
    <td><input id="c2_os_notes" placeholder="+0.00"></td>
    <td><input id="a2_os_notes" placeholder="0"></td>
    <td id="def-se-diff-os-notes">—</td>
    <td id="now-dc-os-notes">BAL</td> 
  </tr>


  <tr class="now">
    <td rowspan="2"><B>Adjusted<br>FC DC Error</b></td>
<td>Right</td>

    <td><input id="dc-sph-od" placeholder="+0.00"></td>
    <td><input id="c2_od" placeholder="+0.00"></td>
    <td><input id="a2_od" placeholder="0"></td>
    <td id="def-se-diff-od">—</td>
    <td id="now-dc-od">—</td> 
  </tr>

  <tr class="now">
<td>Left</td>

    <td><input id="dc-sph-os" placeholder="+0.00"></td>
    <td><input id="c2_os" placeholder="+0.00"></td>
    <td><input id="a2_os" placeholder="0"></td>
    <td id="def-se-diff-os">—</td>
    <td id="now-dc-os">—</td> 
  </tr>

  <tr class="now">
    <td rowspan="2">FC DC<br>Balance</td>
<td>Right</td>

    <td id="final-sph-od">0.00</td>
    <td id="final-cyl-od">0.00</td>
    <td id="final-axis-od">0</td>
    <td id="final-se-od" style="display:none;">—</td>
    <td id="bypass-final-mono">—</td>
    <td id="final-dc-od">BAL </td>
  
  </tr>
  <tr class="now">
    <td>Left</td>
    <td id="final-sph-os">0.00</td>
    <td id="final-cyl-os">0.00</td>
    <td id="final-axis-os">0</td>
    <td id="final-se-os" style="display:none;">—</td>
    <td>—</td>
    <td id="final-dc-os">BAL </td>
    
  </tr>

</tbody>


<tbody class="toggle-section-sharper-rx" style="display:none;">
<tr>
<td colspan="7" style="padding:1px; border:none;"></td>
</tr>
  <tr class="paleviolet">
<td><b>Results</b></td>
<td><b>Sides</b></td>
<td><b>Sph</b></td>
<td><b>Cyl</b></td>
<td><b>Axis</b></td>
<td><b>SE Diff</b></td>
<td><b>DC</b></td>
  </tr>

  <tr class="paleviolet">
    <td rowspan="2">Final RX<br>-----<br>
<span id="toggleAdjustments2" 
      style="cursor:pointer; user-select:none; color: #241D0C;">
  ▼▲ Adjust
</span></td>
<td>Right</td>
    <td id="res-sph-od-2">0.00</td>
    <td id="res-cyl-od-2">0.00</td>
    <td id="res-axis-od-2">0</td>
    <td id="res-se-od-2" style="display:none;">—</td>
    <td id="bypass">—</td>
    <td id="res-dc-od-2">BAL</td> 
  </tr>
  <tr class="paleviolet">
    <td>Left</td>
    <td id="res-sph-os-2">0.00</td>
    <td id="res-cyl-os-2">0.00</td>
    <td id="res-axis-os-2">0</td>
    <td>—</td>    
    <td id="res-se-os-2" style="display:none;">—</td>
    <td id="res-dc-os-2">BAL</td> 
  </tr>

<tr class="now-comfort adj2" style="display:none;">

<td rowspan="3">Adjustments</td>
<td style="display:none;">Both</td>
<td colspan="5" style="padding:7px; text-align:left; display:none;">
 <!-- Clickable control to apply -0.25 x 180 -->

    <span class="addMinus025" role="button" 
          style="cursor:pointer; user-select:none; margin-right:30px; margin-left:20px;">
      Apply -0.25 × 180
    </span> 
●
<!-- SPH Controls -->
    <span class="sph-btn" data-group="mono" data-step="-0.25"
          style="cursor:pointer; text-decoration:none; color:green; margin-right:5px; margin-left:0px;">
     S-0.25
   </span>
    <span class="sph-btn" data-group="mono" data-step="0.25"
          style="cursor:pointer; text-decoration:none; color:red; margin-right:30px; margin-left:0px;">
     S+0.25
</span>

</td>
</tr>

<tr class="now-comfort adj2" style="display:none;">
<td>Right</td>
<td colspan="5" style="padding:7px; text-align:left;">
    <span class="addMinus025" role="button" 
          style="cursor:pointer; user-select:none; margin-right:30px; margin-left:20px;">
      Apply -0.25 × 180
    </span> 
●
<span class="sph-btn-mono" data-eye="od" data-step="-0.25"
          style="cursor:pointer; user-select:none; text-decoration:none; color:green; margin-right:5px; margin-left:0px;">
     S-0.25
   </span>
<span class="sph-btn-mono" data-eye="od" data-step="0.25"
          style="cursor:pointer; user-select:none; text-decoration:none; color:red; margin-right:30px; margin-left:0px;">
     S+0.25
</span>


<tr class="now-comfort adj2" style="display:none;">
<td>Left</td>
<td colspan="5" style="padding:7px; text-align:left;">
    <span class="addMinus025" role="button" 
          style="cursor:pointer; user-select:none; margin-right:30px; margin-left:20px;">
      Apply -0.25 × 180
    </span> 
●
<span class="sph-btn-mono" data-eye="os" data-step="-0.25"
          style="cursor:pointer; user-select:none; text-decoration:none; color:green; margin-right:5px; margin-left:0px;">
     S-0.25
   </span>
<span class="sph-btn-mono" data-eye="os" data-step="0.25"
          style="cursor:pointer; user-select:none; text-decoration:none; color:red; margin-right:30px; margin-left:0px;">
     S+0.25
</span>

</td></tr>
<tr><td colspan="7">
<span class="toggle-btn" data-target="toggle-section-sharper-analysis"
          style="cursor:pointer; color: #101F01; user-select:none; text-align:middle;">
    ▼▲ Analysis
    </span>
</td></tr>


  <tr class="paleviolet">
<tr class="paleviolet">
  <td rowspan="2" colspan="1"><b>Extra Notes:</b></td>
  <td colspan="6" rowspan="2">
    <textarea id="extra-notes" rows="2" placeholder="Type anything here..." 
  style="width:95%; height:100px; box-sizing:border-box;"></textarea>

  </td>
</tr>
<tr></tr>
<tr class="paleviolet">
  <td colspan="7" style="padding:2px;"><i>~ End ~</i></td>
</tr>
</tbody>


<tbody class="toggle-section-sharper-analysis" style="display:none;">
  <tr class="paleviolet">
    <td id="analysis-od-os" colspan="7" style="text-align:left; padding-left:20px;">
    <!-- Combined analysis text for OD OS will appear here -->'
</td>
</tr>

</tbody>
</table>

</div>
</div>



<!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE -----><!---- MATHS LOGIC STARTS HERE ----->


<!-- script for AA calculator & change tolerance (keep this below the row) -->

<script>
function roundDownToQuarter(value) {
  return Math.floor(value / 0.25) * 0.25;
}

// Convert diopters into distance in cm
function diopterToDistanceCm(D) {
  if (D <= 0) return "∞";
  let meters = 1 / D;
  return (meters * 100).toFixed(0) + " cm";
}

// Healthy distance = (AA + 0.00 D) → convert to distance
function healthyDistance(D) {
  let healthyD = D + 0.00;
  if (healthyD <= 0) return "None";

  let cm = parseInt(diopterToDistanceCm(healthyD), 10); // convert to number
  let displayCm = cm > 100 ? 100 : cm;                   // cap display only

  return displayCm + " cm";
}

// Curved AA formula
function calculateAA(age) {
  const AA_young = 18.5; // Peak AA
  const AA_min = 0.33;   // Minimum AA
  const k = 0.1;         // Decay rate
  const age0 = 20;       // Reference age

  let aa = AA_min + (AA_young - AA_min) * Math.exp(-k * (age - age0));
  if (aa < AA_min) aa = AA_min;
  return aa;
}

// Calculate Add Needed (numeric value)
function addNeeded(aa, workingCm) {
  if (workingCm <= 0) return "–";
  let targetD = 100 / workingCm;        // convert cm to diopters
  let gap = targetD - aa;               // difference
  let add = gap + 0.50;                 // add 0.50 D buffer
  if (add < 0) add = 0;                 // limit to 0 if negative
  return parseFloat(add.toFixed(2));
}

// Format Add Needed as range
function addNeededRange(add) {
  if (add === "–") return "–";

  // Round UP to nearest 0.25
  let upper = Math.ceil(add / 0.25) * 0.25;

  // Lower bound is 0.50 D less
  let lower = upper - 0.50;
  if (lower < 0) lower = 0;

  return "From +" + lower.toFixed(2) + "  to +" + upper.toFixed(2);
}

// Calculate change tolerance with age-based limiter
function changeTolerance(aa, age) {
  if (typeof aa !== 'number' || aa <= 0) return "0 (0.00 D)";
  if (typeof age !== 'number' || age <= 0) age = 99; // fallback

  // Original formula
  let original = aa * 0.10 + 0.15;

  // Age-based multiplier limiter
  let multiplier = 1; // default no limit
  if (age >= 18 && age <= 25) multiplier = 0.3;
  else if (age >= 14 && age <= 17) multiplier = 0.25;
  else if (age >= 9 && age <= 13) multiplier = 0.2;
  else if (age <= 8) multiplier = 0.15;

  let ageLimited = ((original - 1.75) * multiplier) + 1.75;

  // Apply limiter
  if (original > ageLimited) original = ageLimited;

  // Round to nearest 0.25 for display
  let rounded = Math.round(original / 0.25) * 0.25;

  return original.toFixed(2) + ' (' + rounded.toFixed(2) + ' D)';
}




// Main calculation function
function calcAA() {
  const ageEl = document.getElementById('ageInput');
  const aaEl = document.getElementById('aaOutput');
  const distEl = document.getElementById('distOutput');
  const healthyEl = document.getElementById('healthyDistOutput');

  const tdInputEl = document.getElementById('targetDistInput');   // target distance (cm)
  const addEl = document.getElementById('addOutput');             // Add Needed
  const toleranceEl = document.getElementById('toleranceOutput'); // Change Tolerance

  const age = parseFloat(ageEl.value);
  const tdCm = parseFloat(tdInputEl.value);

  if (isNaN(age) || age <= 0) {
    aaEl.textContent = '–';
    distEl.textContent = '–';
    healthyEl.textContent = '–';
    addEl.textContent = '–';
    toleranceEl.textContent = '–';
    return;
  }

  // Calculate AA (curved)
  let aa = calculateAA(age);

  // Bracket AA
  let bracket = roundDownToQuarter(aa);
  if (bracket < 0) bracket = 0;

  // Display AA and distances
  aaEl.textContent = aa.toFixed(2) + ' D (' + bracket.toFixed(2) + ' D)';
  distEl.textContent = diopterToDistanceCm(bracket);
  healthyEl.textContent = healthyDistance(bracket);

function calcAA2() {
  const tdInputEl2 = document.getElementById('targetDistInput2');
  const addEl2 = document.getElementById('addOutput2');

  const ageEl = document.getElementById('ageInput'); // same age used
  const age = parseFloat(ageEl.value);
  const tdCm2 = parseFloat(tdInputEl2.value);

  if (isNaN(age) || age <= 0 || isNaN(tdCm2) || tdCm2 <= 0) {
    addEl2.textContent = '–';
    return;
  }

  let aa = calculateAA(age);          // reuse same AA function
  let addVal = addNeeded(aa, tdCm2);  // reuse same Add Needed function
  addEl2.textContent = addNeededRange(addVal);
}

// Live update for second calculator
document.getElementById('targetDistInput2').addEventListener('input', calcAA2);
document.getElementById('ageInput').addEventListener('input', calcAA2);


  // Calculate Add Needed and display as range
  if (!isNaN(tdCm) && tdCm > 0) {
    let addVal = addNeeded(aa, tdCm);
    addEl.textContent = addNeededRange(addVal);
  } else {
    addEl.textContent = '–';
  }

  // Display change tolerance (12% of AA)
let tolerance = changeTolerance(aa, age);
toleranceEl.textContent = tolerance;

}

// Live update
document.getElementById('ageInput').addEventListener('input', calcAA);
document.getElementById('targetDistInput').addEventListener('input', calcAA);
document.getElementById('ageInput').addEventListener('input', () => {
    updateODOSAnalysis();
    updateOUAnalysis();
});


</script>

<!-- script for AA calculator -->


<script>
function formatQuarter(val) {
  const num = parseFloat(val);
  if (isNaN(num)) return "";
  const r = Math.round(num / 0.25) * 0.25;
  return (r >= 0 ? "+" : "") + r.toFixed(2);
}

function formatAxis(val) {
  let num = parseInt(val, 10);
  if (isNaN(num)) return "";
  if (num < 0) num = 0;
  if (num > 180) num = 180;
  return String(Math.round(num));
}

function calcSE(s, c) {
  if (isNaN(s)) s = 0;   // default sph to 0
  if (isNaN(c)) c = 0;   // default cyl to 0
  return s + (c / 2);
}

function calcSE(s, c) {
  if (isNaN(s)) s = 0;
  if (isNaN(c)) c = 0;
  return s + (c / 2);
}

function updateManualOU() {
  // Right Eye
  let sOD = parseFloat(document.getElementById("manual-sph-ou-od").value);
  let cOD = parseFloat(document.getElementById("manual-cyl-ou-od").value);
  let aOD = document.getElementById("manual-axis-ou-od").value;

  if (aOD !== "") document.getElementById("manual-axis-ou-od").value = formatAxis(aOD);

  const SEod = calcSE(sOD, cOD);
  const seOdEl = document.getElementById("manual-se-ou-od");
  if (seOdEl) seOdEl.textContent = isNaN(SEod) ? "—" : formatQuarter(SEod);

  // Left Eye
  let sOS = parseFloat(document.getElementById("manual-sph-ou-os").value);
  let cOS = parseFloat(document.getElementById("manual-cyl-ou-os").value);
  let aOS = document.getElementById("manual-axis-ou-os").value;

  if (aOS !== "") document.getElementById("manual-axis-ou-os").value = formatAxis(aOS);

  const SEos = calcSE(sOS, cOS);
  const seOsEl = document.getElementById("manual-se-ou-os");
  if (seOsEl) seOsEl.textContent = isNaN(SEos) ? "—" : formatQuarter(SEos);

// SE Diff
const diffEl = document.getElementById("manual-se-diff-ou");
if (diffEl) {
  if (isNaN(SEod) && isNaN(SEos)) {
    diffEl.textContent = "—";
  } else {
    const diff = Math.abs((isNaN(SEod) ? 0 : SEod) - (isNaN(SEos) ? 0 : SEos));
    diffEl.textContent = (diff >= 0 ? "+" : "") + diff.toFixed(2);
  }
}
}

// --- Event bindings ---
[
  "manual-sph-ou-od","manual-cyl-ou-od","manual-axis-ou-od",
  "manual-sph-ou-os","manual-cyl-ou-os","manual-axis-ou-os"
].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;

  // Live updates while typing
  el.addEventListener("input", updateManualOU);

  // Snap to 0.25 when leaving the field
  if (id.includes("sph") || id.includes("cyl")) {
    el.addEventListener("blur", () => {
      let val = parseFloat(el.value);
      if (!isNaN(val)) el.value = formatQuarter(val);
      updateManualOU();
    });
  }
});



// Auto-update on any change while typing
[
  "manual-sph-ou-od","manual-cyl-ou-od","manual-axis-ou-od",
  "manual-sph-ou-os","manual-cyl-ou-os","manual-axis-ou-os"
].forEach(id => {
  const el = document.getElementById(id);
  if (el) el.addEventListener("input", updateManualOU);
});

// DC colorize (persists)
function updateDCcolor(sel) {
  const v = sel.value || "";
  if (v.startsWith("R")) sel.style.color = "red";
  else if (v.startsWith("G")) sel.style.color = "green";
  else sel.style.color = "black";
}
document.querySelectorAll("select.dc-select").forEach(sel => {
  sel.addEventListener("change", () => updateDCcolor(sel));
  updateDCcolor(sel); // initial
});
</script>










<script>
function formatToNearestQuarter(value) {
  let num = parseFloat(value);
  if (isNaN(num)) return "+0.00";
  // round to nearest 0.25
  let rounded = Math.round(num / 0.25) * 0.25;
  return (rounded >= 0 ? "+" : "") + rounded.toFixed(2);
}

function formatAxis(value) {
  let num = parseInt(value, 10);
  if (isNaN(num)) return "180";
  if (num <= 0) return "180";
  if (num > 180) return "180";
  return String(num);
}

function attachNoteHandlers() {
  const ids = [
    // --- OD / OS ---
    "dc-sph-od-notes", "c2_od_notes", "a2_od_notes",
    "dc-sph-os-notes", "c2_os_notes", "a2_os_notes",
    // --- OU (regular) ---
    "dc-sph-ou-notes", "c2_ou_notes", "a2_ou_notes",
    // --- OU (manual) ---
    "dc-sph-ou-manual-notes", "c2_ou_manual_notes", "a2_ou_manual_notes","add-ou"
  ];

  ids.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;

    el.addEventListener("blur", () => {
      let val = el.value.trim();

      if (id.includes("axis") || id.includes("a2_")) {
        // Axis formatting
        el.value = formatAxis(val);
      } else {
        // Sphere / Cylinder formatting
        el.value = formatToNearestQuarter(val);
      }
    });
  });
}

// Run after DOM is ready
document.addEventListener("DOMContentLoaded", attachNoteHandlers);
</script>






<script>
document.querySelectorAll('.toggle-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const target = btn.getAttribute('data-target');
    document.querySelectorAll(`.${target}`).forEach(el => {
      el.style.display = (el.style.display === 'none' || el.style.display === '') ? 'table-row-group' : 'none';
    });
  });
});
</script>

<script>
function makeToggle(spanId, hideClass) {
  const span = document.getElementById(spanId);
  let testDone = false; // initial state

  span.addEventListener("click", () => {
    testDone = !testDone; // toggle state

    if (testDone) {
      span.textContent = "● ✅ Selected";
      span.style.fontWeight = "bold";

      if (hideClass) {
        document.querySelectorAll("." + hideClass).forEach(el => {
          el.style.display = "inline";
        });
      }
    } else {
      span.textContent = "● ❌ Unselected";
      span.style.fontWeight = "bold";

      if (hideClass) {
        document.querySelectorAll("." + hideClass).forEach(el => {
          el.style.display = "none";
        });
      }
    }
  });
}

// usage examples
makeToggle("testToggle1", "testStatus"); // this one toggles other spans
makeToggle("testToggle2");               // standalone
makeToggle("testToggle3");               // standalone

</script>


<script>
document.getElementById("toggleAdjustments2").addEventListener("click", function() {
  document.querySelectorAll(".adj2").forEach(row => {
    row.style.display = (row.style.display === "none" || row.style.display === "") 
      ? "table-row" 
      : "none";
  });
});
</script>



<!-- Reusable script -->
<script>
function toggleRow(rowId) {
  const row = document.getElementById(rowId);
  row.style.display = (row.style.display === "none" || row.style.display === "")
    ? "table-row"
    : "none";
}
</script>



<script>
document.addEventListener("DOMContentLoaded", () => {

  // Shared state for all mirrors
  let testDone = false;

  // Function to update all mirrors
  function updateTestStatusMirrors() {
    document.querySelectorAll(".testStatus").forEach(el => {
      el.textContent = testDone ? "Test done" : "Test ongoing..";
      el.style.color = testDone ? "black" : "black";
    });
  }

  // Attach click listener to all current and future mirrors
  function attachMirrorListeners() {
    document.querySelectorAll(".testStatus").forEach(el => {
      if(!el.dataset.listenerAttached){
        el.addEventListener("click", () => {
          testDone = !testDone;
          updateTestStatusMirrors();
        });
        el.dataset.listenerAttached = "true";
      }
    });
  }

  // Initial setup
  attachMirrorListeners();
  updateTestStatusMirrors();

  // Optional: observe DOM changes to attach listeners to newly added mirrors
  const observer = new MutationObserver(() => {
    attachMirrorListeners();
  });
  observer.observe(document.body, { childList: true, subtree: true });

});
</script>

<script>
document.addEventListener("DOMContentLoaded", () => {

  let testDone = false; // existing shared state

  function updateMirrors() {
    document.querySelectorAll(".testStatus").forEach(el => {
      if (testDone) {
        el.textContent = "● RX Finalized";
        el.style.textDecoration = "none";  
        el.style.fontStyle = "normal";          
        el.style.fontWeight = "bold";
      } else {
        el.textContent = "● RX Not Final";
        el.style.textDecoration = "none";       
        el.style.fontWeight = "normal";
      }
    });


  // Mirror click behavior: toggle
  document.querySelectorAll(".testStatus").forEach(el => {
    el.addEventListener("click", () => {
      testDone = !testDone;
      updateMirrors();
    });
  });

  // Reset mirrors whenever a calculator input changes
  const inputIds = [
    "s1_od","c1_od","a1_od",
    "s1_os","c1_os","a1_os",
    "dc-sph-od","c2_od","a2_od",
    "dc-sph-os","c2_os","a2_os",
    "dc-sph-ou","c2_ou","a2_ou"
  ];

  inputIds.forEach(id => {
    const el = document.getElementById(id);
    if(el) el.addEventListener("input", () => {
      testDone = false;
      updateMirrors();
    });
  });



  // Reset mirrors on adjustment buttons
  const adjustmentButtons = document.querySelectorAll(".addMinus025, .sph-btn, .sph-btn-mono");
  adjustmentButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      testDone = false;
      updateMirrors();
    });
  });

  updateMirrors(); // initialize
});
</script>




<script>

window.extraMinus025 = window.extraMinus025 ?? false;

document.addEventListener("DOMContentLoaded", () => {

// ---------- Toggle for extra -0.25 @ 180 (mirror buttons) ----------

// helper to update all mirror buttons' label + color so they stay in sync
function updateMinus025Buttons() {
  document.querySelectorAll('.addMinus025').forEach(b => {
    b.style.color = extraMinus025 ? 'red' : 'black';
    b.textContent = extraMinus025 ? '● Horizon Enhance' : '● All Angles Even';
  });
}

// attach listener to every mirror button
document.querySelectorAll('.addMinus025').forEach(btn => {
  btn.addEventListener('click', () => {
    window.extraMinus025 = !window.extraMinus025;
    updateMinus025Buttons();
    combineAll();
updateAnalysisOuCylAx();
  });
});

// set initial text/color
updateMinus025Buttons();

// ---------- Helpers ----------
function combineEyeWithout025(S_now, C_now, A_now, DC_S, C2, A2){
  const savedExtra = window.extraMinus025; // 🔴 read GLOBAL
  window.extraMinus025 = false;            // 🔴 temporarily disable globally
  const result = combineEyeWithDeficit(S_now, C_now, A_now, DC_S, C2, A2);
  window.extraMinus025 = savedExtra;       // 🔴 restore
  return result;
}

  // ---------- Helpers ----------
  function safeParseFloat(v){
    if(v === null || v === undefined) return 0;
    if(typeof v === "number") return Number.isFinite(v) ? v : 0;
    v = String(v).trim();
    if(v === "" || v === "—" || v === "–") return 0;
    v = v.replace(',', '.');
    const n = parseFloat(v);
    if(!Number.isNaN(n)) return n;
    const m = v.match(/[+-]?(?:\d+\.?\d*|\.\d+)/);
    return m ? parseFloat(m[0]) : 0;
  }

  function roundQuarterNumber(n){ return Math.round(safeParseFloat(n) * 4) / 4; }
  function formatValueForDisplay(n){ const val = roundQuarterNumber(n); return (val >= 0 ? "+" : "") + val.toFixed(2); }

  function calcSENumber(S, C){ S = safeParseFloat(S); C = safeParseFloat(C); return S + C/2; }
  function formatSEforDisplay(n){ return (n >= 0 ? "+" : "") + n.toFixed(2); }

  function formatSEDiffForDisplay(n){
    const num = safeParseFloat(n);
    if (isNaN(num)) return "—";
    return (num >= 0 ? "+" : "") + num.toFixed(2);
  }

  function deg2rad(d){ return d * Math.PI / 180; }
  function rad2deg(r){ return r * 180 / Math.PI; }

  function toMinusCyl({S, C, A}) {
    S = safeParseFloat(S); C = safeParseFloat(C); A = Math.round(safeParseFloat(A) || 0);
    if (C > 0) { S = S + C; C = -C; A = (A + 90) % 180; }
    A = ((A % 180) + 180) % 180;
    return { S, C, A };
  }

  function setIf(id, val){
    const el = document.getElementById(id);
    if(el) el.textContent = val;
  }

  function dcStatusText(val){
    let v = roundQuarterNumber(val);
    if(v === 0) return { text: "BAL", color: "black" };
    const absVal = Math.abs(v);
    const level = Math.max(Math.round(absVal / 0.25), 1);
    if(v > 0) return { text: `G${level} Over -${absVal.toFixed(2)}`, color: "green" };
    return { text: `R${level} Under -${absVal.toFixed(2)}`, color: "red" };
  }

  function updateDCSummaryForEye(dcInputId, dcDisplayId, nowDCId){
    const inputEl = document.getElementById(dcInputId);
    const displayEl = document.getElementById(dcDisplayId);
    const nowDCEl = document.getElementById(nowDCId);
    if(!inputEl) return;
    const val = safeParseFloat(inputEl.value);
    const info = dcStatusText(val);
    if(displayEl){ displayEl.textContent = info.text; displayEl.style.color = info.color; }
    if(nowDCEl){ nowDCEl.textContent = info.text.split(' ')[0]; nowDCEl.style.color = info.color; }
  }

  // ---------- Core vector combine function ----------
  // Combines NowRx (S1,C1,A1) with fan-chart cylinder (C2,A2) and DC sphere (DC_S)
  function combineEyeWithDeficit(S_now, C_now, A_now, DC_S, C2, A2){
    const rx1 = toMinusCyl({ S: S_now, C: C_now, A: A_now });
    const S2_from_FC = -safeParseFloat(C2) / 2;
    const rx2 = toMinusCyl({ S: S2_from_FC, C: C2, A: A2 });

    const M1 = rx1.S + rx1.C / 2;
    const J01 = -rx1.C/2 * Math.cos(2 * deg2rad(rx1.A));
    const J451 = -rx1.C/2 * Math.sin(2 * deg2rad(rx1.A));

    const M2 = rx2.S + rx2.C / 2;
    const J02 = -rx2.C/2 * Math.cos(2 * deg2rad(rx2.A));
    const J452 = -rx2.C/2 * Math.sin(2 * deg2rad(rx2.A));

    let M_total = M1 + M2 + safeParseFloat(DC_S);
    let J0_total = J01 + J02;
    let J45_total = J451 + J452;

    if (extraMinus025) {
    // Add cyl-only vector for -0.25 × 180 (J0 = +0.25)
    M_total -= 0.0625;
    J0_total += 0.125;
    }
    
    

    const C_total_raw = -2 * Math.sqrt(J0_total * J0_total + J45_total * J45_total);
    const S_total_raw = M_total - C_total_raw / 2;
    let A_total = 0.5 * rad2deg(Math.atan2(J45_total, J0_total));
    if(A_total < 0) A_total += 180;
    A_total = Math.round(A_total); // axis to nearest 1 degree

    const S_total_q = roundQuarterNumber(S_total_raw);
    const C_total_q = roundQuarterNumber(C_total_raw);

    const SE_numeric = S_total_q + C_total_q / 2;

    return { S: S_total_q, C: C_total_q, A: A_total, SE: SE_numeric };
  }

  // ---------- Main combine function (updates OU + Mono + SE diffs + DC summaries) ----------
  function combineAll(){
    try {


      // --- Read Now Rx ---
      const S_RE = safeParseFloat(document.getElementById("s1_od")?.value || 0);
      const C_RE = safeParseFloat(document.getElementById("c1_od")?.value || 0);
      const A_RE = Math.round(safeParseFloat(document.getElementById("a1_od")?.value || 0));

      const S_LE = safeParseFloat(document.getElementById("s1_os")?.value || 0);
      const C_LE = safeParseFloat(document.getElementById("c1_os")?.value || 0);
      const A_LE = Math.round(safeParseFloat(document.getElementById("a1_os")?.value || 0));

      // write Now SE (numeric) into any existing now-se ids
      const nowSE_RE_num = calcSENumber(S_RE, C_RE);
      const nowSE_LE_num = calcSENumber(S_LE, C_LE);
      setIf("now-se-od", formatSEforDisplay(nowSE_RE_num));
      setIf("now-se-os", formatSEforDisplay(nowSE_LE_num));
      setIf("now-se-od-2", formatSEforDisplay(nowSE_RE_num));
      setIf("now-se-os-2", formatSEforDisplay(nowSE_LE_num));

      // baseline now diff (RE - LE) — high sensitivity (0.01)
      const nowDiff = nowSE_RE_num - nowSE_LE_num;
      setIf("now-se-diff", formatSEDiffForDisplay(nowDiff));
      setIf("now-se-diff-od", formatSEDiffForDisplay(nowDiff));
      setIf("now-se-diff-os", formatSEDiffForDisplay(nowDiff));

      // --- Read Deficit OU ---
      const DC_OU = safeParseFloat(document.getElementById("dc-sph-ou")?.value || 0);
      const C2_OU = safeParseFloat(document.getElementById("c2_ou")?.value || 0);
      const A2_OU = Math.round(safeParseFloat(document.getElementById("a2_ou")?.value || 0));

      // OU combine for each eye (Now Rx + OU deficit vectorially)
      const RE_ou = combineEyeWithDeficit(S_RE, C_RE, A_RE, DC_OU, C2_OU, A2_OU);
      const LE_ou = combineEyeWithDeficit(S_LE, C_LE, A_LE, DC_OU, C2_OU, A2_OU);

      // write OU result fields
      setIf("res-sph-ou-re", formatValueForDisplay(RE_ou.S));
      setIf("res-cyl-ou-re", formatValueForDisplay(RE_ou.C));
const axisRE_OU = (Math.abs(RE_ou.C) < 0.001) ? "—" : (RE_ou.A === 0 ? "180" : String(RE_ou.A));
setIf("res-axis-ou-re", axisRE_OU);
setIf("res-se-ou-re", formatSEforDisplay(RE_ou.SE));

      setIf("res-sph-ou-le", formatValueForDisplay(LE_ou.S));
      setIf("res-cyl-ou-le", formatValueForDisplay(LE_ou.C));
const axisLE_OU = (Math.abs(LE_ou.C) < 0.001) ? "—" : (LE_ou.A === 0 ? "180" : String(LE_ou.A));
setIf("res-axis-ou-le", axisLE_OU);
setIf("res-se-ou-le", formatSEforDisplay(LE_ou.SE));

// --- Glasses vs Contact Lens Conversion ---
const currentWear = document.querySelector('input[name="current-wearType"]:checked')?.value; // "glasses" or "contacts"
const targetWear  = document.querySelector('input[name="wearType"]:checked')?.value;        // "glasses" or "contacts"

// Conversion functions
function glassesToCL(sph) {
  const d = 0.012; // 12mm vertex distance
  const s = parseFloat(sph) || 0;
  return s / (1 - d * s);
}
function clToGlasses(sph) {
  const d = 0.012;
  const s = parseFloat(sph) || 0;
  return s / (1 + d * s);
}

// Apply conversion only if current and target differ
if (currentWear && targetWear && currentWear !== targetWear) {
  ["res-sph-ou-re", "res-sph-ou-le"].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    const sph = parseFloat(el.textContent) || 0;

    const newSph = (currentWear === "glasses" && targetWear === "contacts")
      ? glassesToCL(sph)
      : clToGlasses(sph);

    el.textContent = formatValueForDisplay(newSph);
  });
}

document.querySelectorAll('input[name="current-wearType"], input[name="wearType"]').forEach(radio => {
  radio.addEventListener("change", combineAll);
});



// persist OU baseline sph so SPH buttons always reference the true base
const elResSphOuRe = document.getElementById("res-sph-ou-re");
if (elResSphOuRe) elResSphOuRe.dataset.base = String(RE_ou.S);
const elResSphOuLe = document.getElementById("res-sph-ou-le");
if (elResSphOuLe) elResSphOuLe.dataset.base = String(LE_ou.S);


      // OU SE diff — high sensitivity (0.01)
      const ouDiff = RE_ou.SE - LE_ou.SE;
      setIf("res-se-diff-ou", formatSEDiffForDisplay(ouDiff));
      setIf("res-se-diff-ou-re", formatSEDiffForDisplay(ouDiff));
      setIf("res-se-diff-ou-le", formatSEDiffForDisplay(ouDiff));

      // --- Mono combines (per-eye deficits) ---
      const DC_RE = safeParseFloat(document.getElementById("dc-sph-od")?.value || 0);
      const C2_RE = safeParseFloat(document.getElementById("c2_od")?.value || 0);
      const A2_RE = Math.round(safeParseFloat(document.getElementById("a2_od")?.value || 0));

      const DC_LE = safeParseFloat(document.getElementById("dc-sph-os")?.value || 0);
      const C2_LE = safeParseFloat(document.getElementById("c2_os")?.value || 0);
      const A2_LE = Math.round(safeParseFloat(document.getElementById("a2_os")?.value || 0));

      const RE_mono = combineEyeWithDeficit(S_RE, C_RE, A_RE, DC_RE, C2_RE, A2_RE);
      const LE_mono = combineEyeWithDeficit(S_LE, C_LE, A_LE, DC_LE, C2_LE, A2_LE);

      // write Mono result fields
      setIf("res-sph-od-2", formatValueForDisplay(RE_mono.S));
      setIf("res-cyl-od-2", formatValueForDisplay(RE_mono.C));
const axisOD_MONO = (Math.abs(RE_mono.C) < 0.001) ? "—" : (RE_mono.A === 0 ? "180" : String(RE_mono.A));
setIf("res-axis-od-2", axisOD_MONO);
setIf("res-se-od-2", formatSEforDisplay(RE_mono.SE));

      setIf("res-sph-os-2", formatValueForDisplay(LE_mono.S));
      setIf("res-cyl-os-2", formatValueForDisplay(LE_mono.C));
const axisOS_MONO = (Math.abs(LE_mono.C) < 0.001) ? "—" : (LE_mono.A === 0 ? "180" : String(LE_mono.A));
setIf("res-axis-os-2", axisOS_MONO);
setIf("res-se-os-2", formatSEforDisplay(LE_mono.SE));

// persist Mono baseline sph
const elResSphOd2 = document.getElementById("res-sph-od-2");
if (elResSphOd2) elResSphOd2.dataset.base = String(RE_mono.S);
const elResSphOs2 = document.getElementById("res-sph-os-2");
if (elResSphOs2) elResSphOs2.dataset.base = String(LE_mono.S);

      // Mono SE diff — high sensitivity (0.01)
      const monoDiff = RE_mono.SE - LE_mono.SE;
      setIf("res-se-diff-2", formatSEDiffForDisplay(monoDiff));
      setIf("res-se-diff-od-2", formatSEDiffForDisplay(monoDiff));
      setIf("res-se-diff-os-2", formatSEDiffForDisplay(monoDiff));

// ---------- Final OU (no -0.25) ----------
const final_RE_ou = combineEyeWithout025(S_RE, C_RE, A_RE, DC_OU, C2_OU, A2_OU);
const final_LE_ou = combineEyeWithout025(S_LE, C_LE, A_LE, DC_OU, C2_OU, A2_OU);

setIf("final-sph-ou-re", formatValueForDisplay(final_RE_ou.S));
setIf("final-cyl-ou-re", formatValueForDisplay(final_RE_ou.C));
setIf("final-axis-ou-re", (Math.abs(final_RE_ou.C)<0.001)?"—":(final_RE_ou.A===0?"180":final_RE_ou.A));
setIf("final-se-ou-re", formatSEforDisplay(final_RE_ou.SE));
setIf("final-dc-ou-re","BAL");

setIf("final-sph-ou-le", formatValueForDisplay(final_LE_ou.S));
setIf("final-cyl-ou-le", formatValueForDisplay(final_LE_ou.C));
setIf("final-axis-ou-le", (Math.abs(final_LE_ou.C)<0.001)?"—":(final_LE_ou.A===0?"180":final_LE_ou.A));
setIf("final-se-ou-le", formatSEforDisplay(final_LE_ou.SE));
setIf("final-dc-ou-le","BAL");

// ---------- Final Mono (no -0.25) ----------
const final_RE_mono = combineEyeWithout025(S_RE, C_RE, A_RE, DC_RE, C2_RE, A2_RE);
const final_LE_mono = combineEyeWithout025(S_LE, C_LE, A_LE, DC_LE, C2_LE, A2_LE);

setIf("final-sph-od", formatValueForDisplay(final_RE_mono.S));
setIf("final-cyl-od", formatValueForDisplay(final_RE_mono.C));
setIf("final-axis-od", (Math.abs(final_RE_mono.C)<0.001)?"—":(final_RE_mono.A===0?"180":final_RE_mono.A));
setIf("final-se-od", formatSEforDisplay(final_RE_mono.SE));
setIf("final-dc-od","BAL");

setIf("final-sph-os", formatValueForDisplay(final_LE_mono.S));
setIf("final-cyl-os", formatValueForDisplay(final_LE_mono.C));
setIf("final-axis-os", (Math.abs(final_LE_mono.C)<0.001)?"—":(final_LE_mono.A===0?"180":final_LE_mono.A));
setIf("final-se-os", formatSEforDisplay(final_LE_mono.SE));
setIf("final-dc-os","BAL");



// --- Bypass calculation (rounded to nearest 0.25 D) ---
// Mono (OD/OS)
const bypassRE = safeParseFloat(document.getElementById("res-se-od-2")?.textContent);
const bypassLE = safeParseFloat(document.getElementById("res-se-os-2")?.textContent);

if (!Number.isNaN(bypassRE) && !Number.isNaN(bypassLE)) {
  let bypassDiff = bypassRE - bypassLE;
  bypassDiff = Math.round(bypassDiff * 8) / 8; // round to nearest 0.125 D
  setIf("bypass", formatSEDiffForDisplay(bypassDiff));
}

// Final Mono (OD/OS)
const finalMonoRE = safeParseFloat(document.getElementById("final-se-od")?.textContent);
const finalMonoLE = safeParseFloat(document.getElementById("final-se-os")?.textContent);

if (!Number.isNaN(finalMonoRE) && !Number.isNaN(finalMonoLE)) {
  let bypassDiffMono = finalMonoRE - finalMonoLE;
  bypassDiffMono = Math.round(bypassDiffMono * 8) / 8; // nearest 0.125 D
  setIf("bypass-final-mono", formatSEDiffForDisplay(bypassDiffMono));
}

// Final OU (RE/LE)
const finalOuRE = safeParseFloat(document.getElementById("final-se-ou-re")?.textContent);
const finalOuLE = safeParseFloat(document.getElementById("final-se-ou-le")?.textContent);

if (!Number.isNaN(finalOuRE) && !Number.isNaN(finalOuLE)) {
  let bypassDiffOu = finalOuRE - finalOuLE;
  bypassDiffOu = Math.round(bypassDiffOu * 8) / 8; // nearest 0.125 D
  setIf("bypass-final-ou", formatSEDiffForDisplay(bypassDiffOu));
}



// Track offsets in 0.25 steps for OU and Mono
const sphOffsets = { ou: 0, mono: 0 };

document.querySelectorAll('.sph-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const group = btn.dataset.group;   // "ou" or "mono"
    const step = parseFloat(btn.dataset.step); // -0.25 or +0.25

    // Update offset
    sphOffsets[group] += step;

    // Reapply adjustment
    applySphOffset(group);
  });
});


// Call this after your main OU/Mono results are calculated
function applySphOffset(group) {
  const ids = (group === "ou")
    ? { right: "res-sph-ou-re", left: "res-sph-ou-le", dcr: "res-dc-ou-re", dcl: "res-dc-ou-le" }
    : { right: "res-sph-od-2", left: "res-sph-os-2", dcr: "res-dc-od-2", dcl: "res-dc-os-2" };

  const rightCell = document.getElementById(ids.right);
  const leftCell  = document.getElementById(ids.left);
  const dcRight   = document.getElementById(ids.dcr);
  const dcLeft    = document.getElementById(ids.dcl);

  if (!rightCell || !leftCell) return;

  // Preserve the original base (only set once)
  if (!rightCell.dataset.base) rightCell.dataset.base = rightCell.textContent.trim() || "0";
  if (!leftCell.dataset.base)  leftCell.dataset.base  = leftCell.textContent.trim() || "0";

  const baseRight = parseFloat(rightCell.dataset.base) || 0;
  const baseLeft  = parseFloat(leftCell.dataset.base) || 0;

// Formatter: always show + for positives
function formatSigned(value) {
  const num = parseFloat(value).toFixed(2);
  if (num > 0) return "+" + num;
  return num; // negatives already have -, zero stays 0.00
}

// Apply offset math (fixed so it doesn’t jump)
const newRight = baseRight + sphOffsets[group];
const newLeft  = baseLeft + sphOffsets[group];

rightCell.textContent = formatSigned(newRight);
leftCell.textContent  = formatSigned(newLeft);


  // Update DC label + color
  const label = getDcLabel(sphOffsets[group]);
  if (dcRight) {
    dcRight.textContent = label.text;
    dcRight.style.color = label.color;
    dcRight.style.fontWeight = "none";
  }
  if (dcLeft) {
    dcLeft.textContent = label.text;
    dcLeft.style.color = label.color;
    dcLeft.style.fontWeight = "none";
  }
}

function getDcLabel(offset) {
  if (offset === 0) return { text: "BAL", color: "black" };
  if (offset < 0) return { text: "G" + Math.abs(offset / 0.25), color: "green" };
  return { text: "R" + (offset / 0.25), color: "red" };
}


      // --- Update DC summary for eyes (ensure OU updates dc-ou) ---
      updateDCSummaryForEye("dc-sph-od", "dc-summary", "now-dc-od");
      updateDCSummaryForEye("dc-sph-os", "dc-summary", "now-dc-os");
      updateDCSummaryForEye("dc-sph-ou", "dc-summary", "dc-ou");

// --- RESET PRESCRIBED DC STATUS TO BAL ---
const prescribedDCEyes = [
  "res-dc-ou-re", "res-dc-ou-le",
  "res-dc-od-2", "res-dc-os-2"
];

prescribedDCEyes.forEach(id => {
  const el = document.getElementById(id);
  if(el) {
    el.textContent = "BAL";
    el.style.color = "black";
    el.style.fontWeight = "none";
  }
});




    } catch (err) {
      console.error("combineAll error:", err);
    }
  }

  // ---------- formatting on blur / axis handling ----------
  function isAxisId(id){
    if(!id) return false;
    return id.startsWith("a");
  }

  function autoFormatInput(el){
    if(!el) return;
    const id = el.id || "";
    let raw = String(el.value || "").trim();
    if(raw === "") return;
    if(isAxisId(id)){
      let num = parseInt(raw, 10);
      if(Number.isNaN(num)) num = 0;
      num = Math.max(0, Math.min(180, num));
      el.value = String(num);
    } else {
      let n = roundQuarterNumber(raw);
      el.value = (n >= 0 ? "+" : "") + n.toFixed(2);
    }
  }

  // ---------- Attach listeners ----------
  const inputIds = [
    "s1_od","c1_od","a1_od",
    "s1_os","c1_os","a1_os",
    "dc-sph-od","c2_od","a2_od",
    "dc-sph-os","c2_os","a2_os",
    "dc-sph-ou","c2_ou","a2_ou"
  ];

  inputIds.forEach(id => {
    const el = document.getElementById(id);
    if(!el) return;
    // live update as you type
    el.addEventListener("input", combineAll);
    // format on blur/enter
    el.addEventListener("blur", (e) => { autoFormatInput(e.target); combineAll(); });
    el.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){ e.preventDefault(); autoFormatInput(e.target); combineAll(); }
    });
  });

  // Also ensure duochrome inputs update summary live
  ["dc-sph-od","dc-sph-os","dc-sph-ou"].forEach(id => {
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener("input", () => {
      updateDCSummaryForEye("dc-sph-od","dc-summary","now-dc-od");
      updateDCSummaryForEye("dc-sph-os","dc-summary","now-dc-os");
      updateDCSummaryForEye("dc-sph-ou","dc-summary","dc-ou");
    });
  });

  // initial run
  combineAll();
});

</script>

<script>
// ---------------- Monocular Adjustments (per eye, live adjust) ----------------

// Attach listeners to monocular sph adjustment buttons
document.querySelectorAll('.sph-btn-mono').forEach(btn => {
  btn.addEventListener('click', () => {
    const eye = btn.dataset.eye;        // "od" or "os"
    const step = parseFloat(btn.dataset.step); // -0.25 or +0.25
    applySphOffsetMonoLive(eye, step);
  });
});

function applySphOffsetMonoLive(eye, step) {
  const ids = (eye === "od")
    ? { sph: "res-sph-od-2", dc: "res-dc-od-2" }
    : { sph: "res-sph-os-2", dc: "res-dc-os-2" };

  const sphCell = document.getElementById(ids.sph);
  const dcCell  = document.getElementById(ids.dc);
  if (!sphCell || !dcCell) return;

  // --- Adjust SPH directly from what's currently shown ---
  const currentVal = parseFloat(sphCell.textContent) || 0;
  const newVal = currentVal + step;
  sphCell.textContent = formatSigned(newVal);

  // --- Adjust DC purely by observing current label and nudging by 1 step ---
  const currentLabel = (dcCell.textContent || "").trim();
  const newLabel = getNextDcLabelByNudge(currentLabel, step);
  dcCell.textContent = newLabel.text;
  dcCell.style.color = newLabel.color;
  dcCell.style.fontWeight = "none";
}

// Format numbers with sign
function formatSigned(value) {
  // ensure standard +/− two-decimal format
  const num = Number(value);
  if (Number.isNaN(num)) return "+0.00";
  const s = num.toFixed(2);
  return (num >= 0 ? "+" : "") + s;
}

// Parse DC string into a numeric offset: BAL -> 0, Rn -> +n, Gn -> -n
function parseDcToNumber(current) {
  const s = String(current || "").toUpperCase().trim();
  if (s === "BAL") return 0;

  // find first R or G and the following number (e.g. "R2", "G10", or "R 1")
  const m = s.match(/([RG])\s*([-]?\d+)/i);
  if (!m) return 0;

  const dir = m[1].toUpperCase();
  const num = parseInt(m[2], 10) || 0;
  return dir === "R" ? num : -num;
}

// Convert numeric offset back to label object
function numberToDcLabel(n) {
  if (!n) return { text: "BAL", color: "black" };
  if (n > 0) return { text: "R" + n, color: "red" };
  return { text: "G" + Math.abs(n), color: "green" };
}

// Nudge the DC label by one step in the direction of `step`
// (step > 0 increments numeric by +1; step < 0 decrements numeric by 1)
function getNextDcLabelByNudge(current, step) {
  const n = parseDcToNumber(current);
  const delta = (step > 0) ? 1 : -1;
  const next = n + delta;

  return numberToDcLabel(next);
}
</script>

<script>
function updateSEDiffLive() {
  const seOD = parseFloat(document.getElementById("res-se-od-2")?.textContent) || 0;
  const seOS = parseFloat(document.getElementById("res-se-os-2")?.textContent) || 0;
  const diff = seOD - seOS;

  // Update all relevant SE diff displays
  ["res-se-diff-2", "res-se-diff-od-2", "res-se-diff-os-2"].forEach(id => {
    const el = document.getElementById(id);
    if(el) el.textContent = formatSEDiffForDisplay(diff);
  });
}

// Patch your existing monocular SPH adjustment function
function applySphOffsetMonoLive(eye, step) {
  const ids = (eye === "od")
    ? { sph: "res-sph-od-2", dc: "res-dc-od-2" }
    : { sph: "res-sph-os-2", dc: "res-dc-os-2" };

  const sphCell = document.getElementById(ids.sph);
  const dcCell  = document.getElementById(ids.dc);
  if (!sphCell || !dcCell) return;

  const currentVal = parseFloat(sphCell.textContent) || 0;
  const newVal = currentVal + step;
  sphCell.textContent = formatSigned(newVal);

  const currentLabel = (dcCell.textContent || "").trim();
  const newLabel = getNextDcLabelByNudge(currentLabel, step);
  dcCell.textContent = newLabel.text;
  dcCell.style.color = newLabel.color;
  dcCell.style.fontWeight = "none";

  // --- NEW: update SE DIFF live ---
  updateSEDiffLive();
}

// Optional: if you also allow typing directly in the SPH input, attach a listener
document.querySelectorAll("#res-sph-od-2, #res-sph-os-2").forEach(el => {
  el.addEventListener("input", updateSEDiffLive);
});
</script>

<script>
function updateBypass(eye, step) {
    const bypassCell = document.getElementById('bypass');
    if (!bypassCell) return;

    // Get current value
    let current = parseFloat(bypassCell.textContent) || 0;

    // Determine the change based on eye and step
    let delta = 0;
    if (eye === 'od') delta = step;   // Right eye: normal
    if (eye === 'os') delta = -step;  // Left eye: reverse

    const newVal = current + delta;
    bypassCell.textContent = (newVal >= 0 ? "+" : "") + newVal.toFixed(2);
}

// Attach observer to the existing monocular buttons
document.querySelectorAll('.sph-btn-mono').forEach(btn => {
    btn.addEventListener('click', () => {
        const eye = btn.dataset.eye;        
        const step = parseFloat(btn.dataset.step); 
        updateBypass(eye, step);
    });
});
</script>
















<script>
(() => {
  // isolated namespace
  const _ID = '__dcAdvice_isolated_v1';

  // small helper: robustly convert a label like "G2", "G 2", "R1", "BAL", or "G1 Over -0.25" into step integer
  // returns: 0 for BAL, positive integer for R (e.g. R2 -> 2), negative integer for G (G2 -> -2)
  function _labelToStep(raw) {
    if (!raw) return 0;
    const s = String(raw).trim().toUpperCase();
    if (s === 'BAL' || s === '—' || s === '—' ) return 0;

    // look for first occurrence of G or R followed by a number
    const m = s.match(/([GR])\s*([+-]?\d+)/i);
    if (m) {
      const dir = m[1].toUpperCase();
      const n = Math.abs(parseInt(m[2], 10) || 0);
      return dir === 'G' ? -n : n;
    }

    // fallback: if contains 'G' but no number, treat as G1; same for R
    if (/G\b/.test(s)) return -1;
    if (/R\b/.test(s)) return 1;
    return 0;
  }

// just return numbers as string
function _numToWord(n) {
  return String(n);
}


  // build the advice HTML exactly as requested
  function _buildAdviceHtml(diffSteps) {
    // diffSteps = targetStep - resultStep
    if (diffSteps === 0) return 'DC Matched.';

    const presses = Math.min(Math.abs(diffSteps), 99); // cap for safeness
    const word = _numToWord(presses);
    const plural = (presses === 1) ? 'time' : 'times';

    if (diffSteps < 0) {
      // need MORE minus -> press S-0.25 (red)
      return `Click <span style="color:green;">S-0.25</span> ${word} ${plural} balance DC.`;
    } else {
      // need MORE plus -> press S+0.25 (green)
      return `Click <span style="color:red;">S+0.25</span> ${word} ${plural} match DC.`;
    }
  }

  // main update function (safe, idempotent)
  function _updateAdvice() {
    try {
      const elTarget = document.getElementById('dc-ou');
      const elResult = document.getElementById('res-dc-ou-re');
      const elAdvice = document.getElementById('dc-advice');
      if (!elAdvice) return; // nothing to update

      // read texts (use textContent to avoid layout reflow issues)
      const targetText = elTarget ? elTarget.textContent.trim() : '';
      const resultText = elResult ? elResult.textContent.trim() : '';

      const targetStep = _labelToStep(targetText);
      const resultStep = _labelToStep(resultText);

      const diffSteps = targetStep - resultStep;
      elAdvice.innerHTML = _buildAdviceHtml(diffSteps);
    } catch (err) {
      // swallow errors so we don't interfere with other scripts; log with unique prefix if console available
      if (window && window.console && typeof window.console.error === 'function') {
        console.error(_ID + ' updateAdvice error:', err);
      }
    }
  }

  // debounce wrapper so rapid DOM edits don't produce race conditions
  let _debounceTimer = null;
  function _scheduleUpdate() {
    if (_debounceTimer) clearTimeout(_debounceTimer);
    _debounceTimer = setTimeout(() => { _debounceTimer = null; _updateAdvice(); }, 80);
  }

  // attach MutationObserver to the two elements (if available). If not, fallback to interval poll.
  function _attachObservers() {
    const elTarget = document.getElementById('dc-ou');
    const elResult = document.getElementById('res-dc-ou-re');

    // if neither exists yet, still schedule initial run and retry later
    if (!elTarget && !elResult) {
      // try again after small delay
      setTimeout(_attachObservers, 200);
      return;
    }

    // observe function
    const observeNode = (node) => {
      if (!node) return;
      try {
        if (window.MutationObserver) {
          const obs = new MutationObserver(_scheduleUpdate);
          obs.observe(node, { childList: true, characterData: true, subtree: true });
        } else {
          // fallback: simple polling (rare)
          setInterval(_scheduleUpdate, 350);
        }
      } catch (e) {
        // ignore
      }
    };

    observeNode(elTarget);
    observeNode(elResult);

    // initial update once observers set
    _scheduleUpdate();
  }

  // run after DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', _attachObservers);
  } else {
    // already ready
    _attachObservers();
  }

  // expose nothing to global scope
})();
</script>



























<script>
// ---------- Cylinder vector math (for combining with -0.25 × 180) ----------
function cylAxisToJ(cyl, axis) {
  const rad = (Math.PI/180) * (axis * 2);
  const J0 = -(cyl/2) * Math.cos(rad);
  const J45 = -(cyl/2) * Math.sin(rad);
  return { J0, J45 };
}
function jToCylAxis(J0, J45) {
  const cyl = -2 * Math.sqrt(J0*J0 + J45*J45);
  let axis = 0.5 * Math.atan2(J45, J0) * (180/Math.PI);
  if (axis < 0) axis += 180;
  if (axis === 0) axis = 180; // normalize 0→180
  return { cyl: parseFloat(cyl.toFixed(2)), axis: Math.round(axis) };
}
function combineCylAxis(c1, a1, c2, a2) {
  const A = cylAxisToJ(c1, a1);
  const B = cylAxisToJ(c2, a2);
  return jToCylAxis(A.J0 + B.J0, A.J45 + B.J45);
}

// ---------- Effects (text) ----------
function getCylStretchEffect(cylVal) {
  const c = Math.abs(Number(cylVal) || 0);
  if (c < 0.01) return null;
  const mag = `+${c.toFixed(2)}`;
  if (c <= 0.25) return `Change of ${mag} cyl is negligible, no noticeable stretch.`;
  if (c <= 0.50) return `Change of ${mag} cyl will cause mild stretch of objects, easily adapted.`;
  if (c <= 0.75) return `Change of ${mag} cyl will cause moderate stretch of objects, adaptation needed.`;
  if (c <= 1.00) return `Change of ${mag} cyl will cause strong stretch, at the usual limit for most people.`;
  return `Change of ${mag} cyl will cause very strong stretch, risky and requires long adaptation.`;
}
function nearestPrimeDist(axis) {
  // axis in 1..180, treat 0 as 180
  let a = Math.round(Number(axis) || 0);
  if (a <= 0) a = 180;
  const d90 = Math.abs(a - 90);
  const d180 = Math.min(Math.abs(a - 180), Math.abs(a - 0));
  const nearest = (d90 <= d180) ? 90 : 180;
  const dist = (nearest === 90) ? d90 : d180;
  return { dist, nearest, norm: a };
}
function getAxisTiltEffect(axis) {
  const { dist, nearest, norm } = nearestPrimeDist(axis);
  if (dist === 0) return null;
  if (dist <= 10) return `Axis ${norm}° is near prime, minimal tilt.`;
  return `Axis ${norm}° is a shift of ${dist}° from prime (${nearest}°), tilt noticeable.`;
}

// ---------- Difficulty scoring (your mapping) ----------
function cylDifficulty(cyl, age) {
  const c = Math.abs(Number(cyl) || 0);
  const over40 = (Number(age) || 0) >= 40;
  if (c <= 0.25) return 0;
  if (c <= 0.50) return over40 ? 1 : 0;
  if (c <= 0.75) return over40 ? 2 : 1;
  if (c <= 1.00) return over40 ? 3 : 2;
  if (c <= 1.25) return over40 ? 4 : 3;
  return over40 ? 4 : 4;
}
function axisDifficulty(axis, age) {
  const over40 = (Number(age) || 0) >= 40;
  const { dist } = nearestPrimeDist(axis);
  if (dist === 0) return 0;
  if (dist <= 10) return over40 ? 1 : 0;    // outer prime
  if (dist <= 20) return over40 ? 2 : 1;    // ±10 from outer prime
  if (dist <= 30) return over40 ? 3 : 2;    // ±20 from prime
  return over40 ? 4 : 3;                    // >20 from prime
}
function adaptLabel(total) {
  if (total <= 0) return "No adaptation needed.";
  if (total === 1) return "Low difficulty, adapt in 1–3 days.";
  if (total === 2) return "Mild difficulty, adapt in 3–7 days.";
  if (total === 3) return "Moderate difficulty, adapt in 1–2 weeks.";
  if (total === 4) return "Upper limit, adapt in ~2 weeks.";
  if (total === 5) return "High difficulty, adapt in 2–4 weeks.";
  if (total === 6) return "Very high difficulty, may take 3–4+ weeks.";
  return "Risky change, adaptation may fail or take >4 weeks.";
}

// ---------- Main analyzer ----------
function updateAnalysisOuCylAx() {
  let cyl = parseFloat(document.getElementById("c2_ou")?.value || "0");
  let axis = parseFloat(document.getElementById("a2_ou")?.value || "0");
  const age = parseFloat(document.getElementById("ageInput")?.value || "0");

  // If toggle is ON, combine input with -0.25 × 180
  if (window.extraMinus025) {
    const combo = combineCylAxis(cyl, axis, -0.25, 180);
    cyl = combo.cyl;
    axis = combo.axis;
  }

  // Build output
  let html = `<b><u>Astigmatism Changes Effect:</u></b><br>`;

  // "No change" == no stretch AND axis at prime
  const stretchText = getCylStretchEffect(cyl);
  const { dist: dPrime } = nearestPrimeDist(axis);
  const noChange = (!stretchText && dPrime === 0);

  if (noChange) {
    html += "- No changes in prescription.";
    document.getElementById("analysis-ou-cylax").innerHTML = html;
    return;
  }

  const tiltText = getAxisTiltEffect(axis);

  // Adaptation capability
  let adaptText = "<b>*Key in age*</b> to generate analysis.";
  if (age > 0) {
    const score = cylDifficulty(cyl, age) + axisDifficulty(axis, age);
    adaptText = adaptLabel(score);
  }

  html += `
    - <b>Stretched Effect</b>: ${stretchText || "None"}<br>
    - <b>Tilt Effect</b>: ${tiltText || "None"}<br>
    - <b>Adaptation Capability</b>: ${adaptText}
  `;

  document.getElementById("analysis-ou-cylax").innerHTML = html;
}

// ---------- Auto-update from inputs ----------
document.addEventListener("DOMContentLoaded", () => {
  ["c2_ou","a2_ou","ageInput"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener("input", updateAnalysisOuCylAx);
  });
  updateAnalysisOuCylAx(); // initial render
});
</script>
































<script>
// --- Shared DC Analysis Functions (COMFY CLEARER) ---
function parseDC(dc) {
    if (dc === null || dc === undefined) return null;
    let s = String(dc).trim();
    if (!s) return null;
    s = s.replace(/−/g, '-').toUpperCase();
    if (s === 'BAL') return { kind: 'BAL', diopter: 0, stepVal: 0, raw: s };
    const codeMatch = s.match(/^([RG])\s*(\d+)$/i);
    if (codeMatch) {
        const type = codeMatch[1].toUpperCase();
        const step = parseInt(codeMatch[2], 10);
        const diopter = (type === 'R') ? -(step * 0.25) : (step * 0.25);
        const stepVal = (type === 'R') ? -step : step;
        return { kind: 'CODE', type, step, stepVal, diopter, raw: s };
    }
    const numStr = s.replace(/[^\d\.\-+]/g, '');
    const n = parseFloat(numStr);
    if (!Number.isNaN(n)) {
        const stepVal = n / 0.25;
        return { kind: 'NUMERIC', diopter: n, stepVal, raw: s };
    }
    return { kind: 'UNKNOWN', raw: s };
}

function describeDC(dc, label = 'Current') {
    if (!dc) return '';
    const parsed = parseDC(dc);
    if (!parsed) return `${label} RX: ${dc}`;
    if (parsed.kind === 'BAL') return `${label} Well balance between distance and near vision.`;
    if (parsed.kind === 'CODE') {
        const absD = Math.abs(parsed.diopter).toFixed(2);
        const colourLabel = `<span style="color:${parsed.type === 'R' ? 'red' : 'green'}; font-weight:normal;">${parsed.raw}</span>`;
        if (parsed.type === 'R') {
            return `${label} Under by -${absD} (${colourLabel}). Good for seeing near.`;
        } else {
            if (parsed.step === 1) return `${label} Over by +${absD} (${colourLabel}). Good for seeing far.`;
            return `${label} Over by +${absD} (${colourLabel}); Good for seeing far but over-corrected prescription.`;
        }
    }
     return `${label} ${dc}`;
}

function getDeeperAnalysis(fromDC, toDC, prevParsed, toParsed) {
    const f = prevParsed && typeof prevParsed === 'object' ? prevParsed : parseDC(fromDC);
    const t = toParsed && typeof toParsed === 'object' ? toParsed : parseDC(toDC);
    if (!f || !t || f.kind === 'UNKNOWN' || t.kind === 'UNKNOWN') return '';
    const parts = [];
    if (f.kind === 'BAL' && t.kind === 'BAL') return '- <b>Distance Vision Changes</b>: No changes.<br>- <b>Near Vision Changes</b>: No changes.';
    if (f.type === 'R' && t.type === 'R' && f.step === t.step) return '- <b>Distance Vision Changes</b>: No changes.<br>- <b>Near Vision Changes</b>: No changes.';
    // Rule 1: G → G
if (f.type === 'G' && t.type === 'G') {
    if (t.step === 1) {
        parts.push('- <b>Distance Vision Changes:</b> No changes.<br>- <b>Near Vision Changes</b>: Improvement in near vision comfort and clarity range.<br>- <b>Purpose of change</b>: To prescribe proper distance preferred prescription.');
    } else if (t.step < f.step) {
        parts.push('- <b>Distance Vision Changes:</b> No changes.<br>- <b>Near Vision Changes</b>: Improvement in near vision comfort and clarity range.<br>- <b>Purpose of change</b>: To resolve the over-correction in stages.');
    } else if (t.step > f.step) {
        parts.push('- <b>Distance Vision Changes:</b> No changes.<br>- <b>Near Vision Changes</b>: Over-correction leads to eye strains fatigue at near vision.<br>- <b>Not advisable to prescribe.</b> Reduce to (<span style="color: green;">G1</span>).');
    } else {
        parts.push('- <b>Distance Vision Changes</b>: No changes.<br>- <b>Near Vision Changes</b>: No changes.');
    }
}


// Rule 4: Distance improvement
const distanceImprovementCond =
    (f.kind === 'BAL' && t.type === 'G') ||
    (f.type === 'R' && t.kind === 'BAL') ||
    (f.type === 'R' && t.type === 'R' && t.step < f.step) ||
    (f.type === 'R' && t.type === 'G' && t.step >= 1); // changed === 1 → >= 1

if (distanceImprovementCond) {
    if (t.type === 'G' && t.step >= 1) {
        if (t.step === 1) {
            parts.push(
                '- <b>Distance Vision Changes</b>: Distance clarity will improve. See as far as possible.<br>- <b>Near Vision Changes</b>: Expect slight stress when looking at near during adaptation.<br>- <b>Purpose of Changes</b>: To improve distance clarity.'
            );
        } else {
            parts.push(
                `- <b>Distance Vision Changes</b>: Distance clarity will improve. See as far as possible but over-correction.<br>- <b>Near Vision Changes</b>: Over-correction leads to eye strains fatigue at near vision.<br>- <b>Not advisable to prescribe.</b> Reduce to (<span style="color: green;">G1</span>).`
            );
        }
    } else {
let gainDist = t.kind === 'BAL' ? 20 : Math.round(((1 / (t.step * 0.25)) * 3.281) * 10) / 10;
        parts.push(
            `- <b>Distance Vision Changes</b>: Distance clarity will improve to ${gainDist} feet. <br>- <b>Near Vision Changes</b>: Expect slight stress when looking at near during adaptation.<br>- <b>Purpose of Changes</b>: To improve distance clarity.`
        );
    }
}


    // Rule 2: Distance reduction
    const distanceReductionCond = (t.kind === 'BAL' || t.type === 'R') && !distanceImprovementCond;
    if (distanceReductionCond) {
let lossDist = t.kind === 'BAL' ? 20 : Math.round(((1 / (t.step * 0.25)) * 3.281) * 10) / 10;
        parts.push(`- <b>Distance Vision Changes</b>: Distance clarity will be reduced; blurry beyond ${lossDist} feet.<br>- <b>Near Vision Changes</b>: Near vision comfort and clarity range will improve.<br>- <b>Purpose of Changes</b>: To improve near vision comfort and clarity range.`);
    }
    return parts.length ? parts.join('<br>') : '';
}





function getDCShiftText(fromDC, toDC) {
    if (!fromDC || !toDC) return '';
    const f = parseDC(fromDC);
    const t = parseDC(toDC);
    if (!f || !t || f.kind === 'UNKNOWN' || t.kind === 'UNKNOWN') return '';

    const stepDiff = (t.stepVal || t.diopter/0.25) - (f.stepVal || f.diopter/0.25);
    const diopterShift = stepDiff * 0.25;

    const line1 = describeDC(fromDC, '- <b>Current RX:</b>');
    let line2 = '';

   if (Math.abs(diopterShift) < 0.0001) {
    line2 = '- No changes in prescription.';
} else {
    const mag = Math.abs(diopterShift).toFixed(2);
    const direction = stepDiff < 0 ? '+' : '-';
    
    // First line: Change + swim effect
    line2 = `- <b>Swim Effect</b>: Change of <b>${direction}${mag}</b> will cause `;
    if (Math.abs(diopterShift) <= 0.25 + 0.001) 
        line2 += 'slight swim effect.';
    else if (Math.abs(diopterShift) <= 0.50 + 0.001) 
        line2 += 'moderate swim effect.';
    else 
        line2 += 'obvious swim effect.';

    // --- Second line: Tolerance Analysis ---
    try {
        const ageEl = document.getElementById('ageInput');
        const age = parseFloat(ageEl.value);

        if (!ageEl.value || isNaN(age) || age <= 0) {
            line2 += '<br>- <b>Adaptation Capability</b>: <b>*Key in age*</b> to generate analysis.';
        } else {
            const aaEl = document.getElementById('aaOutput');
            const aa = parseFloat(aaEl?.textContent) || 0;
            const toleranceText = changeTolerance(aa, age);
            const roundedMatch = toleranceText.match(/\(([\d.]+)\s*D\)/);
            const tolVal = roundedMatch ? parseFloat(roundedMatch[1]) : null;

            if (tolVal !== null && !isNaN(tolVal)) {
                const absShift = Math.abs(diopterShift);
                const EPS = 0.01;

                line2 += '<br>- <b>Adaptation Capability</b>: ';
                if (Math.abs(absShift - tolVal) <= EPS) {
                    line2 += 'Noticeable changes, adapt within 2 to 4 weeks.';
                } else if (absShift > tolVal + EPS) {
                    line2 += 'Challenging to adapt. <b>Reduce amount of changes</b>.';
                } else if (absShift > tolVal / 2 + EPS) {
                    line2 += 'Noticeable changes, adapt within 2 weeks.';
                } else {
                    line2 += 'Small changes, easily adapt almost instantly.';
                }
            }
        }
    } catch (e) { /* silent fail */ }

    // Dynamic / minification / magnification lines AFTER
    if (diopterShift > 0) line2 += '<br>- <b>Spatial Shift</b>: Environment will look further (floor and steps become farther).<br>- <b>Size Shift</b>: Objects will look smaller (reading prints become smaller).<br>- <b>Motion perception</b>: Feels like everything moves slower.';
    else if (diopterShift < 0) line2 += '<br>- <b>Spatial Shift</b>: Environment will look nearer (floor and steps become nearer).<br>- <b>Size Shift</b>: Objects will look bigger (reading prints become bigger).<br>- <b>Motion perception</b>: Feels like everything moves faster.';
}




       let line3 = '';
    if (t.kind === 'BAL') {
        line3 = '- <b>New Rx:</b> Well balance between distance and near vision.';
    } else {
        const newD = t.diopter || t.stepVal * 0.25;
        const mag = Math.abs(newD).toFixed(2);
        let codeLabel = '';
        if (t.kind === 'CODE') {
            codeLabel = `(<span style="color:${t.type==='R'?'red':'green'}; font-weight:normal;">${t.type}${t.step}</span>)`;
        }

        if (newD < 0) {
            line3 = `- <b>New RX</b>: Under by -${mag} ${codeLabel}. Good for seeing near.`;
        } else if (newD === 0) {
            line3 = `- <b>New RX</b>: At -${mag} ${codeLabel}.`;
        } else {
            line3 = `- <b>New RX</b>: Over by +${mag} ${codeLabel}.`;
        }

        // --- Add G rules here ---
        if (t.kind === 'CODE' && t.type === 'G') {
            if (t.step === 1) {
                line3 += ' Good for seeing far.';
            } else if (t.step >= 2) {
                line3 += ' Over-corrected prescription.';
            }
        }
    }
    const line4 = getDeeperAnalysis(fromDC, toDC, f, t);



  // Write separately
  document.getElementById("analysis-ou").innerHTML = [
    line1,
    line3,
    '<b>---------------------</b>',
    '<b>Changes</u></b>:',
    line4
  ].filter(Boolean).join('<br>');

  document.getElementById("analysis-ou-sph").innerHTML = [
    '<b><u>Sphere Changes Effect</u></b>:',
    line2
  ].filter(Boolean).join('<br>');

  // Only return the "Changes" part (no Expectations here anymore)
  return [
    line1,
    line3,
    '<br><b><u>Changes</u></b>:',
    line4
  ].filter(Boolean).join('<br>');
}



































































// --- OD/OS Analysis ---
function updateODOSAnalysis() {
    const oldDCR = document.getElementById('now-dc-od')?.textContent.trim() || '';
    const newDCR = document.getElementById('res-dc-od-2')?.textContent.trim() || '';
    const oldDCL = document.getElementById('now-dc-os')?.textContent.trim() || '';
    const newDCL = document.getElementById('res-dc-os-2')?.textContent.trim() || '';
    const diffRStr = (parseDC(newDCR)?.diopter || 0) - (parseDC(oldDCR)?.diopter || 0);
    const diffLStr = (parseDC(newDCL)?.diopter || 0) - (parseDC(oldDCL)?.diopter || 0);
    const output = `
<b><u>Right Vision Status</U></b><br>
${getDCShiftText(oldDCR,newDCR)}<br>
~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  <br>
<b><u>Left Vision Status</u></b><br>
${getDCShiftText(oldDCL,newDCL)}<br><br>
`;
    document.getElementById('analysis-od-os').innerHTML = output;
}

// --- OU Analysis ---
function updateOUAnalysis() {
    const oldDC = document.getElementById('dc-ou')?.textContent.trim() || '';
    const newDC = document.getElementById('res-dc-ou-re')?.textContent.trim() || '';
    const diff = (parseDC(newDC)?.diopter || 0) - (parseDC(oldDC)?.diopter || 0);
    const output = `
<b><u>Vision Status</u></b><br>
${getDCShiftText(oldDC,newDC)}<br>
`;
    document.getElementById('analysis-ou').innerHTML = output;
}

// --- Input Triggers and Mutation Observers ---
// OD/OS inputs
['dc-sph-od','c2_od','a2_od','dc-sph-os','c2_os','a2_os'].forEach(id=>{
    const el=document.getElementById(id);
    if(!el) return;
    el.addEventListener('input',updateODOSAnalysis);
    el.addEventListener('blur',()=>updateODOSAnalysis());
    el.addEventListener('keydown',e=>{if(e.key==='Enter'){e.preventDefault();updateODOSAnalysis();}});
});
// OD/OS mutation observers
['now-dc-od','res-dc-od-2','now-dc-os','res-dc-os-2'].forEach(id=>{
    const el=document.getElementById(id);
    if(!el) return;
    new MutationObserver(updateODOSAnalysis).observe(el,{childList:true,characterData:true,subtree:true});
});

// OU inputs
['dc-sph-od','c2_od','a2_od','dc-sph-os','c2_os','a2_os'].forEach(id=>{
    const el=document.getElementById(id);
    if(!el) return;
    el.addEventListener('input',updateOUAnalysis);
    el.addEventListener('blur',()=>updateOUAnalysis());
    el.addEventListener('keydown',e=>{if(e.key==='Enter'){e.preventDefault();updateOUAnalysis();}});
});
// OU mutation observers
['dc-ou','res-dc-ou-re'].forEach(id=>{
    const el=document.getElementById(id);
    if(!el) return;
    new MutationObserver(updateOUAnalysis).observe(el,{childList:true,characterData:true,subtree:true});
});

// --- Run once on load ---
window.addEventListener('DOMContentLoaded',()=>{
    updateODOSAnalysis();
    updateOUAnalysis();
});
</script>
<script>
// --- Binocular Merged Plan Add-On ---
function updateMergedPlan() {
  const oldDCR = document.getElementById('now-dc-od')?.textContent.trim() || '';
  const newDCR = document.getElementById('res-dc-od-2')?.textContent.trim() || '';
  const oldDCL = document.getElementById('now-dc-os')?.textContent.trim() || '';
  const newDCL = document.getElementById('res-dc-os-2')?.textContent.trim() || '';

  const fR = parseDC(oldDCR), tR = parseDC(newDCR);
  const fL = parseDC(oldDCL), tL = parseDC(newDCL);

  if (!fR || !tR || !fL || !tL) return;

  // --- Compute total change ---
  const diffR = (tR.diopter || 0) - (fR.diopter || 0);
  const diffL = (tL.diopter || 0) - (fL.diopter || 0);

  // --- SE Diff ---
  const seDiff = Math.abs(diffR - diffL);

  // Adaptation time rule
  let adaptText = "";
  if (seDiff <= 0.25) adaptText = "Likely mild binocular imbalance; adaptation 1–2 weeks.";
  else if (seDiff <= 0.50) adaptText = "Moderate imbalance; adaptation 2–4 weeks.";
  else adaptText = "High imbalance (>0.50); possible adaptation failure, especially in older patients.";

  // --- Distance blur merge ---
  function getBlurDist(parsed) {
    if (parsed.kind === "BAL") return 20;
    if (parsed.type === "R") return 20 / Math.pow(2, parsed.step - 1);
    if (parsed.type === "G" && parsed.step > 1) return 20; // over G1 = max distance
    return 20;
  }
  const blurR = getBlurDist(tR);
  const blurL = getBlurDist(tL);
  const minBlur = Math.min(blurR, blurL); // stricter
  const maxBlur = Math.max(blurR, blurL); // looser
  const blurText = (blurR !== blurL)
    ? `Distance vision: semi-blur beyond ${minBlur}ft, noticeable blur beyond ${maxBlur}ft.`
    : `Distance vision: blur beyond ${minBlur}ft.`;

  // --- Near vision comfort merge ---
  let nearText = "";
  const nearR = diffR < 0 ? "improve" : (diffR > 0 ? "reduce" : "same");
  const nearL = diffL < 0 ? "improve" : (diffL > 0 ? "reduce" : "same");
  if (nearR === "improve" && nearL === "improve") {
    nearText = "Near vision comfort improved.";
  } else if (nearR === "reduce" && nearL === "reduce") {
    nearText = "Near vision comfort reduced.";
  } else if ((nearR === "improve" && nearL === "reduce") ||
             (nearR === "reduce" && nearL === "improve")) {
    nearText = "Mixed binocular comfort — may cause headaches or double vision due to conflicting focal points.";
  } else {
    nearText = "Near vision comfort unchanged.";
  }

  // --- Output ---
  const mergedOutput = `
  <br><b><u>Binocular (Merged) Plan</u></b><br>
  - Total change: Right eye ${diffR.toFixed(2)}, Left eye ${diffL.toFixed(2)}<br>
  - SE Diff: ${seDiff.toFixed(2)}<br>
  - ${adaptText}<br>
  - ${blurText}<br>
  - ${nearText}<br><br>
  `;

  // Inject after OD/OS analysis
  const target = document.getElementById("analysis-od-os");
  if (target) {
    if (!document.getElementById("merged-plan")) {
      const div = document.createElement("div");
      div.id = "merged-plan";
      target.appendChild(div);
    }
    document.getElementById("merged-plan").innerHTML = mergedOutput;
  }
}

// Hook into existing updateODOSAnalysis
const oldUpdateODOS = updateODOSAnalysis;
updateODOSAnalysis = function() {
  oldUpdateODOS();
  updateMergedPlan();
};

// Run on load
window.addEventListener("DOMContentLoaded", updateMergedPlan);
</script>




</div>
</div>








<!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank ---><!--- thickness & minimum blank --->



<div class="section">
<span style="margin-left:20px; cursor:pointer; user-select:none;" id="toggle-lens-thickness">
  ▼ How to Check Lens Thickness
</span>

<div id="lens-thickness" style="display:none;">
<div class="row" style="gap:10px; padding:5px 15px 0px 15px;">
<i>1. Key in PD and RX.<br>2. Either choose to calculate by Frames Details or Longest Length.<br>3. If choose Longest length, then measure OC to the longest distance on the lens.<br>4. Calculator will then show what is the thickness at the position.</I>
</div>
  <input id="safety" type="number" style="width:30px; height:15px; margin-left:20px; margin-top:5px; margin-right:10px;" placeholder="2" value="2"><span>Safety</span>
</div>
<br><br>




  <div class="pane" style="padding:10px;">


<div style="display:flex; justify-content:center;">
  <b><span
    id="toggle-frame-lens-details"
    style="cursor:pointer; user-select:none; text-align:center;">
    ▼ Lens Thickness & Minimum Blank Size Calculator </span></b>
 </div>


<div id="frame-lens-details" style="display:none;">
<div style="height:10px;"></div>

<div class="pane">
    <table>
<tr class="calibrator">
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
</tr>
<tr class="white">
<td colspan="2" style="text-align:left;">&nbsp;&nbsp;&nbsp;Import RX :</td>
<td colspan="5" style="background-color: white"><div style="display:flex; gap:10px; margin-left:20px;">
  <button class="small-normal-btn" onclick="copyRx('current')">Current</button>
  <button class="small-normal-btn" onclick="copyRx('manual')">Manual</button>
  <button class="small-normal-btn" onclick="copyRx('ouRe')">Comfy</button> 
  <button class="small-normal-btn" style="display:none;" onclick="copyRx('odOs2')">Sharpest</button>
</div>
</td>
</tr>
<tr class="white">
<td colspan="2" style="text-align:left;">&nbsp;&nbsp;&nbsp;Quick Estimate :</td>
<td colspan="5" style="background-color: white"><div style="display:flex; gap:20px; margin-left:20px;">

    <button class="small-normal-btn" data-value="-3.00">−3.00</button>
    <button class="small-normal-btn" data-value="-2.00">−2.00</button>
    <button class="small-normal-btn" data-value="-1.00">−1.00</button>
    <button class="small-normal-btn" data-value="-0.50">−0.50</button></div>
<div style="display:flex; gap:20px; margin-left:20px; margin-top:5px;">
    <button class="small-normal-btn" data-value="+3.00">+3.00</button>
    <button class="small-normal-btn" data-value="+2.00">+2.00</button>
    <button class="small-normal-btn" data-value="+1.00">+1.00</button>
    <button class="small-normal-btn" data-value="+0.50">+0.50</button>
    <button id="resetSph" class="small-normal-btn">Reset 0.00</button>
</div>

</td>
</tr>

<td colspan="7" style="border:none;"></td>
</tr>


<tr class="white">
<td><b>R/L</b></td>
<td><b>PD</b></td>
<td><b>SPH</b></td>
<td><b>Cyl</b></td>
<td><b>Axis</b></td>
<td colspan="2"><B>Frame Size </b><i>(e.g 50-20)</i></td>

  </tr>

<td colspan="1">R</td>
<td>      <div><input id="monoPD_OD" type="number" placeholder="31"></div></td>
          <td><input type="text" id="sphOD" placeholder="+0.00"></td>
          <td><input type="text" id="cylOD" placeholder="+0.00"></td>
          <td><input type="number" id="axisOD" step="1" placeholder="180"></td>




    <td rowspan="2">
<div><input id="frameA" type="number" placeholder="52"></div>
<div style="height:5px;"></div>

Lens Width<br><i>(A Size)</i></td>

    <td rowspan="2">
<div> <input id="frameDBL" type="number" placeholder="17"></div>
<div style="height:5px;"></div>

Bridge Size<br><i>(DBL size)</i></td>

        </tr>
        <tr>
<td colspan="1">L</td>
<td>      <div><input id="monoPD_OS" type="number" placeholder="31"></div></td>
          <td><input type="text" id="sphOS" placeholder="+0.00"></td>
          <td><input type="text" id="cylOS" placeholder="+0.00"></td>
          <td><input type="number" id="axisOS" step="1" placeholder="180"></td>


            </tr>
<tr>
<td colspan="7" style="border:none;"></td>
</tr>

<tr class="white">
  <td colspan="7" style="background:white; text-align:center; vertical-align:middle;">
    <div style="display:flex; justify-content:center; align-items:center; flex-wrap:wrap; gap:10px;">

      <button id="btnCalc" class="normal-btn">
        Generate with<br>Customer & Frame Details      </button>

      <span>or</span>

      <button id="btnLength" class="normal-btn">
       <span style="color:red">(Quick calculation) with</span><br>with Longest Edge Length
      </button>

      <label for="lengthInput" style="display:none;">Length (mm)</label>
      <input type="number" id="lengthInput" value="30" step="1"
             style="border-radius: 30px; max-width:40px; text-align:center;">(mm)

    </div>
  </td>
</tr>


<tr>
<td colspan="7" style="border:none;">


</td>

</tr>
</table>
</div>
<div style="height:10px;"></div>



<div id="frame-lens-2-details"
     style="display:none; text-align:center; width:100%;">

  <div class="pane"
       style="display:flex; flex-direction:column; align-items:center; padding:10px 0 10px 0;">

    <div class="pane" id="mbsLine"
         style="width:90%; padding:10px 0 10px 0 ; text-align:center;">
      <i>~ Generating Minimum Blank Size.</i>
    </div>
<div style="height:5px;"></div>

    <div class="pane"id="thicknessBars"
         style="width:90%; padding:10px 0px 10px 0px ; text-align:center;">
      <i>~ Generating Lens Thickness.</i>
    </div>

    <div id="thickNote" class="tiny muted"
         style="margin-top:10px; text-align:center;">
</div>


  <div class="row"
       style="display:flex; flex-direction:column; align-items:center; gap:10px;">
    <div class="pane" style="width:85%; padding:10px; text-align:center; border:none">
<table style="border-collapse:collapse; margin:0; padding:0;">
  <tr>
    <td style="padding:3px 0; border:none;">
      <div style="display:flex; align-items:center; gap:8px; justify-content:flex-start;">
        <div style="width:30px; height:10px; background:var(--barOD);"></div>
        <span>= Custom (RX) lens thickness, usually thinner and better optics.</span>
      </div>
    </td>
  </tr>
  <tr>
    <td style="padding:3px 0; border:none;">
      <div style="display:flex; align-items:center; gap:8px; justify-content:flex-start;">
        <div style="width:30px; height:10px; background:darkblue;"></div>
        <span>= Diagram shows additional thickness of stock compared to RX.</span>
      </div>
    </td>
  </tr>
  <tr>
    <td style="padding:3px 0; border:none;">
      <div style="display:flex; align-items:center; gap:8px; justify-content:flex-start;">
        <div style="width:30px; height:10px; background:#a8733b;"></div>
        <span>= Frame thickness used for comparison</span>
      </div>
    </td>
  </tr>
</table>
  </div>

  </div>
</div>
<div style="height:5px;"></div>
</div>
</div>

</div>
</div>




<script>
/* =========================
   CONFIG - CHANG THICKNESS
========================= */
const CSV_URL = "https://raw.githubusercontent.com/kiaraoptometrypx/OL-selector/main/lens%20selector.csv";
const INDICES = [1.56, 1.60, 1.67, 1.74];
const CENTER_MINUS = 1.2;   // minus lens min center thickness
const EDGE_PLUS    = 1.2;   // plus lens min center thickness
const BASE_PX      = 50 * 0.6; // px per mm before scale radios

/* =========================
   CONFIG - CHANG THICKNESS
========================= */

function minusCorr(n){ if(n===1.56) return 1.05; if(n===1.60) return 1.025; return 1.0; }
function plusCorr(n){  if(n===1.56) return 1.3;  if(n===1.60) return 1.1;  if(n===1.67) return 1.05; if(n===1.74) return 1.0; return 1; }

/* =========================
   STATE
========================= */
let PRODUCTS = [];
let LAST_GEOM = null;   // {semiOD, semiOS, MBS}
let LAST_MODE = null;   // "frame" | "length"

/* =========================
   INPUT ROUNDING (text inputs keep + sign)
========================= */
function parseToNumber(str){
  if(!str) return 0;
  const v = parseFloat(String(str).replace(/\s+/g,'').replace('+',''));
  return isNaN(v) ? 0 : v;
}
function round025number(x){
  const s = x >= 0 ? 1 : -1;
  const a = Math.abs(x);
  const r = Math.round(a / 0.25) * 0.25;
  return s * r;
}
function formatSigned025(x){
  const v = round025number(x);
  return (v > 0 ? "+" : "") + v.toFixed(2);
}
function onSignedBlur(el){
  const v = parseToNumber(el.value);
  el.value = formatSigned025(v);
}
function roundAxis(el){
  let v = parseFloat(el.value);
  if(isNaN(v)) return;
  v = Math.round(v);
  if(v < 0) v += 180;
  if(v > 180) v = v % 180;
  el.value = v;
}
document.addEventListener("DOMContentLoaded", ()=>{
  ['sphOD','cylOD','sphOS','cylOS'].forEach(id=>{
    const el = document.getElementById(id);
    el.addEventListener('blur', ()=> onSignedBlur(el));
  });
  ['axisOD','axisOS'].forEach(id=>{
    const el = document.getElementById(id);
    el.addEventListener('blur', ()=> roundAxis(el));
  });
});

/* =========================
   OPTICS
========================= */
function effectivePower(S,C,axisDeg){
  const a = ((axisDeg % 180) + 180) % 180;
  const s = Math.sin(a * Math.PI / 180);
  return S + C * s * s; // horizontal meridian power
}
function minusThickness(S,C,A,n,y){
  const Fh = Math.abs(effectivePower(S,C,A));
  let t = CENTER_MINUS + (y*y*Fh)/(2000*(n-1));
  t *= minusCorr(n);
  return t;
}
function plusThickness(S,C,A,n,y){
  const Fh = effectivePower(S,C,A);
  let t = EDGE_PLUS + (y*y*Fh)/(2000*(n-1)); // center thickness from rim sag
  t = Math.max(t, 1.1	);
  t *= plusCorr(n);
  return t;
}






/* =========================
   BARS / THICKNESS
========================= */
function renderBars(rx, geom, mode, lenOverride){
  const container = document.getElementById("thicknessBars");
  container.innerHTML = `
<div class="pane" style="border:none">
<span><b>Lens Thickness Details</B></span><br><br>


  <div style="display:flex; flex-wrap:wrap; gap:5px; justify-content:center; align-items:center;">
    <span style="margin-left:20px;">Zoom in to see:</span>
    <button id="resetZoom" class="small-normal-btn">Reset</button>
    <input id="barScale" type="range" name="barScale"
      min="0.01" max="0.7" step="0.01" value="0.165"
      style="width:270px; accent-color:grey;">
  </div>

  <div style="display:flex; flex-wrap:wrap; gap:5px; justify-content:center;align-items:center;">
<span id="toggle-bar-frame" style="margin-left:20px;; cursor:pointer; user-select:none;">
 ▼ Show Frame Thickness
</span>
    <button id="btnMetal" class="small-normal-btn">2mm</button>
    <button id="btnPlastic" class="small-normal-btn">4mm</button>
    <input type="range" id="frameThickness"
      min="1" max="7" step="0.1" value="4"
      style="width:165px; accent-color:grey;"
      oninput="thicknessValue.textContent=this.value">
    <span id="thicknessValue" style="min-width:10px;">4</span>
  </div>
</div>





<!-- dedicated diagram container -->
<div id="thicknessDiagram" style="padding:0 10px 0 10px"></div>
  `;


  // --- controls ---
  const barScaleEl = container.querySelector("#barScale");
  const resetBtn   = container.querySelector("#resetZoom");
  const frameInput = container.querySelector("#frameThickness");
  const metalBtn   = container.querySelector("#btnMetal");
  const plasticBtn = container.querySelector("#btnPlastic");
  const diagram    = container.querySelector("#thicknessDiagram");

  let scale = parseFloat(barScaleEl.value) || 0.165;

  // zoom slider
  barScaleEl.addEventListener("input", () => {
    scale = parseFloat(barScaleEl.value) || 0.165;
    draw();
  });

  resetBtn.addEventListener("click", () => {
    const def = 0.165;
    barScaleEl.value = def;
    barScaleEl.dispatchEvent(new Event("input", { bubbles: true }));
  });

  // frame thickness slider
  frameInput.addEventListener("input", () => {
    document.getElementById("thicknessValue").textContent = frameInput.value;
    draw();
  });

  // quick-set buttons
  metalBtn.addEventListener("click", () => {
    frameInput.value = 2;
    frameInput.dispatchEvent(new Event("input", { bubbles:true }));
  });
  plasticBtn.addEventListener("click", () => {
    frameInput.value = 4;
    frameInput.dispatchEvent(new Event("input", { bubbles:true }));
  });

  function eyeLabel(isPlus){ return isPlus ? "" : ""; }

  // ========== DRAW FUNCTION ==========
// --- helper for stock lens %, separated for plus/minus CHANGE THICKNESS  ---
function stockFactor(n, isPlus) {
  if (isPlus) {
    // PLUS lenses (center thickness heavier, smaller scaling)
    if (n === 1.56) return 1.7;
    if (n === 1.60) return 1.3;
    if (n === 1.67) return 1.1;
    if (n === 1.74) return 1.05;
  } else {
    // MINUS lenses (edge thicker, bigger scaling)
    if (n === 1.56) return 1.1;
    if (n === 1.60) return 1.07;
    if (n === 1.67) return 1.05;
    if (n === 1.74) return 1.02;
  }
  return 1.0;
}



window.showStockBars = true;

  function draw() {
    diagram.innerHTML = ""; // ✅ clears old drawings only, keeps controls fixed
    const frameT = parseFloat(frameInput.value) || 0;

    // concise note logic (used in box descriptions)
    const odStatus = effectivePower(rx.OD.S, rx.OD.C, rx.OD.Ax) >= 0
      ? "CENTER"
      : "EDGE";
    const osStatus = effectivePower(rx.OS.S, rx.OS.C, rx.OS.Ax) >= 0
      ? "CENTER"
      : "EDGE";

    // --- outer flex wrapper ---
    const wrapper = document.createElement("div");
    wrapper.className = "bar-box-wrapper";
    wrapper.style.cssText = `
      display:flex;
      flex-wrap:wrap;
      gap:20px;
      justify-content:space-between;
      margin-top:15px;
    `;

    // --- RIGHT box ---
    const rightBox = document.createElement("div");
    rightBox.className = "bar-side-box";
    rightBox.style.cssText = `
      flex:1;
      min-width:50px;
      border:1px solid #ccc;
      border-radius:10px;
      padding:20px 20px;
    `;
    rightBox.innerHTML = `<div style="text-align:center;margin-bottom:6px;">
      <u><b>Right Lens thickest (mm) ${odStatus}</U></b></span>
    </div>`;

    // --- LEFT box ---
    const leftBox = document.createElement("div");
    leftBox.className = "bar-side-box";
    leftBox.style.cssText = `
      flex:1;
      min-width:50px;
      border:1px solid #ccc;
      border-radius:10px;
      padding:20px 20px;
    `;
    leftBox.innerHTML = `<div style="text-align:center; margin-bottom:6px;">
      <u><b>Left Lens thickest (mm) ${osStatus}</u></b></span>
    </div>`;

    // --- generate bar rows ---
    INDICES.forEach(n=>{
      const yOD = (mode==="length") ? lenOverride : geom.semiOD;
      const yOS = (mode==="length") ? lenOverride : geom.semiOS;

      const FhOD = effectivePower(rx.OD.S,rx.OD.C,rx.OD.Ax);
      const FhOS = effectivePower(rx.OS.S,rx.OS.C,rx.OS.Ax);
      const isPlusOD = FhOD >= 0;
      const isPlusOS = FhOS >= 0;

const reverseOD = isPlusOD ? "" : "reverse";
const reverseOS = isPlusOS ? "" : "reverse";

// --- stock lens availability per index ---
const stockOD = getStockAvailability(rx.OD.S, rx.OD.C, n);
const stockOS = getStockAvailability(rx.OS.S, rx.OS.C, n);

// --- check if stock diameter can cover required blank size ---
const requiredDia = LAST_GEOM?.MBS || 0;

const stockUsableOD = stockOD.available && stockOD.maxDia && requiredDia <= stockOD.maxDia;
const stockUsableOS = stockOS.available && stockOS.maxDia && requiredDia <= stockOS.maxDia;


      const tOD = isPlusOD ? plusThickness(rx.OD.S,rx.OD.C,rx.OD.Ax,n,yOD)
                           : minusThickness(rx.OD.S,rx.OD.C,rx.OD.Ax,n,yOD);
      const tOS = isPlusOS ? plusThickness(rx.OS.S,rx.OS.C,rx.OS.Ax,n,yOS)
                           : minusThickness(rx.OS.S,rx.OS.C,rx.OS.Ax,n,yOS);

      const px = BASE_PX * scale;
      const odLen = tOD * px, osLen = tOS * px, frameLen = frameT * px;

// flip the offset condition to match the new direction logic
const offsetOD = !isPlusOD ? `margin-left:${odLen + 3}px;` : "";
const offsetOS = !isPlusOS ? `margin-left:${osLen + 3}px;` : "";


      // Right bar
      const rightRow = document.createElement("div");
      rightRow.className = "bar-row";
      rightRow.style.margin = "6px 0";
rightRow.innerHTML = `
  <div class="bar-label"><br>${n.toFixed(2)}</div>
  <div class="bar-block">
    <div class="bar-text"><br>
      <b>
        RX ${tOD.toFixed(1)}
        <span>, Stock ${stockUsableOD ? (tOD * stockFactor(n, isPlusOD)).toFixed(1) : "-"}${eyeLabel(isPlusOD)}</span>

      </b>
    </div>
    <div style="display:flex; align-items:flex-start; gap:6px; position:relative;">
      <div class="your-eye">Your<br>Eye</span></div>
    <div class="eye-arrow">◑´→</div>
      <div class="bar-track ${reverseOD}" style="${offsetOD}">
        <div class="bar" style="background:var(--barOD);width:${odLen}px;"></div>
        <div class="bar-stock" style="
display:${(window.showStockBars && stockUsableOD) ? 'block' : 'none'};
          width:${(window.showStockBars && stockOD.available) ? odLen * stockFactor(n, isPlusOD) : 0}px;"></div>
        <div class="bar-frame" style="background:#a8733b;width:${frameLen}px;"></div>
      </div>
    </div>
  </div>
`;


      rightBox.appendChild(rightRow);

      // Left bar
      const leftRow = document.createElement("div");
      leftRow.className = "bar-row";
      leftRow.style.margin = "6px 0";
leftRow.innerHTML = `
  <div class="bar-label"><br>${n.toFixed(2)}</div>
  <div class="bar-block">
    <div class="bar-text"><br>
      <b>
        RX ${tOS.toFixed(1)}
<span>, Stock ${stockUsableOS ? (tOS * stockFactor(n, isPlusOS)).toFixed(1) : "-"}${eyeLabel(isPlusOS)}</span>
      </b>
    </div>
    <div style="display:flex; align-items:flex-start; gap:6px; position:relative;">
      <div class="your-eye">Your<br>Eye</span></div>
      <div class="eye-arrow">◑´→</div>
      <div class="bar-track ${reverseOS}" style="${offsetOS}">
        <div class="bar" style="background:var(--barOS);width:${osLen}px;"></div>
        <div class="bar-stock" style="
display:${(window.showStockBars && stockUsableOS) ? 'block' : 'none'};
          width:${(window.showStockBars && stockOS.available) ? osLen * stockFactor(n, isPlusOS) : 0}px;"></div>
        <div class="bar-frame" style="background:#a8733b;width:${frameLen}px;"></div>

      </div>
    </div>
  </div>
`;
;

      leftBox.appendChild(leftRow);
    });

    wrapper.appendChild(rightBox);
    wrapper.appendChild(leftBox);
    diagram.appendChild(wrapper);

// --- bar frame toggle inside renderBars ---
const frameToggleBtn = document.getElementById("toggle-bar-frame");
if (frameToggleBtn) {
  let visible = window.barFrameVisible ?? false; // remember last state, start hidden if undefined

  // hide/show all based on current state
  document.querySelectorAll(".bar-frame").forEach(el => {
    el.style.display = visible ? "block" : "none";
  });

  // update button label + color
  frameToggleBtn.textContent = visible ? "▼ Show Frame Thickness" : "▲ Show Frame Thickness";
  frameToggleBtn.style.color = visible ? "#a8733b" : "grey";
  frameToggleBtn.style.fontWeight = visible ? "bold" : "bold"; // bold when visible


  // remove old listeners before reattaching
  const newBtn = frameToggleBtn.cloneNode(true);
  frameToggleBtn.parentNode.replaceChild(newBtn, frameToggleBtn);

  newBtn.addEventListener("click", () => {
    visible = !visible;
    window.barFrameVisible = visible; // store for next redraw

    document.querySelectorAll(".bar-frame").forEach(el => {
      el.style.display = visible ? "block" : "none";
    });

    newBtn.textContent = visible ? "▼ Show Frame Thickness" : "▲ Show Frame Thickness";
    newBtn.style.color = visible ? "#a8733b" : "grey"; // brown when shown, grey when hidden
    newBtn.style.fontWeight = visible ? "bold" : "bold"; // bold when visible

  });

// --- stock lens toggle ---
const stockBtn = document.createElement("button");
stockBtn.id = "toggleStock";
stockBtn.className = "small-normal-btn";
stockBtn.textContent = "Show Stock Lens";
stockBtn.style.marginLeft = "50px";
frameToggleBtn.parentNode.appendChild(stockBtn);

stockBtn.addEventListener("click", () => {
  window.showStockBars = !window.showStockBars;
  stockBtn.textContent = window.showStockBars ? "Hide Stock Lens" : "Show Stock Lens";
  draw();
});

}


// --- add legend diagram ---
const legend = document.createElement("div");
legend.className = "legend";
legend.style.cssText = `
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  margin-top:5px;
`;

legend.innerHTML = `

`;
diagram.appendChild(legend);

  }

  draw();
}

/* =========================
   BUTTONS & FLOW
========================= */
document.addEventListener("DOMContentLoaded", ()=>{
  // Price cap adjusters
  document.getElementById("capPlus").onclick=()=>{const e=document.getElementById("priceCap");e.value=(parseFloat(e.value)||0)+100;};
  document.getElementById("capMinus").onclick=()=>{const e=document.getElementById("priceCap");e.value=Math.max(0,(parseFloat(e.value)||0)-100);};

  document.getElementById("cap500Plus").onclick=()=>{const e=document.getElementById("priceCap");e.value=(parseFloat(e.value)||0)+500;};
  document.getElementById("cap500Minus").onclick=()=>{const e=document.getElementById("priceCap");e.value=Math.max(0,(parseFloat(e.value)||0)-500);};

  document.getElementById("cap1000Plus").onclick=()=>{const e=document.getElementById("priceCap");e.value=(parseFloat(e.value)||0)+1000;};
  document.getElementById("cap1000Minus").onclick=()=>{const e=document.getElementById("priceCap");e.value=Math.max(0,(parseFloat(e.value)||0)-1000);};


  // Calculate by Frame — thickness only
  document.getElementById("btnCalc").onclick=()=>{
    const rx = parseRx();
    const A = getVal("frameA"), DBL = getVal("frameDBL");
    const pdOD = getVal("monoPD_OD"), pdOS = getVal("monoPD_OS");
  const safety = getVal("safety") || 0;            // use same safety as frame calc


    if(!A || !DBL || !pdOD || !pdOS){
      document.getElementById("mbsLine").innerHTML = "<span style='color:var(--warn);'>Please key in frame details and PD.</span>";
      LAST_GEOM = null; LAST_MODE = null;
      document.getElementById("thicknessBars").innerHTML = "";
      document.getElementById("thickNote").textContent = "";
      return;
    }

    LAST_GEOM = computeMBS(A,DBL,pdOD,pdOS,safety); // {semiOD, semiOS, MBS}
    LAST_MODE = "frame";
    document.getElementById("mbsLine").innerHTML = `<strong> - Minimum Blank Size:</strong> <strong> ${LAST_GEOM.MBS} mm to optimize wearing comfort.</strong>`;
    renderBars(rx, LAST_GEOM, "frame");
  };

 // Calculate by Length — thickness only
document.getElementById("btnLength").onclick = () => {
  const rx = parseRx();
  const len = getVal("lengthInput") || 30;         // interpreted as SEMI (per eye)
  const safety = getVal("safety") || 0;            // use same safety as frame calc

  LAST_GEOM = { 
    semiOD: len, 
    semiOS: len, 
    MBS: 2 * (len + safety)                        // add safety per eye, then double
  };
  LAST_MODE = "length";

  document.getElementById("mbsLine").innerHTML =
    `<strong> - Minimum Blank Size: ${2 * (len + safety)} mm to optimize wearing comfort.</strong>`;

  renderBars(rx, LAST_GEOM, "length", len);
};

  // Fetch Lenses — uses LAST_GEOM + filters
  document.getElementById("btnFetch").onclick=()=>{
    const rx = parseRx();
renderLensOptions(LAST_GEOM, rx);
  };
});

// Clear all filter checkboxes (does not auto-fetch)
document.getElementById("btnClearFilters").onclick = () => {
  document.querySelectorAll('.fl-appear, .fl-index, .fl-func, .fl-clarity, .fl-durability, .fl-viewing')
    .forEach(cb => cb.checked = false);
};


  // Optional: also clear the table message so it's obvious filters are cleared
  // const body = document.getElementById("resultsBody");
  // body.innerHTML = `<tr><td colspan="6" class="muted">Filters cleared. Search again.”.</td></tr>`;


function copyRx(source) {
  const map = {
current:{
      od:['s1_od','c1_od','a1_od'],
      os:['s1_os','c1_os','a1_os']
  },
manual: {
      od: ['manual-sph-ou-od','manual-cyl-ou-od','manual-axis-ou-od'],
      os: ['manual-sph-ou-os','manual-cyl-ou-os','manual-axis-ou-os']
    },
    ouRe: {
      od: ['res-sph-ou-re','res-cyl-ou-re','res-axis-ou-re'],
      os: ['res-sph-ou-le','res-cyl-ou-le','res-axis-ou-le']
    },
    odOs2: {
      od: ['res-sph-od-2','res-cyl-od-2','res-axis-od-2'],
      os: ['res-sph-os-2','res-cyl-os-2','res-axis-os-2']
    },
  };


  const targets = {
    od: ['sphOD','cylOD','axisOD'],
    os: ['sphOS','cylOS','axisOS']
  };

  const src = map[source];
  if (!src) return;

  ['od','os'].forEach(eye => {
    const [s,c,a] = src[eye].map(id => document.getElementById(id)?.value || document.getElementById(id)?.textContent || '');
    if (s !== undefined) document.getElementById(targets[eye][0]).value = s;
    if (c !== undefined) document.getElementById(targets[eye][1]).value = c;
    if (a !== undefined) document.getElementById(targets[eye][2]).value = a;
  });
}

/* =========================
   GEOMETRY
========================= */
function computeSemi(A, DBL, monoPD, safety){
  const framePDhalf = (A + DBL) / 2;
  const dec = Math.abs(framePDhalf - monoPD);
  return (A/2) + dec + safety;
}
function computeMBS(A, DBL, pdOD, pdOS, safety){
  const semiOD = computeSemi(A, DBL, pdOD, safety);
  const semiOS = computeSemi(A, DBL, pdOS, safety);
  return { semiOD, semiOS, MBS: 2 * Math.max(semiOD, semiOS) };
}

/* =========================
   HELPERS
========================= */
function getVal(id){ return parseFloat(document.getElementById(id)?.value) || 0; }
function parseRx(){
  const SOD = parseToNumber(document.getElementById("sphOD")?.value);
  const COD = parseToNumber(document.getElementById("cylOD")?.value);
  const SOS = parseToNumber(document.getElementById("sphOS")?.value);
  const COS = parseToNumber(document.getElementById("cylOS")?.value);
  return {
    OD:{ S:SOD, C:COD, Ax:getVal("axisOD") },
    OS:{ S:SOS, C:COS, Ax:getVal("axisOS") }
  };
}



</script>


























<!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR --->



<div class="section">
<span style="margin-left:20px; cursor:pointer; user-select:none;" id="toggle-build-your-lens">
  ▼ How to Build your Lens
</span>

<div id="build-your-lens" style="display:none;">
<div class="row" style="gap:10px; padding:5px 15px 0px 15px;">
<i>1. Thickness must be generated so only lenses with sufficient diameter will show.<br>2. Pick only 1 selection from each question. The less selection, the more refined the search.<br>3. Picking more than 1 selection from the same question may result in no lenses shown..</i><br><br>
</div>
</div>

 <div style="height:12px;"></div>


<div class="pane" style="align-items:center; padding:10px 10px 10px 10px;">

<div style="display:flex; justify-content:center;">
 <b><span   id="toggle-lens-selector"    style="cursor:pointer; user-select:none; text-align:center;">
    ▼ Build Your Lens
  </span></b>

</div>

<div id="lens-selector" style="display:none;">
 <div style="height:10px;"></div>





<div class="pane" style="padding:10px">
<button id="btnToggleSeg1" class="small-normal-btn" style="display:none; background-color:white;">Select All</button>
  <span id="toggle-lensMaterialCoating" style="cursor:pointer; user-select:none;">▼ 1. Lens Material & Coating: Choose your type of lens </span>




<div id="lensMaterialCoating" style="display:none;">



      <!-- Appearance -->
<div class="pane" style="padding:10px; margin:15px 0px 15px 0px">

       <button id="btnToggleDesc" class="small-normal-btn">▲ Desc</button><br>  <b>Question 1 of 4. Type of Lens :</b> Do you want changing colour lenses? Do you want sunglasses? Do you want premium sunglasses that cuts glare (polarize)? Or just normal clear material?

 <div style="height:10px;"></div>



<div style="display:flex; flex-direction:column; flex-wrap:wrap; gap:10px; align-items:flex-start;">


<label><input type="checkbox" class="fl-appear" value="Clear"> Clear – normal transparent lens.</label>
<label><input type="checkbox" class="fl-appear" value="Photochromic"> Photochromic – darkens under sunlight and then clears back indoors.</label>
<label><input type="checkbox" class="fl-appear" value="Tinted"> Tinted – fixed color sunglasses lens.</label>
<label><input type="checkbox" class="fl-appear" value="Polarized"> Polarized – Also sunglasses but cuts glare and colours are more vivid due to technology.</label>

</div>
      </div>

<!-- Index -->
<div class="pane" style="padding:10px; margin:15px 0px 15px 0px">
  
       <button id="btnToggleDesc" class="small-normal-btn">▲ Desc</button><br>  <b>Question 2 of 4. Lens thick or thinness :</b> Do you prefer lighter and thinner lenses (higher index)? Or do you want normal thickness lenses that are more affordable?
 <div style="height:10px;"></div>


<div style="display:flex; flex-direction:column; flex-wrap:wrap; gap:10px; align-items:flex-start;">


<label><input type="checkbox" class="fl-index" value="1.5"> Standard (1.5) – normal thickness and curvy lens for everyday use.</label>
<label><input type="checkbox" class="fl-index" value="Safety"> Safety – impact-resistant material for tougher protection.</label>
<label><input type="checkbox" class="fl-index" value="1.6"> Thin (1.6) – lighter, flatter lens that looks neater.</label>
<label><input type="checkbox" class="fl-index" value="1.67"> Extra Thin (1.67) - even slimmer, even lighter and even flatter for stable optics.</label>
<label><input type="checkbox" class="fl-index" value="1.74"> Ultra Thin (1.74) – utmost thinnest, lightest, flattest lens for most stable optics.</label>


        </div>
      </div>
<!-- Clarity & Coating -->
<div style="" class="pane" style="padding:10px; margin:15px 0px 15px 0px">
      <button id="btnToggleDesc" class="small-normal-btn">▲ Desc</button><br>  <b>Question 3 of 4. Clarity & Coating :</b> Choose how clear you want your vision and how easy the lens is to clean.
 <div style="height:10px;"></div>

  <div style="display:flex; flex-direction:column; flex-wrap:wrap; gap:10px; align-items:flex-start;">
    <label><input type="checkbox" class="fl-clarity" value="UV_400"> Basic UV 400 – common UV400 clear lens with simple coating. Blocks UV light.</label>
    <label><input type="checkbox" class="fl-clarity" value="UV_420_BL"> Premium Blue Light Filter – blocks UV light & blue light from digital gadget. Slight yellow tint due to its function.</label>
    <label><input type="checkbox" class="fl-clarity" value="high_clarity"> Luxury High Clarity & Filter – blocks UV light, blue light and increased clarity at night.</label>
  </div>
</div>


<!-- Durability Preference -->
<div class="pane" style="padding:10px; margin:15px 0px 15px 0px">

      <button id="btnToggleDesc" class="small-normal-btn">▲ Desc</button><br>  <b>Question 4 of 4. Durability Preference :</b> Decide between softer coatings with less reflection, or tougher ones that last longer.

 <div style="height:10px;"></div>

  <div style="display:flex; flex-direction:column; flex-wrap:wrap; gap:10px; align-items:flex-start;">

    <label><input type="checkbox" class="fl-durability" value="STANDARD"> Standard – Common standard that comes with 1 year warranty.</label>
    <label><input type="checkbox" class="fl-durability" value="HIGH"> Tougher – Coating is thicker so it's much stronger and more durable.</label>
  </div>
</div>

</div>

</div>


 <div style="height:5px;"></div>







<div class="pane" style="padding:10px">


  <span id="toggle-brand" style="cursor:pointer; user-select:none;">▼ 2. Brand Preference: Quality & Price Point</span>



<div id="brand" style="display:none;">


<!-- Brands -->
<div class="pane" style="padding:10px; margin:15px 0px 15px 0px">
      <button id="btnToggleDesc" class="small-normal-btn">▲ Desc</button><br>  <b>Question 1 of 1. Brand Quality & Price :</b> Choose your preference based on optical quality, price, and origin.

  <div style="height:10px;"></div>

  <div style="display:flex; flex-direction:column; flex-wrap:wrap; gap:10px; align-items:flex-start;">

<label><input type="checkbox" class="fl-brand" value="Seiko"> Seiko&nbsp;&nbsp; –
    Technology = ⭐️⭐️⭐️⭐️⭐️ · Price = 💰💰💰💰💰 -
    Made in Japan. Ultra premium customised aspheric technology; thinnest possible optics.</label>

<label><input type="checkbox" class="fl-brand" value="Rodenstock">Rodenstock&nbsp;&nbsp; –
    Technology = ⭐️⭐️⭐️⭐️⭐️ · Price = 💰💰💰💰💰 -
    German engineered. Pioneers of many optical technologies. Excellent visual experience.</label>

<label style="display:none"><input type="checkbox" class="fl-brand" value="Meyer"> Meyer&nbsp;&nbsp; –
    Technology = ⭐️⭐️⭐️⭐️ ⬤ · Price = 💰💰💰💰 ⬤ -
    German design. Premium price with modern technologies.</label>

<label><input type="checkbox" class="fl-brand" value="Pentax"> Pentax&nbsp;&nbsp; –
    Technology = ⭐️⭐️⭐️⭐️ ⬤ · Price = 💰💰💰💰 ⬤ -
    Japan optics lineage. Great coating durability.</label>

<label><input type="checkbox" class="fl-brand" value="Asahi">Asahi&nbsp;&nbsp; –
    Technology = ⭐️⭐️⭐️⭐️ ⬤ · Price = 💰💰💰 ⬤ ⬤ -
    Japan made. Pioneer in thin lenses.  Good choice to reduce lens thickness.</label>

<label><input type="checkbox" class="fl-brand" value="Opto-tech">Optotech&nbsp;&nbsp; –
    Technology = ⭐️⭐️⭐️⭐️ ⬤ · Price = 💰💰💰 ⬤ ⬤ -
    German design. Reasonable price with modern technologies.</label>

<label><input type="checkbox" class="fl-brand" value="Rayfilter">Rayfilter&nbsp;&nbsp; –
    Technology = ⭐️⭐️⭐️ ⬤ ⬤ · Price = 💰💰 ⬤ ⬤ ⬤ -
    Taiwan made. Simple everyday lenses with nothing fancy. Basic and cost-focused.</label>

<label><input type="checkbox" class="fl-brand" value="Advance Lens"> Local&nbsp;&nbsp; –
    Technology = ⭐️⭐️⭐️ ⬤ ⬤ · Price = 💰💰 ⬤ ⬤ ⬤ -
    Local lab with simple, durable lenses.</label>


  </div>
</div>

</div>
</div>











 <div style="height:5px;"></div>




<div class="pane" style="padding:10px">
  <span id="toggle-lenstype" style="cursor:pointer; user-select:none;">▼ 3. Build your Vision: Single Vision or Multifocal</span>
<div id="lenstype" style="display:none;">
 <div style="height:10px;"></div>


<div class="pane" style="padding:10px">


  <span id="toggle-single" style="cursor:pointer; user-select:none;">▼ A. Build Your Single Vision Lens</span>





<div id="singleFilters" style="display:none;">

<button id="btnToggleSeg2" class="small-normal-btn" style="display:none; margin-left:10px; border:none; background-color:white;">Select All</button>





<!-- Functional Lens -->
<div class="pane" style="padding:10px; margin:15px 0px 15px 0px">
      <button id="btnToggleDesc" class="small-normal-btn">▲ Desc</button><br>  <b>Question 1 of 2. Functional Lens :</b> High technological lenses understands that not every part should be the same prescription in order to maintain natural and relaxed vision. Dual zone single vision maximises functionality.

 <div style="height:10px;"></div>
  <div style="display:flex; flex-direction:column; flex-wrap:wrap; gap:10px; align-items:flex-start;">
<label><input type="checkbox" class="fl-func" value="Stock SV"> Stock Single Vision - ready made single vision lenses with standard optics. No further customization. </label>

    <label><input type="checkbox" class="fl-func" value="Custom SV"> Customized Single vision - made from scratch to your wearing needs and frame details. Can be tinted as well.</label>

    <label><input type="checkbox" class="fl-func" value="Anti-Fatigue"> Customized Dual zone vision - made from scratch and customized to your needs as well, and bottom part of lenses are further optimized for even better ergnomics.</label>
  </div>
</div>



<!-- Viewing Preference -->
<div class="pane" style="padding:10px; margin:15px 0px 15px 0px">
      <button id="btnToggleDesc" class="small-normal-btn">▲ Desc</button><br>  <b>Question 2 of 2. Viewing Preference :</b> Pick your preferred look and view balance – wider vision or slimmer design.
 <div style="height:10px;"></div>

  <div style="display:flex; flex-direction:column; flex-wrap:wrap; gap:10px; align-items:flex-start;">
    <label><input type="checkbox" class="fl-viewing" value="SPH"> Spherical – traditional curve, natural peripheral vision and may observe some warping effect at the side.</label>
    <label><input type="checkbox" class="fl-viewing" value="ATO"> Atoric – ideal for astigmatism prescription as it makes your vision less tilt, more stable and wider.</label>
    <label><input type="checkbox" class="fl-viewing" value="ASP"> Single Aspheric – flatter front, less magnification of the eye but may notice a little peripheral swim..</label>
    <label><input type="checkbox" class="fl-viewing" value="DAS"> Double Aspheric – maximum aspheric optics, thinnest and most realistic magnification but may notice a little peripheral swim..</label>
  </div>
</div>

  <!--  Personalisation Tier -->
<div class="pane" style="padding:10px; margin:15px 0px 15px 0px">
      <button id="btnToggleDesc" class="small-normal-btn">▲ Desc</button><br>  <b>Question 3 of 3. Personalization :</b> Optimize optics by personalization; fitting the lenses for the frame & wearer. Wearing position of the frame will affect the optical clarity; hence personalization will maximise the clarity at the position of wear.

 <div style="height:10px;"></div>
    <div style="display:flex; flex-direction:column; gap:10px; align-items:flex-start;">
      <label><input type="checkbox" class="fl-sv-pers" value="Full"> Full personalization - optics are optimized for your frame and how you wear the glasses.</label>
      <label><input type="checkbox" class="fl-sv-pers" value="Partial"> Partial personalization - optics are optimized for the frame only.</label>
      <label><input type="checkbox" class="sv-mf-pers" value="None"> No personalization - optics are made as default and may suit or not suit the frame.</label>
    </div>
  </div>





      </div>
</div>

 <div style="height:5px;"></div>




<div class="pane" style="padding:10px">


  <span id="toggle-multi" style="cursor:pointer; user-select:none;">▼ B. Build Your Multi-Focal Vision Lens</span> 



<!-- Multifocal Filters -->
<div id="multifocalFilters" style="display:none;">


<button id="btnToggleSeg3" class="small-normal-btn" style="display:none; margin-left:10px; border:none; background-color: white;">Select All</button>

  <!--  Multifocal Design -->
<div class="pane" style="padding:10px; margin:15px 0px 15px 0px">
      <button id="btnToggleDesc" class="small-normal-btn">▲ Desc</button><br>  <b>Question 1 of 4. Multifocal Design :</b> Choose the type of multifocal design you prefer. Every design has pros and cons. Wider clear zones and swim effect is related. If one is increased the other will follow suit. <div style="height:10px;"></div>

    <div style="display:flex; flex-direction:column; gap:10px; align-items:flex-start;">
      <label><input type="checkbox" class="fl-mf-view" value="Expert"> Expert - wider clear zones but swim is more obvious; requires prior experience with multifocal.</label>
      <label><input type="checkbox" class="fl-mf-view" value="Balance">Balanced - smaller clear zones but swim effect reduced; making it more comfortable to use.</label>
      <label><input type="checkbox" class="fl-mf-view" value="Entry"> Entry - softest and minimal swim but clear zones are narrow; good for first time adaptation.</label>
    </div>
  </div>


  <!--  Zone Enhancement -->
<div class="pane" style="padding:10px; margin:15px 0px 15px 0px">
      <button id="btnToggleDesc" class="small-normal-btn">▲ Desc</button><br>  <b>Question 2 of 4. Zone Enhancement :</b> Emphasize near or intermediate. Near vision range defined as less than 45cm; hand distance, phone, books etc. Intermediate vision range defined as  more than 45cm; PC, laptop, tablets etc.
 <div style="height:10px;"></div>

    <div style="display:flex; flex-direction:column; gap:10px; align-items:flex-start;">
      <label><input type="checkbox" class="fl-mf-zone" value="Near"> Near preferred – larger reading zone but less intermediate zone.</label>
      <label><input type="checkbox" class="fl-mf-zone" value="Intermediate"> Intermediate preferred - larger intermediate but smaller near.</label>
<label><input type="checkbox" class="fl-mf-zone" value="Equal"> Equal both - both are equally spread.</label>
    </div>
  </div>

  <!--  Design Technology Tier -->
<div class="pane" style="padding:10px; margin:15px 0px 15px 0px">
      <button id="btnToggleDesc" class="small-normal-btn">▲ Desc</button><br>  <b>Question 3 of 4. Design Tier :</b> Select the optical design sophistication. The more sophisticated the better the optics performance are but they come at a higher price. The recommended add and design is based on past customer's satisfactory level. Higher add has more complicated optics and hence sophisticated designs help. 
 <div style="height:10px;"></div>
    <div style="display:flex; flex-direction:column; gap:10px; align-items:flex-start;">
      <label><input type="checkbox" class="fl-mf-tier" value="Double"> Double Surface – maximum optics & comfort. Overall huge reduction in distortion. Suitable for all add power.</label>
      <label><input type="checkbox" class="fl-mf-tier" value="Single"> Single Surface – standard choice for balance between cost and performance. Suitable for add +2.00 and below. </label>
      <label><input type="checkbox" class="fl-mf-tier" value="Traditional"> Traditional – old fashioned optics performance, cost priority. Suitable for add +1.50 and below.</label>
    </div>
  </div>

  <!--  Personalisation Tier -->
<div class="pane" style="padding:10px; margin:15px 0px 15px 0px">
      <button id="btnToggleDesc" class="small-normal-btn">▲ Desc</button><br>  <b>Question 4 of 4. Personalization :</b> Optimize optics by personalization; fitting the lenses for the frame & wearer. Wearing position of the frame will affect the optical clarity; hence personalization will maximise the clarity at the position of wear.

 <div style="height:10px;"></div>
    <div style="display:flex; flex-direction:column; gap:10px; align-items:flex-start;">
      <label><input type="checkbox" class="fl-mf-pers" value="Full"> Full personalization - optics are optimized for your frame and how you wear the glasses.</label>
      <label><input type="checkbox" class="fl-mf-pers" value="Partial"> Partial personalization - optics are optimized for the frame only.</label>
      <label><input type="checkbox" class="fl-mf-pers" value="None"> No personalization - optics are made as default and may suit or not suit the frame.</label>
    </div>
  </div>




</div>

</div>


</div>
</div>







 <div style="height:15px;"></div>

     <!-- Price -->

      <div class="pane" style="display:none; padding:5 0 5px 0px;">
    <span style="display:none" id="status" class="tiny muted"></span>&nbsp;

        <b>Set Max Price (RM) :</b>
         <input id="priceCap" type="number" placeholder="1000"  style="width:70px; border:1px solid lightgrey; border-radius:30px; height:25px; padding:4px 6px; appearance:textfield; margin-left:10px">

<!-- Price Range -->
<div class="pane" style="padding:5px 0; margin-top:6px;">
  <b>Price Range (RM):</b>
  <input id="priceMin" type="number" placeholder="Min"
         style="width:80px; border:1px solid #ccc; border-radius:30px; height:25px; padding:4px 8px; margin-left:10px">
  <span>–</span>
  <input id="priceMax" type="number" placeholder="Max"
         style="width:80px; border:1px solid #ccc; border-radius:30px; height:25px; padding:4px 8px; margin-left:6px">
</div>


     
          <button style="margin-left:5px" id="cap1000Plus" class="small-normal-btn"><span style="color:green">+1000</span></button></span>
          <button style="margin-left:5px" id="cap500Plus" class="small-normal-btn"><span style="color:green">+500</span></button></span>
          <button style="margin-left:5px" id="capPlus" class="small-normal-btn"><span style="color:green">+100</span></button>

          <button style="margin-left:5px" id="cap1000Minus" class="small-normal-btn"><span style="color:red">–1000</span></button>
          <button style="margin-left:5px" id="cap500Minus" class="small-normal-btn"><span style="color:red">–500</span></button>
     <button style="margin-left:5px" id="capMinus" class="small-normal-btn"><span style="color:red">–100</span></button>

</div>

<!-- Price Range -->
<div class="pane" style="padding:5 0 5px 0px">
  <span style="margin-left:5px;"><b>Price Range (RM):</b></span>
  <input id="priceMin" type="number" placeholder="Min"
         style="width:80px; border:1px solid #ccc; border-radius:30px; height:25px; padding:4px 8px; margin-left:10px">
  <span>–</span>
  <input id="priceMax" type="number" placeholder="Max"
         style="width:80px; border:1px solid #ccc; border-radius:30px; height:25px; padding:4px 8px; margin-left:6px">
</div>




      <div class="pane" style="padding:10px; margin:5px 0px 5px 0px;">
  <b>Search :</b>
  <input id="lensSearch" type="text" placeholder="Type brand, model, design, index…" 
         style="width:280px; border:1px solid #ccc; border-radius:30px; height:28px; padding:4px 8px; margin-left:4px;">
  <span id="searchCount" class="tiny muted" style="display:none; margin-left:8px;"></span>
<span><button id="btnFetch" class="small-normal-btn">Search</button>
</span> 
  <button id="btnSort" class="small-normal-btn">Sort by Price</button>

</div>





  <div id="lensResults">
    <div class="muted">Generate thickness first to see lenses choices.</div>
  </div>
</div>

</div>











<!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR ---><!--- LENS SELECTOR --->






<script>
/* =========================
   CSV LOADING (DOM-safe)
========================= */
async function loadCSV(url){
  const res = await fetch(url, { cache:"no-store" });
  if(!res.ok) throw new Error("HTTP "+res.status);
  let text = await res.text();
  text = text.replace(/^\uFEFF/, '').trim(); // remove BOM

  const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
  if (lines.length < 2) return [];

  const headers = lines[0].split(',').map(h => h.replace(/^"|"$/g,'').trim());
  return lines.slice(1).map(line => {
    const cols = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
    const obj = {};
    headers.forEach((h,i)=> obj[h] = (cols[i]||"").replace(/^"|"$/g,'').trim());
    return obj;
  });
}

/* =========================
   INIT
========================= */
async function init(){
  const statusEl = document.getElementById("status");
  if(statusEl) statusEl.textContent = "Loading CSV…";
  try{
    PRODUCTS = await loadCSV(CSV_URL);
    if(statusEl) statusEl.textContent = "";
  }catch(e){
    if(statusEl) statusEl.textContent = "CSV load failed.";
    console.error("CSV load error:", e);
  }
}
document.addEventListener("DOMContentLoaded", init);

/* =========================
   UNIVERSAL HELPERS
========================= */
function toNumber(v){
  if (v == null) return null;
  const s = String(v).trim();
  if (!s || s === "—" || s === "-") return null;
  const cleaned = s
    .replace(/,/g, "")
    .replace(/[^\d.]/g, "")
    .replace(/(\..*)\./g, "$1");
  const n = parseFloat(cleaned);
  return Number.isFinite(n) ? n : null;
}
function debounce(fn, ms=200){
  let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); };
}
function parseTags(s){ return (s||"").toString().split(/[|;,]\s*/).filter(Boolean); }
function matchesMultiField(cell, wanted){
  if (!wanted || wanted.size===0) return true;
  const have = new Set(parseTags(cell));
  for (const w of wanted) if (have.has(w)) return true;
  return false;
}

let LENS_SEARCH_TERM = "";

function rowHaystack(row){
  return [
    row["PRODUCT_NAME"], row["BRAND"], row["LENS_DESIGN"], row["INDEX"],
    row["CLEAR_CHANGING_TINT"], row["VIEWING_STYLE"], row["EXTRA_NOTE"],
    row["MF_VIEWING"], row["MF_SWIM"], row["MF_ZONE"], row["MF_TIER"], row["MF_PERSONALIZATION"],
    getSVPersonalization(row)
  ].map(x => (x||"").toString().toLowerCase()).join(" | ");
}
function matchesSearch(row, query){
  const q = (query||"").trim().toLowerCase();
  if (!q) return true;
  const terms = q.split(/\s+/).filter(Boolean);
  const hay = rowHaystack(row);
  return terms.every(t => hay.includes(t));
}

function getAppearance(val=""){
  const s = String(val||"").toLowerCase();
  if(s.includes("polar")) return "Polarized";
  if(s.includes("tint"))  return "Tinted";
  if(s.includes("chang") || s.includes("photo")) return "Photochromic";
  return "Clear";
}
function getIndexGroup(val=""){
  const n = toNumber(val) ?? 0;
  if (Math.abs(n-1.59) < 0.01 || Math.abs(n-1.53) < 0.01) return "Safety";
  if (n>=1.49 && n<1.57)    return "1.5";
  if (n>=1.60 && n<1.65)    return "1.6";
  if (n>=1.65 && n<1.71)    return "1.67";
  if (n>=1.73 && n<1.76)    return "1.74";
  if (Math.abs(n-1.67)<0.02) return "1.67";
  if (Math.abs(n-1.60)<0.02) return "1.6";
  if (Math.abs(n-1.74)<0.02) return "1.74";
  return "1.5";
}
function getFunctionCat(val=""){
  const s = val.toLowerCase();
  if(s.includes("anti")) return "Anti-fatigue";
  if(s.includes("office") || s.includes("room")) return "Office";
  if(s.includes("pal") || s.includes("progress") || s.includes("multi")) return "Multifocal";
  return "SV";
}
function checkedValues(selector){
  return Array.from(document.querySelectorAll(selector))
    .filter(i=>i.checked)
    .map(i=>i.value);
}
function withinCap(price, cap){ if(!cap) return true; return Number(price) <= cap * 1.20; }

/* =========================
   PRICE HELPERS
========================= */
function getPriceByClarity(row, clarityChoice) {
  const colMap = {
    UV_400: "UV_400_PRICE_RM",
    UV_420_BL: "UV_420_BL_PRICE_RM",
    high_clarity: "HIGH_CLARITY_COATING_PRICE_RM"
  };
  const column = colMap[clarityChoice];
  if (!column) return null;
  return toNumber(row[column]);
}
function getAllPrices(row){
  return {
    UV_400:       getPriceByClarity(row, "UV_400"),
    UV_420_BL:    getPriceByClarity(row, "UV_420_BL"),
    high_clarity: getPriceByClarity(row, "high_clarity")
  };
}
function minPrice(prices){
  const vals = Object.values(prices).filter(v => v != null);
  return vals.length ? Math.min(...vals) : null;
}
function getPriceRange(){
  const mins = Array.from(document.querySelectorAll('#priceMin'))
    .map(el => toNumber(el.value))
    .filter(v => v != null);
  const maxs = Array.from(document.querySelectorAll('#priceMax'))
    .map(el => toNumber(el.value))
    .filter(v => v != null);

  let min = mins.length ? mins[mins.length - 1] : null;
  let max = maxs.length ? maxs[maxs.length - 1] : null;

  if (min != null && max != null && min > max){ const t=min; min=max; max=t; }
  return { min, max };
}

function withinPriceRange(price, min, max){
  if (price == null) return false;           // rows with no price for the checked coating are excluded
  if (min != null && price < min) return false;
  if (max != null && price > max) return false;
  return true;
}

/* =========================
   STOCK LENS AVAILABILITY
========================= */
function getStockAvailability(S, C, n) {
  if (S > 2.00) return { available: false, maxDia: null };
  if (C < -2.00) return { available: false, maxDia: null };

  if (n === 1.56) {
    if (S > +2.00 || S < -6.00) return { available: false, maxDia: null };
    if (S >= +0.25 && S <= +2.00) return { available: true, maxDia: 65 };
    return { available: true, maxDia: 70 };
  }
  if (n === 1.60) {
    if (S > 0 || S < -8.00) return { available: false, maxDia: null };
    return { available: true, maxDia: 70 };
  }
  if (n === 1.67) {
    if (S > 0 || S < -12.00) return { available: false, maxDia: null };
    return { available: true, maxDia: 65 };
  }
  if (n === 1.74) {
    if (S > -2.00 || S < -12.00) return { available: false, maxDia: null };
    return { available: true, maxDia: 65 };
  }
  return { available: false, maxDia: null };
}

/* =========================
   MF BADGES
<style>
.mf-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:8px 12px;margin-top:6px}
.mf-sec{display:flex;align-items:center;flex-wrap:wrap;gap:6px}
.mf-title{font-weight:600;font-size:12px;letter-spacing:.2px;white-space:nowrap;color:#444}
.mf-tag{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid #e5e7eb;background:#f6f7f9}
.mf-sec[data-k="view"] .mf-tag{background:#eef6ff;border-color:#d6e7ff}
.mf-sec[data-k="zone"] .mf-tag{background:#f1fff0;border-color:#d6f6d4}
.mf-sec[data-k="tier"] .mf-tag{background:#fff5f0;border-color:#ffd8c2}
.mf-sec[data-k="pers"] .mf-tag{background:#f9f5ff;border-color:#e6d7ff}
.mf-sec[data-k="swim"] .mf-tag{background:#fef9c3;border-color:#fde68a}
</style>


========================= */


// Grouped MF badges -> HTML block
function renderMFBadges(row){
  const rawView = String(row["MF_VIEWING"]||"");
  const rawZone = String(row["MF_ZONE"]||"");
  const rawTier = String(row["MF_TIER"]||"");
  const rawPers = String(row["MF_PERSONALIZATION"]||"");
  const rawSwim = String(row["MF_SWIM"]||"");

  const VIEW_TEXT = {
    Expert:  "Expert :  Widest clear zones but most swim effect",
    Balance: "Balanced : Moderate clear zones & swim effect",
    Entry:   "Entry : Minimal swim effect but narrow clear zones"
  };
  const ZONE_TEXT = {
    Near:         "Near - Larger near but smaller intermediate",
    Intermediate: "Intermediate - Larger intermediate but smaller near",
    Equal:        "Equal - Balance size intermediate & near"
  };
  const TIER_TEXT = {
    Double:       "Dual-surface -  Mostly costly but best possible optics quality and comfort.",
    Single:       "Single-surface - Less costly and retaining most of the technology.",
    Traditional:  "Conventional - Lowest production cost. Basic optics performance."
  };
  const PERS_TEXT = {
    Full:    "Fully custom - Made to maximise the spectacles size, shape and wearer's position",
    Partial: "Partial custom - Made to maximise the spectacles only",
    None:    "None - Made with nothing in consideration"
  };

  const uniq = a => Array.from(new Set(a.filter(Boolean)));

  // VIEW
  let view = [];
  if (/\bexpert\b/i.test(rawView)) view.push(VIEW_TEXT.Expert);
  if (/\bbalance(?:d)?\b/i.test(rawView)) view.push(VIEW_TEXT.Balance);
  if (/\bentry\b/i.test(rawView)) view.push(VIEW_TEXT.Entry);
  parseTags(rawView).forEach(t=>{
    const x=t.trim().toLowerCase();
    if (x.startsWith("expert"))  view.push(VIEW_TEXT.Expert);
    if (x.startsWith("balance")) view.push(VIEW_TEXT.Balance);
    if (x.startsWith("entry"))   view.push(VIEW_TEXT.Entry);
  });
  view = uniq(view);

  // ZONE
  let zone = [];
  if (/near/i.test(rawZone)) zone.push(ZONE_TEXT.Near);
  if (/intermediate/i.test(rawZone)) zone.push(ZONE_TEXT.Intermediate);
  if (/(^|[^a-z])equal([^a-z]|$)/i.test(rawZone)) zone.push(ZONE_TEXT.Equal);
  parseTags(rawZone).forEach(t=>{
    const x=t.trim().toLowerCase();
    if (x.startsWith("near")) zone.push(ZONE_TEXT.Near);
    if (x.startsWith("intermediate")) zone.push(ZONE_TEXT.Intermediate);
    if (x.startsWith("equal")) zone.push(ZONE_TEXT.Equal);
  });
  zone = uniq(zone);

  // TIER
  let tier = [];
  if (/double/i.test(rawTier)) tier.push(TIER_TEXT.Double);
  if (/single/i.test(rawTier)) tier.push(TIER_TEXT.Single);
  if (/tradition/i.test(rawTier)) tier.push(TIER_TEXT.Traditional);
  parseTags(rawTier).forEach(t=>{
    const x=t.trim().toLowerCase();
    if (x.startsWith("double")) tier.push(TIER_TEXT.Double);
    if (x.startsWith("single")) tier.push(TIER_TEXT.Single);
    if (x.startsWith("traditional")) tier.push(TIER_TEXT.Traditional);
  });
  tier = uniq(tier);

  // PERSONALIZATION
  let pers = [];
  if (/full/i.test(rawPers)) pers.push(PERS_TEXT.Full);
  if (/partial/i.test(rawPers)) pers.push(PERS_TEXT.Partial);
  if (/(^|[^a-z])none([^a-z]|$)/i.test(rawPers)) pers.push(PERS_TEXT.None);
  parseTags(rawPers).forEach(t=>{
    const x=t.trim().toLowerCase();
    if (x.startsWith("full")) pers.push(PERS_TEXT.Full);
    if (x.startsWith("partial")) pers.push(PERS_TEXT.Partial);
    if (x.startsWith("none")) pers.push(PERS_TEXT.None);
  });
  pers = uniq(pers);

  // SWIM (verbatim tags)
  const swim = uniq(parseTags(rawSwim).map(t=>t.trim()).filter(Boolean)).map(v=>`Swim: ${v}`);

  // Build HTML (only show sections that have tags)
const sec = (k,title,arr)=> arr.length
  ? `<div class="mf-sec" data-k="${k}">
       <span class="mf-title">${title}:</span>
       <div class="mf-lines">${arr.map(t=>`<span class="mf-tag">${t}</span>`).join("<br>")}</div>
     </div>`
  : "";


  return `
    <div class="mf-grid">
        <div style="height:10px;"></div>
----------
        <div style="height:10px;"></div>

      ${sec("tier","<b>Production Type - High production lenses makes vision as natural as possible:</b>",tier)}
      <div style="height:10px;"></div>
      ${sec("pers","<b>Customization Level - The more customized, the more natural your vision is:</b>",pers)}

      <div style="height:10px;"></div>
      ${sec("view","<b>Multifocal Design Choice - Adjust zones to your liking</b><br>(Choose Either One Below)",view)}
      <div style="height:10px;"></div>

      ${sec("zone","<b>Multifocal Near Choice - Adjust your Near Preference</b><br>(Choose Either One Below)",zone)}
    </div>
  `;
}


function getSVPersonalization(row){
  // prefer dedicated SV column; fall back to MF only for display/search if SV empty
  return String(
    row["SV_PERSONALIZATION"] ??
    row["SV_PERS"] ??
    row["SV_PERSONALISATION"] ??
    ""
  ).trim() || String(row["MF_PERSONALIZATION"] || "").trim();
}



// Grouped SV badges -> HTML block (with Personalization like MF)
function renderSVBadges(row){
  const rawDesign = String(row["LENS_DESIGN"]||"").toLowerCase();
  const rawView   = String(row["VIEWING_STYLE"]||"").toUpperCase();
  const rawPers   = getSVPersonalization(row); // 


  // EXACT TEXT from your questionnaire
  const FUNC_TEXT = {
    "Stock SV":     "Stock Single Vision - ready made single vision lenses with standard optics. No further customization.",
    "Custom SV":    "Customized Single vision - made from scratch to your wearing needs and frame details. Can be tinted as well.",
    "Anti-Fatigue": "Customized Dual zone vision - made from scratch and customized to your needs as well, and bottom part of lenses are further optimized for even better ergnomics."
  };
  const VIEW_TEXT = {
    "SPH": "Spherical – traditional curve, natural peripheral vision and may observe some warping effect at the side.",
    "ATO": "Atoric – ideal for astigmatism prescription as it makes your vision less tilt, more stable and wider.",
    "ASP": "Single Aspheric – flatter front, less magnification of the eye but may notice a little peripheral swim..",
    "DAS": "Double Aspheric – maximum aspheric optics, thinnest and most realistic magnification but may notice a little peripheral swim.."
  };
  const PERS_TEXT = {
    Full:    "Fully custom - Made to maximise the spectacles size, shape and wearer's position",
    Partial: "Partial custom - Made to maximise the spectacles only",
    None:    "None - Made with nothing in consideration"
  };

  const func = [];
  const isStockSV     = /\bstock\b/.test(rawDesign) && /\b(sv|single vision)\b/.test(rawDesign);
  const isAntiFatigue = /\banti[- ]?fatigue\b|\b(relax|boost|dual\s*zone)\b/.test(rawDesign);
  const isCustomSV    = !isStockSV && !isAntiFatigue &&
                        /\b(sv|single vision)\b/.test(rawDesign) &&
                        !/\b(pal|progress|multifocal|varifocal|bifocal|office|room)\b/.test(rawDesign);
  if (isStockSV)     func.push(FUNC_TEXT["Stock SV"]);
  if (isCustomSV)    func.push(FUNC_TEXT["Custom SV"]);
  if (isAntiFatigue) func.push(FUNC_TEXT["Anti-Fatigue"]);

  const view = [];
  const viewTokens = (rawView ? rawView.split(/[|;,]\s*/): [rawView]).filter(Boolean);
  viewTokens.forEach(t=>{
    const k = String(t).trim().toUpperCase();
    if (VIEW_TEXT[k]) view.push(VIEW_TEXT[k]);
  });

  // Personalization (reuse MF column/values)
  const pers = [];
  (rawPers.split(/[|;,]\s*/).filter(Boolean)).forEach(t=>{
    const k = t.trim();
    if (/^full/i.test(k))    pers.push(PERS_TEXT.Full);
    if (/^partial/i.test(k)) pers.push(PERS_TEXT.Partial);
    if (/^none/i.test(k))    pers.push(PERS_TEXT.None);
  });

  const uniq = a => Array.from(new Set(a.filter(Boolean)));
  const sec = (k,title,arr)=> arr.length
    ? `<div class="mf-sec" data-k="${k}">
         <span class="mf-title">${title}:</span>
         <div class="mf-lines">${uniq(arr).map(t=>`<span class="mf-tag">${t}</span>`).join("<br>")}</div>
       </div>`
    : "";

  return `
    <div class="mf-grid">
<div style="height:10px;"></div>
----------
        <div style="height:10px;"></div>

      ${sec("sv-view","<b>Lens Design Type - Complex lens design makes vision as natural as possible: </b>", view)}
      ${pers.length ? `<div style="height:10px;"></div>${sec("pers","<b>Customization Level - The more customized, the more natural your vision is:</b>", pers)}` : ""}
      <div style="height:10px;"></div>

      ${sec("sv-func","<b>Single Vision Function Type - The more advanced lenses will help us see clearer and more comfortable.</b>", func)}

    </div>
  `;
}










/* =========================
   MAIN: Render Lens Options
========================= */
let sortAsc = true;

function renderLensOptions(geom, rx) {
  const container = document.getElementById("lensResults");
  container.innerHTML = "";

  if (!geom) {
    container.innerHTML = `<div class="muted"><b><span style="color:red;">"Search Lenses" requires thickness generation first.</span></b></div>`;
    return;
  }

  // Collect selections
  const appearSet     = checkedValues(".fl-appear");
  const indexSet      = checkedValues(".fl-index");
  const funcSet       = checkedValues(".fl-func");
  const claritySet    = checkedValues(".fl-clarity");
  const durabilitySet = checkedValues(".fl-durability");
  const viewingSet    = checkedValues(".fl-viewing");
  const brandSet      = checkedValues(".fl-brand");
 const svPersSet = checkedValues(".fl-sv-pers");


  // MF groups
  const mfViewSet     = checkedValues(".fl-mf-view");
  const mfSwimSet     = checkedValues(".fl-mf-swim");
  const mfZoneSet     = checkedValues(".fl-mf-zone");
  const mfPersSet     = checkedValues(".fl-mf-pers");
  const mfTierSet     = checkedValues(".fl-mf-tier");

  const cap = toNumber(document.getElementById("priceCap")?.value) || 0;

  const { min: priceMin, max: priceMax } = getPriceRange();

  // Filter
  const matches = PRODUCTS.filter(row => {
    const rawDesign  = String(row["LENS_DESIGN"] || "");
    const designKey  = rawDesign.toLowerCase().replace(/\s+/g, " ").trim();
    const designType = getFunctionCat(rawDesign); // "SV", "Multifocal", "Office", "Anti-fatigue"

  // SV Personalization filter (uses SV_* column; never constrains MF rows)
  if (svPersSet.length) {
    if (designType !== "SV") return false;
    const svPers = getSVPersonalization(row);   // reads SV_PERSONALIZATION (or fallback)
    if (!matchesMultiField(svPers, new Set(svPersSet))) return false;
  }

    // Functional filter via LENS_DESIGN keywords
    if (funcSet.length) {
      const d = designKey;
      const ok = funcSet.some(f => {
        const s = String(f).toLowerCase();
        if (s === "stock sv")  return /\bstock\b/.test(d) && (/\bsv\b/.test(d) || /\bsingle vision\b/.test(d));
        if (s === "custom sv") return !/\bstock\b/.test(d) && (/\bsv\b/.test(d) || /\bsingle vision\b/.test(d)) &&
                                 !/\b(anti[- ]?fatigue|relax|boost|dual\s*zone|office|room|pal|progress|multifocal|varifocal|bifocal)\b/.test(d);
        if (s === "anti-fatigue") return /\banti[- ]?fatigue\b|\b(relax|boost|dual\s*zone)\b/.test(d);
        if (s === "office")       return /\b(office|room|computer|degressive)\b/.test(d);
        if (s === "multifocal")   return /\b(pal|progress|multifocal|varifocal|bifocal)\b/.test(d);
        return s === getFunctionCat(rawDesign).toLowerCase();
      });
      if (!ok) return false;
    }

    // PRICE FILTERS (no default):
    if (claritySet.length){
      // When a coating is selected: require that coating price exists and is within range (if any)
      const sel = claritySet[0];
      const p = getPriceByClarity(row, sel);
      if (!withinPriceRange(p, priceMin, priceMax)) return false;
    } else {
      // No coating selected: show product if it has ANY price.
      const all = getAllPrices(row);
      const available = Object.values(all).filter(v => v != null);
      if (available.length === 0) return false;                      // hide rows with no price at all
      if (priceMin != null || priceMax != null) {
        const anyInRange = available.some(v => withinPriceRange(v, priceMin, priceMax));
        if (!anyInRange) return false;
      }
    }

    // Shared filters (only apply if selected)
    const app  = getAppearance(row["CLEAR_CHANGING_TINT"] || "");
    const idx  = getIndexGroup(row["INDEX"] || "");
    const dur  = (row["DURABILITY_LEVEL"] || "").trim();
    const view = (row["VIEWING_STYLE"] || "").trim();

    if (appearSet.length     && !appearSet.includes(app))  return false;
    if (indexSet.length      && !indexSet.includes(idx))   return false;
    if (durabilitySet.length && !durabilitySet.includes(dur)) return false;
    if (viewingSet.length    && !viewingSet.includes(view)) return false;

    // Brand filter
    if (brandSet.length) {
      const prodBrandKey = String(row["BRAND"] || "").trim().toLowerCase().replace(/\s+/g, " ");
      const pickedBrandKeys = brandSet.map(v => String(v).trim().toLowerCase().replace(/\s+/g, " "));
      if (!pickedBrandKeys.includes(prodBrandKey)) return false;
    }

    // Stock SV guard (only for "stock sv")
    if (designType === "SV" && /\bstock sv\b/.test(designKey)) {
      const n = toNumber(row["INDEX"]);
      const diaNum = toNumber(row["DIA"]);
      const mbs = geom?.MBS || 0;
      if (!Number.isFinite(n) || !Number.isFinite(diaNum) || !(mbs > 0)) return false;
      const odOk = getStockAvailability(rx.OD.S, rx.OD.C, n).available;
      const osOk = getStockAvailability(rx.OS.S, rx.OS.C, n).available;
      if (!(odOk && osOk)) return false;
      if (diaNum < mbs) return false;
    }

    // MF sub-filters
    const mfViewSet  = checkedValues(".fl-mf-view");
    const mfSwimSet  = checkedValues(".fl-mf-swim");
    const mfZoneSet  = checkedValues(".fl-mf-zone");
    const mfTierSet  = checkedValues(".fl-mf-tier");
    const mfPersSet  = checkedValues(".fl-mf-pers");
    const anyMFWanted = (mfViewSet.length || mfSwimSet.length || mfZoneSet.length || mfTierSet.length || mfPersSet.length);
    if (anyMFWanted) {
      if (designType !== "Multifocal") return false;
      const mfView = (row["MF_VIEWING"]||"").trim();
      const mfSwim = (row["MF_SWIM"]||"").trim();
      const mfZone = (row["MF_ZONE"]||"").trim();
      const mfTier = (row["MF_TIER"]||"").trim();
      const mfPers = (row["MF_PERSONALIZATION"]||"").trim();
      if (mfViewSet.length && !matchesMultiField(mfView, new Set(mfViewSet))) return false;
      if (mfSwimSet.length && !matchesMultiField(mfSwim, new Set(mfSwimSet))) return false;
      if (mfZoneSet.length && !matchesMultiField(mfZone, new Set(mfZoneSet))) return false;
      if (mfTierSet.length && !matchesMultiField(mfTier, new Set(mfTierSet))) return false;
      if (mfPersSet.length && !matchesMultiField(mfPers, new Set(mfPersSet))) return false;
    }

    // Global search
    return matchesSearch(row, LENS_SEARCH_TERM);
  });

  // SORT — by selected coating price; otherwise by cheapest available coating
  const claritySetNow = checkedValues(".fl-clarity");
  matches.sort((a, b) => {
    let pa, pb;
    if (claritySetNow.length){
      const k = claritySetNow[0];
      pa = getPriceByClarity(a, k);
      pb = getPriceByClarity(b, k);
    } else {
      pa = minPrice(getAllPrices(a));
      pb = minPrice(getAllPrices(b));
    }
    if (pa == null && pb == null) return 0;
    if (pa == null) return 1;
    if (pb == null) return -1;
    return sortAsc ? (pa - pb) : (pb - pa);
  });

  if (!matches.length) {
    container.innerHTML = `<div class="muted">No lens options match your filters or price cap.</div>`;
    return;
  }

  if (searchCount) {
    searchCount.textContent = `${matches.length} found`;
  }

  // BRAND helpers
  const BRAND_ALIASES = {
    "asahi": "Asahi",
    "asahi lens": "Asahi",
    "asahi optical": "Asahi",
    "rayfilter": "Rayfilter",
    "rodenstock": "Rodenstock",
    "pentax": "Pentax",
    "opto-tech": "Opto-tech",
    "opto tech": "Opto-tech",
    "optotech": "Opto-tech",
    "seiko": "Seiko",
    "advance lens": "Advance Lens",
    "advance": "Advance Lens"
  };
  const BRAND_RATINGS = {
"Asahi":        { optical: "(Premium ⭐️⭐️⭐️⭐️⬤)", price: "(Mid 💰💰💰⬤⬤)" },
  "Rayfilter":    { optical: "(Good ⭐️⭐️⭐️⬤⬤)",    price: "(Budget 💰💰⬤⬤⬤)" },
  "Rodenstock":   { optical: "(Luxury ⭐️⭐️⭐️⭐️⭐️)",  price: "(Luxury 💰💰💰💰💰)" },
  "Pentax":       { optical: "(Premium ⭐️⭐️⭐️⭐️⬤)", price: "(Premium 💰💰💰💰⬤)" },
  "Opto-tech":    { optical: "(Premium ⭐️⭐️⭐️⭐️⬤)", price: "(Mid 💰💰💰⬤⬤)" },
  "Seiko":        { optical: "(Luxury ⭐️⭐️⭐️⭐️⭐️)",  price: "(Luxury 💰💰💰💰💰)" },
  "Advance Lens": { optical: "(Good ⭐️⭐️⭐️⬤⬤)",    price: "(Budget 💰💰⬤⬤⬤)" }
  };
  function getBrandGroup(val = "") {
    const s = String(val).toLowerCase()
      .replace(/\./g, "")
      .replace(/\b(lens|optical|co|co ltd|ltd|gmbh|inc|corp|corporation)\b/g, "")
      .replace(/[^a-z0-9]+/g, " ")
      .trim();
    for (const key in BRAND_ALIASES) {
      if (s.includes(key)) return BRAND_ALIASES[key];
    }
    return s ? s.replace(/\b\w/g, m => m.toUpperCase()) : "";
  }

  const clarityMap = {
    "UV_400": "Standard UV400",
    "UV_420_BL": "Blue Light Blocker UV420",
    "high_clarity": "Premium Ultra High Clarity"
  };

  // Render (top 25)
  matches.slice(0, 25).forEach(row => {
    const idx = (row["INDEX"] || "—").trim();
    const app   = getAppearance(row["CLEAR_CHANGING_TINT"] || "");
    const design = row["LENS_DESIGN"] || "—";
    const dia   = row["DIA"] || "—";
    const rawNote = (row["EXTRA_NOTE"] ?? "").toString().trim();
    const note = (rawNote && rawNote !== "-") ? rawNote : "";
    const brand = row["BRAND"] || "";
    const brandKey = getBrandGroup(brand);
    const rating = BRAND_RATINGS[brandKey];
    const brandMeta = rating
      ? `<span class="tag meta">Quality: ${rating.optical} · Price: ${rating.price}</span>`
      : "";



    const tintOpt = (row["TINT_OPTION"] || "").trim();
    const tintCharge = toNumber(row["TINT_SURCHARGE"]) ?? 0;
    let tintNote = "";
    switch (tintOpt) {
      case "Yes":     tintNote = `<span>Can be tinted (+RM${tintCharge.toFixed(0)} surcharge)</span>`; break;
      case "Already": tintNote = `<span>Already tinted</span>`; break;
      case "No":      tintNote = `<span>Cannot be tinted</span>`; break;
      default:        tintNote = "";
    }

    // Build coating display (NO DEFAULT). If none selected, show each available separately.
    const selectedClarity = checkedValues(".fl-clarity")[0] || null;
    let coatingHTML = "";
    const labelMap = {
      UV_400: "UV Filter only",
      UV_420_BL: "Blue Light Filter",
      high_clarity: "High Clarity & Filter"
    };
    const colorMap = { UV_400: "", UV_420_BL: "color:#1e66ff", high_clarity: "color:#7c3aed" };

    if (selectedClarity){
      const p = getPriceByClarity(row, selectedClarity);
      if (p != null){
        const style = colorMap[selectedClarity] ? ` style="${colorMap[selectedClarity]}"` : "";
        coatingHTML = `<div class="lens-prices"><b>Price | </b> <b><span class="tag price"${style}>${labelMap[selectedClarity]}: RM ${p}</span></b></div>`;
      } else {
        coatingHTML = ""; // shouldn't appear due to filter
      }
    } else {
      const all = getAllPrices(row);
      const order = ["UV_400", "UV_420_BL", "high_clarity"];
      const parts = [];
      order.forEach(k=>{
        const v = all[k];
        if (v != null){
          const style = colorMap[k] ? ` style="${colorMap[k]}"` : "";
          parts.push(`<span class="tag price"${style}>${labelMap[k]}: RM ${v}</span>`);
        }
      });
      coatingHTML = parts.length ? `<div class="lens-prices"><b>Price&nbsp; |</b><b>${parts.join('|')}</b></div>` : "";
    }

    const card = document.createElement("div");
    card.className = "lens-card";
    card.innerHTML = `
      <div class="lens-header">

<div><b>Lens Name & Brand:</b> ${row["PRODUCT_NAME"] || "(Unnamed Lens)"} <b>by</b> ${brandKey || (row["BRAND"] || "")} </div>

   <div style="height:10px"></div>

        <div><b>Lens Type:</b> ${dia} mm ${idx} ${design} ${app} ${note}   </div>

   <div style="height:10px"></div>
     <div>${coatingHTML} </div>
        <div style="height:10px;"></div>
  <span class="toggle-card-details" style="cursor:pointer; user-select:none;">▼ More Details </span> 
<div class="card-details" style="display:none;">

        <div style="height:10px;"></div>

        <div><b>Lens Tintability Option:</b> ${tintNote}  </div>

   <div style="height:10px"></div>

<div><b>Lens Rating & Price:</b> ${brandMeta}</div>

        <div style="height:10px;"></div>

<div>${
  getFunctionCat(row["LENS_DESIGN"]||"") === "Multifocal"
    ? renderMFBadges(row)
    : renderSVBadges(row)   // <-- shows only Functional Lens + Viewing Preference for SV
}</div>

      </div>
</div>
    `;
    container.appendChild(card);
  });

if (!container.dataset.cardToggleBound) {
  container.addEventListener("click", (e) => {
    const btn = e.target.closest(".toggle-card-details");
    if (!btn) return;
    const card = btn.closest(".lens-card");
    const section = card?.querySelector(".card-details");
    if (!section) return;

    const hidden = section.style.display === "none" || section.style.display === "";
    section.style.display = hidden ? "block" : "none";
    btn.textContent = (hidden ? "▲" : "▼") + " More Details";
  });
  container.dataset.cardToggleBound = "1";
}

}

/* =========================
   BUTTONS / WIRING
========================= */
document.getElementById("btnFetch").onclick = () => {
  const rx = parseRx();
  renderLensOptions(LAST_GEOM, rx);
};

const btnSort = document.getElementById("btnSort");
if (btnSort) {
  btnSort.textContent = "Sort by Price ↑";
  btnSort.onclick = () => {
    sortAsc = !sortAsc;
    btnSort.textContent = sortAsc ? "Sort by Price ↑" : "Sort by Price ↓";
    const rx = parseRx();
    renderLensOptions(LAST_GEOM, rx);
  };
}

const searchInput = document.getElementById("lensSearch");
const searchCount = document.getElementById("searchCount");
if (searchInput){
  searchInput.addEventListener("input", debounce(() => {
    LENS_SEARCH_TERM = searchInput.value || "";
    const rx = parseRx();
    renderLensOptions(LAST_GEOM, rx);
  }, 200));
}

// Price inputs: re-render on change
document.querySelectorAll('#priceMin, #priceMax').forEach(input => {
  input.addEventListener('input', debounce(() => {
    const rx = parseRx();
    renderLensOptions(LAST_GEOM, rx);
  }, 200));
});


/* =========================
   UNIVERSAL FILTER ACTIONS
========================= */
function updateStatus(msg) {
  document.querySelectorAll(".status, #status").forEach(st => (st.textContent = msg));
}
function setFilters(checked, selector = '.fl-appear, .fl-index, .fl-func, .fl-clarity, .fl-durability, .fl-viewing, .fl-brand') {
  document.querySelectorAll(selector).forEach(cb => (cb.checked = checked));
}
document.querySelectorAll(".btnToggleFilters").forEach(btn =>
  btn.addEventListener("click", () => {
    const allFilters = document.querySelectorAll("#singleFilters, #multifocalFilters");
    const hide = btn.textContent.includes("Hide");
    allFilters.forEach(f => (f.style.display = hide ? "none" : "block"));
    document.querySelectorAll(".btnToggleFilters").forEach(b => {
      b.textContent = hide ? "Show Filters ▼" : "Hide Filters ▲";
    });
  })
);
document.getElementById("btnSelectAllSV")?.addEventListener("click", () => {
  setFilters(true, "#singleFilters input[type='checkbox']");
});
document.getElementById("btnClearSV")?.addEventListener("click", () => {
  setFilters(false, "#singleFilters input[type='checkbox']");
  updateStatus("Single vision filters cleared.");
});
document.getElementById("btnSelectAllMF")?.addEventListener("click", () => {
  setFilters(true, "#multifocalFilters input[type='checkbox']");
  updateStatus("All multifocal filters selected.");
});
document.getElementById("btnClearMF")?.addEventListener("click", () => {
  setFilters(false, "#multifocalFilters input[type='checkbox']");
  updateStatus("Multifocal filters cleared.");
});
</script>







































<script>
// helper: set all checkboxes within a root selector
function setGroupChecked(rootSel, checked) {
  document.querySelectorAll(`${rootSel} input[type='checkbox']`)
    .forEach(cb => cb.checked = checked);
}

// make a toggle button that alternates Select All <-> Clear All
function initToggleButton(btnId, rootSel) {
  const btn = document.getElementById(btnId);
  if (!btn) return;

  // no memory except flip-flop on the button itself
  btn.dataset.mode = 'select';           // next click action
  btn.textContent = 'Select All';

  btn.addEventListener('click', () => {
    const mode = btn.dataset.mode || 'select';

    if (mode === 'select') {
      setGroupChecked(rootSel, true);    // check everything in the segment
      btn.dataset.mode = 'clear';
      btn.textContent = 'Clear All';
    } else {
      setGroupChecked(rootSel, false);   // clear everything in the segment
      btn.dataset.mode = 'select';
      btn.textContent = 'Select All';
    }
  });
}

// init 3 segment toggles
initToggleButton('btnToggleSeg1', '#lensMaterialCoating');
initToggleButton('btnToggleSeg2', '#singleFilters');
initToggleButton('btnToggleSeg3', '#multifocalFilters');
</script>






















<script>
// ===============================
// 0) Ensure one toggle button exists (optional helper)
// ===============================
document.addEventListener("DOMContentLoaded", () => {
  if (!document.querySelector('[id="btnToggleDesc"]')) {
    const host =
      document.querySelector("#lensMaterialCoating")?.parentElement ||
      document.querySelector("#lens-selector") ||
      document.body;
    const row = document.createElement("div");
    row.style.margin = "6px 0";
    const btn = document.createElement("button");
    btn.id = "btnToggleDesc";
    btn.className = "small-normal-btn";
    btn.type = "button";
    btn.textContent = "▲ Desc";
    row.appendChild(btn);
    host.insertBefore(row, host.firstChild);
  }

  // Run setup
  wrapPaneDescriptions();
  wrapLabelDescriptions("#lensMaterialCoating");
  wrapLabelDescriptions("#singleFilters");
  wrapLabelDescriptions("#multifocalFilters");
  setDescriptionsHidden(false);

  // Wire ALL buttons with the same id (works even if duplicated)
  document.querySelectorAll('[id="btnToggleDesc"]').forEach(btn => {
    btn.addEventListener("click", () => setDescriptionsHidden(!descHidden));
  });
});

// ===============================
// 1) Wrap paragraph blurbs under <b> so they can be hidden
// ===============================
function wrapPaneDescriptions() {
  const panes = document.querySelectorAll(
    "#lensMaterialCoating .pane, #singleFilters .pane, #multifocalFilters .pane"
  );
  panes.forEach(pane => {
    const title = pane.querySelector("b");
    if (!title) return;

    // Wrap everything after <b> up to the first options DIV
    let n = title.nextSibling, wrap = null;
    while (n) {
      const next = n.nextSibling;
      if (n.nodeType === 1 && n.tagName === "DIV") break; // options start
      if (!wrap) {
        wrap = document.createElement("span");
        wrap.className = "descWrap";
        pane.insertBefore(wrap, n);
      }
      wrap.appendChild(n);
      n = next;
    }
  });
}

// ===============================
// 2) LABELS: keep text BEFORE dash; hide dash + after
// ===============================
function wrapLabelDescriptions(rootSel) {
  document.querySelectorAll(`${rootSel} label`).forEach(label => {
    const input = label.querySelector("input[type='checkbox'],input[type='radio']");
    if (!input) return;
    if (label.querySelector(".descPart")) return; // already processed

    // Find the first TEXT NODE after the input that contains any dash
    let node = input.nextSibling;
    while (node && !(node.nodeType === 3 && /-|–|—/.test(node.textContent))) {
      node = node.nextSibling;
    }
    if (!node) return;

    const s = node.textContent;           // preserve spacing exactly
    const dashIndex = s.search(/-|–|—/);  // first dash of any type
    if (dashIndex === -1) return;

    const before = s.slice(0, dashIndex); // stays visible
    const after  = s.slice(dashIndex);    // dash + after (toggle)

    const frag = document.createDocumentFragment();
    frag.appendChild(document.createTextNode(before));

    const descSpan = document.createElement("span");
    descSpan.className = "descPart";
    descSpan.textContent = after;

    frag.appendChild(descSpan);
    label.replaceChild(frag, node);
  });
}

// ===============================
// 3) Toggle visibility (updates ALL buttons)
// ===============================
let descHidden = false;
function setDescriptionsHidden(hide) {
  descHidden = !!hide;

  // Hide pane blurbs and the dash+after in labels
  document.querySelectorAll(".descWrap, .descPart").forEach(el => {
    el.style.display = descHidden ? "none" : "";
  });

  // Update ALL copies of the button with this id
  document.querySelectorAll('[id="btnToggleDesc"]').forEach(btn => {
    btn.textContent = descHidden ? "▼ Desc" : "▲ Desc";
    // preserve your inline look in case a copy misses it
    btn.style.border = "none";
    btn.style.backgroundColor = "white";
  });
}
</script>



































<script>
// --- universal toggle handler ---
function makeToggle(buttonId, sectionId) {
  const btn = document.getElementById(buttonId);
  const section = document.getElementById(sectionId);

  if (!btn || !section) return;

  btn.addEventListener("click", () => {
    const hidden = section.style.display === "none" || section.style.display === "";
    section.style.display = hidden ? "block" : "none";
    btn.textContent = hidden
      ? `▲ ${btn.textContent.replace("▼", "").replace("▲", "").trim()}`
      : `▼ ${btn.textContent.replace("▼", "").replace("▲", "").trim()}`;
  });
}


makeToggle("toggle-manual", "exam-manual");
makeToggle("toggle-comfy", "exam-comfy");
makeToggle("toggle-sharpest", "exam-sharpest");
makeToggle("toggle-lens-thickness", "lens-thickness");
makeToggle("toggle-settings-block", "settings-block");
makeToggle("toggle-frame-lens-details","frame-lens-details");
makeToggle("toggle-frame-lens-details","frame-lens-2-details");
makeToggle("toggle-customer-details","customer-details");
makeToggle("toggle-build-your-lens","build-your-lens");
makeToggle("toggle-lens-selector","lens-selector");
makeToggle("toggle-single", "singleFilters");
makeToggle("toggle-multi", "multifocalFilters");
makeToggle("toggle-lensMaterialCoating", "lensMaterialCoating");
makeToggle("toggle-brand", "brand");
makeToggle("toggle-lenstype", "lenstype");
makeToggle("toggle-reference", "reference");
makeToggle("toggle-reference2", "reference2");







</script>



<script>
function roundQuarter(x) {
  return (Math.round(x * 4) / 4).toFixed(2);
}

document.querySelectorAll(".small-normal-btn[data-value]").forEach(btn => {
  btn.addEventListener("click", () => {
    const addVal = parseFloat(btn.dataset.value);
    const eyes = ["sphOD", "sphOS"];

    eyes.forEach(id => {
      const field = document.getElementById(id);
      if (!field) return;

      const current = parseFloat(field.value) || 0;
      const newVal = roundQuarter(current + addVal);
      field.value = (newVal > 0 ? "+" : "") + newVal;
      field.dispatchEvent(new Event("input"));
    });
  });
});

document.getElementById("resetSph").addEventListener("click", () => {
  ["sphOD", "sphOS"].forEach(id => {
    const field = document.getElementById(id);
    if (field) {
      field.value = "+0.00";
      field.dispatchEvent(new Event("input"));
    }
  });
});

</script>














<script>
(function(){
  const TEMPLATE = `
    <div class="axis-dc-widget" style="font-size:10px;">
      <table style="width:100%; border:none; border-collapse:collapse;">
        <tr class="calibrator">
          <td style="border:none;"></td><td style="border:none;"></td><td style="border:none;"></td>
          <td style="border:none;"></td><td style="border:none;"></td><td style="border:none;"></td>
          <td style="border:none;"></td>
        </tr>
        <tr class="white">
          <td colspan="2" style="font-weight:bold; text-align:center;">DC Clearer Side</td>
          ${["+1.00","+0.50","Now RX","-0.50","-1.00"].map(lbl=>`
            <td style="text-align:center; padding:10px 5px;">
              <span class="result-label">${lbl}</span><br>
              <select class="dc-result-select" style="width:85%;">
                <option>-</option>
                <option>Green</option>
                <option>Balance</option>
                <option>Red</option>
              </select>
            </td>`).join("")}
        </tr>
      </table>

      <!-- R/G Codes compact -->
      <table style="width:100%; border-collapse:collapse; font-size:10px; text-align:center;">
        <tr class="calibrator">
          <td style="border:none;"></td><td style="border:none;"></td><td style="border:none;"></td><td style="border:none;"></td>
          <td style="border:none;"></td><td style="border:none;"></td><td style="border:none;"></td><td style="border:none;"></td>
        </tr>
        <tr class="white">
          <td colspan="2"><b> R Codes Fanchart </b></td>
          <td style="color:#cc0000; font-weight:bold;">R0 = 90</td>
          <td style="color:#cc0000; font-weight:bold;">R1 = 105</td>
          <td style="color:#cc0000; font-weight:bold;">R2 = 120</td>
          <td style="color:#cc0000; font-weight:bold;">R3 = 135</td>
          <td style="color:#cc0000; font-weight:bold;">R4 = 150</td>
          <td style="color:#cc0000; font-weight:bold;">R5 = 165</td>
        </tr>
        <tr class="white">
          <td colspan="2"><b> G Codes Fanchart </b></td>
          <td style="color:green; font-weight:bold;">G0 = 180</td>
          <td style="color:green; font-weight:bold;">G1 = 15</td>
          <td style="color:green; font-weight:bold;">G2 = 30</td>
          <td style="color:green; font-weight:bold;">G3 = 45</td>
          <td style="color:green; font-weight:bold;">G4 = 60</td>
          <td style="color:green; font-weight:bold;">G5 = 75</td>
        </tr>
        <tr class="white">
          <td colspan="2"><b>Clock To Axis </b></td>
          <td style="font-weight:bold; text-align:center;">9 – 3 = 180°</td>
          <td style="font-weight:bold; text-align:center;">10 – 4 = 30°</td>
          <td style="font-weight:bold; text-align:center;">11 – 5 = 60°</td>
          <td style="font-weight:bold; text-align:center;">12 – 6 = 90°</td>
          <td style="font-weight:bold; text-align:center;">1 – 7 = 120°</td>
          <td style="font-weight:bold; text-align:center;">2 – 8 = 150°</td>
        </tr>
      </table>

      <!-- FC 3 Darker Lines row -->
      <table style="width:100%; border-collapse:collapse;">
        <tr class="calibrator">
          <td style="border:none;"></td><td style="border:none;"></td><td style="border:none;"></td>
          <td style="border:none;"></td><td style="border:none;"></td><td style="border:none;"></td>
          <td style="border:none;"></td>
        </tr>
        <tr class="white">
          <td colspan="2"><b>FC 3 Darker Lines</b></td>
          <td colspan="2">
            <span class="result-label">Now RX</span>
            <input type="text" class="fc-darker-input fc-gr-input" placeholder="—" style="width:50px;">
          </td>
          <td colspan="2">
            <span class="result-label">+0.50 Cyl</span>
            <input type="text" class="fc-darker-input fc-gr-input" placeholder="—" style="width:50px;">
          </td>
          <td colspan="2">
            <span class="result-label">+1.00 Cyl</span>
            <input type="text" class="fc-darker-input fc-gr-input" placeholder="—" style="width:50px;">
          </td>
        </tr>
      </table>

      <!-- Axis Average Calculator -->
      <table style="width:100%; border:none; border-collapse:collapse;">
        <tr class="calibrator"><td style="border:none;"></td></tr>
        <tr class="white">
          <td>
            <div style="padding:6px 0; display:flex; align-items:center; gap:10px; font-weight:bold;">
              <span>Axis Average Calculator</span>
              <div style="display:flex; gap:6px; align-items:center;">
                <span>Code 1: <input type="text" class="calc1 fc-gr-input" style="width:50px;"></span>
                <span>Code 2: <input type="text" class="calc2 fc-gr-input" style="width:50px;"></span>
              </div>
              <div style="display:flex; gap:20px; align-items:center;">
                <button class="btn-calc" type="button" style="margin-left:10px;">Calculate</button>
                <span>Average Axis: <span class="axis-avg">—</span></span>
              </div>
            </div>
          </td>
        </tr>
      </table>
    </div>
  `;

  const AxisMap = {
    G0:180, G1:15, G2:30, G3:45, G4:60, G5:75,
    R0:90,  R1:105, R2:120, R3:135, R4:150, R5:165
  };

  function colorizeSelect(sel){
    const txt = sel.value;
    sel.style.fontWeight = "bold";
    if (txt === "Green") sel.style.color = "green";
    else if (txt === "Red") sel.style.color = "red";
    else sel.style.color = "black";
  }

  function wireWidget(root){
    // colorize DC selects
    root.querySelectorAll(".dc-result-select").forEach(sel=>{
      sel.addEventListener("change", ()=>colorizeSelect(sel));
      colorizeSelect(sel);
    });

// add inside wireWidget(root) after your other listeners
function colorizeAxisField(el){
  const raw = (el.value || "").toUpperCase().trim();
  el.style.fontWeight = "bold";
  // Exact code: R0–R5 or G0–G5
  if (/^R[0-5]$/.test(raw)) { el.style.color = "#cc0000"; el.style.outline = ""; return; }
  if (/^G[0-5]$/.test(raw)) { el.style.color = "green";   el.style.outline = ""; return; }
  // Empty -> default
  if (raw === "") { el.style.color = ""; el.style.outline = ""; el.style.fontWeight = ""; return; }
  // Invalid but non-empty
  el.style.color = "#B42318";           // warn red
  el.style.outline = "1px dashed #B42318";
}

// Looser rule for FC darker inputs: if it contains R/G anywhere
function colorizeFCDarker(el){
  const raw = (el.value || "").toUpperCase();
  el.style.fontWeight = "bold";
  if (raw.includes("R")) { el.style.color = "#cc0000"; el.style.outline = ""; return; }
  if (raw.includes("G")) { el.style.color = "green";   el.style.outline = ""; return; }
  if (raw === "")        { el.style.color = ""; el.style.outline = ""; el.style.fontWeight = ""; return; }
  el.style.color = ""; el.style.outline = "";
}

// Wire up listeners
(root.querySelectorAll(".calc1, .calc2") || []).forEach(el=>{
  el.addEventListener("input", ()=>colorizeAxisField(el));
  colorizeAxisField(el);
});

(root.querySelectorAll(".fc-darker-input") || []).forEach(el=>{
  el.addEventListener("input", ()=>colorizeFCDarker(el));
  colorizeFCDarker(el);
});

    // DC input echo (guarded — these fields may not exist here)
    const dcInput = root.querySelector(".dc-sph");
    const dcText  = root.querySelector(".dc-analysis-text");
    if (dcInput && dcText){
      function updateDC(){
        const v = (dcInput.value||"").trim();
        if(!v){ dcText.textContent = "—"; return; }
        const num = Number(v.replace(/[^\d\.\-\+]/g,""));
        if (isNaN(num)) { dcText.textContent = "Invalid"; return; }
        dcText.textContent = (num>=0? "+" : "") + num.toFixed(2) + " D";
      }
      dcInput.addEventListener("input", updateDC);
      updateDC();
    }

    // Axis average
    const btn = root.querySelector(".btn-calc");
    if (btn){
      btn.addEventListener("click", ()=>{
        const c1 = (root.querySelector(".calc1")?.value || "").toUpperCase().trim();
        const c2 = (root.querySelector(".calc2")?.value || "").toUpperCase().trim();
        const a1 = AxisMap[c1], a2 = AxisMap[c2];
        const out = root.querySelector(".axis-avg");
        if(a1===undefined || a2===undefined){ if(out) out.textContent = "Invalid code"; return; }
        let diff = a2 - a1;
        if(diff > 90)  diff -= 180;
        if(diff < -90) diff += 180;
        let avg = a1 + diff/2;
        if(avg < 0)   avg += 180;
        if(avg > 180) avg -= 180;
        if(out) out.textContent = avg.toFixed(1);
      });
    }
  }

  // Public init
  window.initAxisDCWidget = function mount(selector){
    const host = document.querySelector(selector);
    if(!host) return;
    host.innerHTML = TEMPLATE;
    wireWidget(host);
  };
})();
</script>



<script>
  // Example: initialize in two places
  initAxisDCWidget('#axis-dc-spot-1');
  initAxisDCWidget('#axis-dc-spot-2');
</script>

















</div>
</div>


<!-- Spacer at the bottom for scrolling -->
<div style="height:300px;"></div>



</body>
</html>




