<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=160, initial-scale=0.6, maximum-scale=1, user-scalable=yes">
<title>Kiara Optometry Prescription Calculator</title>
<style>
* {
  font-size: 12px;
  letter-spacing: 1px;
}

html, body {
  font-size: 20px; /* your base */
	  -webkit-text-size-adjust: none; /* prevents Safari scaling */

}

body { 
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
  font-size: 20px;
  margin: 0;
  background: #f8f8f5;
  color: black;
}

table td:first-child,
table th:first-child {
  width: 80px;
}

table td:nth-child(2),
table th:nth-child(2){
  max-width: 40px;
  width: 40px;
}

table td:nth-child(3),
table th:nth-child(3) {
  min-width: 90px;
  width: 90px;
  white-space: nowrap;
}

table td:nth-child(4),
table th:nth-child(4) {
  min-width: 90px;
  width: 90px;
  white-space: nowrap;
}

table td:nth-child(5),
table th:nth-child(5) {
  min-width: 90px;
  width: 90px;
  white-space: nowrap;
}

table td:nth-child(6),
table th:nth-child(6) {
  min-width: 50px;
  width: 50px;
  white-space: nowrap;
}

table td:nth-child(7),
table th:nth-child(7) {
  min-width: 50px;
  width: 50px;
  white-space: nowrap;
}

h2 { 
  text-align:center; 
  margin-bottom:10px; 
}

table { 
  border-collapse: collapse;
  table-layout: fixed;
  width: 95%; /* keep your width */ 
  margin:0 auto; 
  font-size: 20px; 

}

th, td { 
  border:0.5px solid #999; 
  padding:5px; 
  text-align:center; 
  vertical-align: middle;
  white-space: normal;   /* allow line wrapping */
  word-wrap: break-word; /* legacy */
  overflow-wrap: break-word; /* modern */
}

th {   background:#d9d9d9; 
  color: black;}

input {   width:80px; 
  padding:2px; 
  text-align:center; 
  box-sizing: border-box;}

.now td { background: #F5F5F5; }
.now-comfort td { background: #F5F5F5 ;}
.white td { background: #d9d9d9; }
.fc-results td { background: #EFF5E6; }
.dc-bal td { background: #fff; }

.table-headernow {  background: #E8D1A0;}

.comfort {  background: #E5F0D1;}
.offwhite { background: #f8f8f5; }

.sph-btn, .addMinus025 {
  user-select: none;      /* prevent text highlight */
  -webkit-user-select: none; /* Safari */
  -moz-user-select: none;    /* Firefox */
}


/* üîí Overlay for blackout */
#overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: #EDEADF;
  color: black;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  z-index: 9999;
}

#apply-controls { text-align:left; margin-bottom:10px; margin-top:10px; margin-left:10px }
#addMinus025 { cursor:pointer; color:black; text-decoration:underline; user-select:none; }

.custom-link {
  color: #101F01;       /* text color */
  font-weight: bold;    /* normal | bold | lighter | 100-900 */
  font-style: normal;   /* normal | italic | oblique */
  text-decoration: none; /* none | underline | overline | line-through */
}


</style>
</head>
<body>

<!-- üîí Locked screen -->
<div id="overlay">üîí Entering password...</div>

<script>
  function checkPassword() {
    let password = "";
    const correctPassword = ""; // change this

    while (password !== correctPassword) {
      password = prompt("Please enter password to use:");
      if (password === null) {
        document.getElementById("overlay").innerHTML = "Sorry, Access Denied.";
        return false;
      }
      if (password !== correctPassword) {
        alert("Wrong password. Try again.");
      }
    }
    return true;
  }

  window.onload = function () {
    if (checkPassword()) {
      document.getElementById("overlay").style.display = "none";
      // there's no #content in your original but leaving safe
      const c = document.getElementById("content");
      if(c) c.style.display = "block";
    }
  };
</script>


<div style="height:10px;"></div>

<h2 style="text-align:center;">
KIARA OPTOMETRY V4 CALCULATOR

</h2>
<div style="height:10px;"></div>

<table>
<tr class="offwhite">
<td colspan="1" style="color:#182E00; text-align:left; padding:15px;">

 <span class="toggle-btn" data-target="toggle-section-fcdc-errormargin"
          style="cursor:pointer; color: #101F01; user-select:none;">
      <b>- How to Do FCDC Error Margin test - <i>click to show/hide</i></B><br>
</span>

    <span class="toggle-btn" data-target="toggle-section-guide-comfort"
          style="cursor:pointer; color: #101F01; user-select:none;">
      <b>- How to perform the exam and use the RX Calculator - <i>click to show/hide</i></B><BR>
</span>

</td>
</tr>
</table>



<table>
<tbody class="toggle-section-fcdc-errormargin" style="display:none;">
<tr class="offwhite">
  <td colspan="1" style="padding:10px; border:none; color:#182E00; text-align:left;">
<b>Purpose:</b><br>
FC‚ÄìDC Error Margin Test maps how far the visual system is from a true <b>balanced prescription</b>. Using a series of trial lenses (usually 5‚Äì10 steps) we locate areas of over- and under-correction, then calculate the balanced RX. The test can be done binocularly or monocularly and works with glasses or contacts.<br><br>

<b>Important concept:</b><br>
Fan Chart (FC) and Duochrome (DC) are <b>inter-related</b>. The FC reveals astigmatic/line errors; if FC is not balanced, DC results will be unreliable. Correct the FC first ‚Äî this usually requires a slight under-correction (a little less minus / a little more plus). When FC is corrected correctly, the DC should show clearer <b>red</b> during the balancing step.<br><br>

<b>Materials:</b><br>
1. Fan Chart (FC) and Duochrome (DC) charts.<br>
2. Trial lenses (5‚Äì10 steps; e.g. +1.00, +0.50, 0, -0.50, -1.00).<br>
3. Calculator to enter FC/DC balance values.<br><br>

<b>Steps ‚Äî Practical workflow</b><br><br>

1. <b>Explain & position:</b> Ask the patient to view the FC/DC chart and tell them you‚Äôll try several lenses. Encourage quick, instinctive answers.<br><br>

2. <b>Balance the Fan Chart (FC) first:</b> Always center the FC before using DC. If parts of the fan look darker or blurred, place plus cylinder (or the appropriate cylinder) on the darker region to bring the fan into balance. Do not proceed to DC until the FC looks centered and even.<br><br>

<img src="https://raw.githubusercontent.com/kiaraoptometrypx/RX-calculator/main/FCDCchart1.png"
         alt="Fc Dc Chart 1" style="max-width:80%;">
<br><br>

3. <b>Perform the Duochrome (DC) sequence:</b> Present lens steps around the current RX (example: +1.00, +0.50, 0, -0.50, -1.00). For each step ask: ‚ÄúWhich side is clearer ‚Äî red or green?‚Äù Record quick responses.<br><br>

4. <b>Interpret results:</b> Identify the lens position where balance or smallest difference occurs. That lens value is the <b>sphere to balance DC</b> ‚Äî enter it into the calculator along with the FC adjustments.<br>
   <i>Example:</i> +1.00 red clearer, +0.50 both same, 0 green clearer, -0.50 green clearer, -1.00 both blur ‚Üí here +0.50 is the SPH to balance DC.<br><br>

5. <b>Map & record:</b> Log the FC (cyl/axis) and DC (sphere to balance). Use the calculator to compute the Balanced RX.<br><br>

6. <b>Confirm binocularly:</b> If you performed monocular checks, confirm the balanced prescription with both eyes open and ask about comfort and clarity.<br><br>

<b>Tips & troubleshooting:</b><br>
- Always balance FC before DC ‚Äî FC errors will invalidate DC readings.<br>
- Aim for a slight under-correction when fixing FC (less minus / more plus). When done correctly, DC should lean clearer to <b>red</b> during balancing ‚Äî this indicates the FC adjustment moved the eye into the correct region for DC testing.<br>
- Ask for quick answers. Long, uncertain replies reduce test reliability. Repeat if responses are inconsistent.<br>
- Keep step sizes consistent (0.25 or 0.50 D) and record which steps were used.<br><br>

<b>Note:</b> This test measures the additional power needed to reach balance ‚Äî clinical judgment and binocular confirmation are essential before finalising any prescription.<br><br>
----


</td>
</tr>
</tbody>
</table>



<table>
<tbody class="toggle-section-guide-comfort" style="display:none;">
<tr class="offwhite">
  <td colspan="1" style="padding:10px; border:none; color:#182E00; text-align:left;">

<b>- Steps for Comfy Clearer Test -</b><br><br>

1. Begin with the patient <b>wearing their current glasses or prescription</b>.<br>
2. Keep <b>both eyes open</b> during the test (to maintain natural binocular vision).<br>
3. <b>Change lenses equally</b> for both eyes at the same time.<br>
4. This keeps the <b>prismatic effect balanced</b>, even if the prescription changes.<br>
5. Perform the <B>FC DC Error Margin test</b>.<br>
6. Use the <b>Fan Chart (FC)</b> to find the <b> cyl and axis to bal </b> values, then enter those into the calculator.<br>
7. The calculator will give you the <b>Balance RX</b> (the true and full prescription).<br>
8. Apply the <b>Horizontal Sharpening</b> function.<br>
9. If the wearer has special needs (e.g. wants sharper distance or near vision), make slight <b>sphere adjustments</b>.<br>
10. If no special needs, keep the same <b>DC status</b> as before.<br><br>

<b>Note:</b> When checking each eye separately, <b>one eye may still show some error.</b> 
This is <b>normal</b> because the <b>test corrects binocularly</b>, not monocularly.  
The small error in one eye <b>does not affect daily vision</b>.<br><br><i> End of Comfy Clearer </i><br>---
        </td>
</tr>
<tr>
  <td colspan="1" style="padding:10px; border:none; color:#182E00; text-align:left;">
<b>- Steps for Sharpest Ever Test -</b><br><br>

1. Begin with the patient‚Äôs <b>current prescription</b>.<br>
2. For the sharpest possible vision,<b>perform FC DC Error Margin test on each eye separately</b> (monocular testing).<br>
3. This may cause the two eyes to become <b>imbalanced</b>, since one eye‚Äôs prescription can change more than the other.<br>
4. Use <b>SE Diff</b> (Spherical Equivalent Difference) to track the difference in prescription strength between the two eyes.<br>
5. A new SE Diff introduces a <b>prismatic effect</b> when looking away from the lens center.<br>
6. An SE Diff change of <b>0.25</b> usually requires about a week of adaptation.<br>
7. Most people can tolerate up to <b>0.50 SE Diff change</b> without major issues.<br>
8. Beyond this, adaptation becomes difficult and may lead to <b>adaptation failure</b>.<br>
9. Tolerance is linked to <b>accommodation</b> (the eye‚Äôs focusing ability).<br>
10. <b>Younger patients</b> generally adapt better to larger SE Diff changes.<br><br><i> End of Sharpest Ever</i><br>---


     
</td>
</tr>
</tbody>
</table>


<!-- Toggle function -->
<script>
function toggleSection(id) {
  const section = document.getElementById(id);
  section.style.display = (section.style.display === "none") ? "table-row" : "none";
}
</script>


<div style="height:10px;"></div>


<table>


  <tr class="white">
    <th>Rx Type</th>
    <th>Sides</th>
    <th>Sph</th>
    <th>Cyl</th>
    <th>Axis</th>
    <th>SE Diff</th>
    <th>DC</th>
  </tr>

  <!-- Now RX -->
  <tr class="white">
  <td rowspan="2">Current RX</td>
    <td>Right</td>
    <td><input id="s1_od" placeholder="+0.00"></td>
    <td><input id="c1_od" placeholder="+0.00"></td>
    <td><input id="a1_od" placeholder="0"></td>
    <td id="now-se-diff-od">‚Äî</td>
    <td>‚Äî</td>
  </tr>

  <tr class="white">
    <td>Left</td>
    <td><input id="s1_os" placeholder="+0.00"></td>
    <td><input id="c1_os" placeholder="+0.00"></td>
    <td><input id="a1_os" placeholder="0"></td>
    <td>‚Äî</td>
    <td>‚Äî</td>
  </tr>

<tr>
<td colspan="7" style="padding:5px; border:none;"></td>
</tr>

<tr class="comfort">
  <td colspan="7" style="padding:10px; color: #101F01; text-align:left;">

<b>- Comfy Clearer Rx -</b>  

<span class="toggle-btn" data-target="toggle-section-comfort-rx"
          style="cursor:pointer; color: #101F01; user-select:none; margin-left:15px;">
      Results..
    </span>

    <span style="margin-left:15px;  margin-right:15px; text-decoration:none; cursor:pointer; color:#101F01; user-select:none;"
          onclick="event.stopPropagation(); let t=document.getElementById('deficit-rows-comfort'); t.style.display=t.style.display==='none'?'table-row-group':'none';">
      Diagnostics..
    </span>

Status:
<span id="testToggle1" style="cursor:pointer; user-select:none; color: #101F01; margin-left:0px;">
  ‚úñ N/A..
</span>


  </td>
</tr>


  <tbody id="deficit-rows-comfort" style="display:none;">

  <!-- Deficit Rows -->
<tr class="now-comfort">
    <td colspan="2">Error Margin & DX</td>
    <td>Sph to Bal DC</td>
    <td colspan="2">Cyl & Axis to Bal FC</td>
    <td>SE Diff</td>
    <td>DC</td>
  </tr>
 
<tr class="now-comfort">
    <td>Bino Error<br>Margin</td>
<td>Both</td>
    <td><input id="dc-sph-ou" placeholder="0.00"></td>
    <td><input id="c2_ou" placeholder="+0.00"></td>
    <td><input id="a2_ou" placeholder="0"></td>
    <td id="def-se-diff-ou">‚Äî</td>
    <td id="dc-ou">‚Äî</td>
  </tr>

<tr class="now-comfort">
  <td rowspan="2">DC & FC<br>Bal Bino</td>
<td>Right</td>
  <td id="final-sph-ou-re">0.00</td>
  <td id="final-cyl-ou-re">0.00</td>
  <td id="final-axis-ou-re">0</td>
  <td id="final-se-ou-re" style="display:none;">‚Äî</td>
  <td id="bypass-final-ou">‚Äî</td>
  <td id="final-dc-ou-re">BAL</td>
</tr>
<tr class="now-comfort">
 <td>Left</td>

  <td id="final-sph-ou-le">0.00</td>
  <td id="final-cyl-ou-le">0.00</td>
  <td id="final-axis-ou-le">0</td>
  <td id="final-se-ou-le" style="display:none;">‚Äî</td>
  <td>‚Äî</td>
  <td id="final-dc-ou-le">BAL</td>
</tr>

<tr class="now-comfort">
  <td>
Adjustments
</td>
<td>Both</td>
<td colspan="5" style="padding:7px; text-align:left;">
    <div>
<!-- Clickable control to apply -0.25 x 180 -->
    <span class="addMinus025" role="button" 
          style="cursor:pointer; user-select:none; margin-right:15px; margin-left:15px;">
      Apply -0.25 √ó 180
    </span>


<span class="sph-btn" data-group="ou" data-step="-0.25"
          style="cursor:pointer; text-decoration:none; color:green; margin-right:2px; margin-left:15px;">
      S-0.25..
   </span>
<span class="sph-btn" data-group="ou" data-step="0.25"
          style="cursor:pointer; text-decoration:none; color:red; margin-right:15px; margin-left:2px;">
      S+0.25..
</span>
    </span>
<span class="testStatus" style="cursor:pointer; color: #101F01; user-select:none; text-decoration:none; margin-right:2px; margin-left:15px;">
  Test ongoing..
</span>


</td>
</div>
</tr>

</tbody>


<tbody class="toggle-section-comfort-rx" style="display:none;">

<tr class="comfort">
<td>Rx Type</td>
<td>Sides</td>
<td>Sph</td>
<td>Cyl</td>
<td>Axis</td>
<td>SE Diff</td>
<td>DC</td>

  </tr>
<tr class="comfort">
    <td rowspan="2">Prescribed<br>Bino</td>
<td>Right</td>

    <td id="res-sph-ou-re">0.00</td>
    <td id="res-cyl-ou-re">0.00</td>
    <td id="res-axis-ou-re">0</td>
    <td id="res-se-diff-ou-re">‚Äî</td>
    <td id="res-dc-ou-re">BAL</td>
  </tr>

<tr class="comfort">
 <td>Left</td>
    <td id="res-sph-ou-le">0.00</td>
    <td id="res-cyl-ou-le">0.00</td>
    <td id="res-axis-ou-le">0</td>
    <td >‚Äî</td>
    <td id="res-dc-ou-le">BAL</td>
  </tr>

<tr class="comfort">
  <td>Analysis<br>& Plan</td>
  <td id="analysis-ou" colspan="6" style="text-align:left;">
    <!-- Combined analysis text for OU will appear here -->
  </td>
</tr>
</tbody>


<tr>
<td colspan="7" style="padding:5px; border:none;"></td>
</tr>




<tr class="table-headernow">
<td colspan="7" style="padding:10px; color: #241D0C; text-align:left;">
<b>- Sharpest Ever Rx -</b>


 <span class="toggle-btn" data-target="toggle-section-sharper-rx" 
      style="cursor:pointer; color: #241D0C; user-select:none; margin-left:15px;">
Results..
</span>

    <span style="margin-left:15px; margin-right:15px; text-decoration:none; cursor:pointer; color:#241D0C; user-select:none;"
          onclick="event.stopPropagation(); let t=document.getElementById('deficit-rows-sharper'); t.style.display=t.style.display==='none'?'table-row-group':'none';">
      Diagnostics..
    </span>

Status:


<span id="testToggle2" style="cursor:pointer; user-select:none; color: #241D0C;">
  ‚úñ N/A..
</span>

</td>
</tr>


<tbody class="toggle-section-sharper" style="display:none;">
 <tr class="table-headernow">
  <td colspan="7" style="padding:10px; text-align:left;>
    <div style="margin-top:8px; color:#241D0C;">
      <i>
       1. Test is done ontop of the current prescription.<br>
       2. Seeing sharpest ever requires each eye to be tested to their own perfection, one eye at a time.<br>
       3. Binocular may become imbalance because one eye's prescription may change more.<br>
4. SE Diff is a metric to track the RX difference between the eyes.<br>
5. A new SE Diff creates new prismatic effect when looking off from lens centre.<br>
       6. SE Diff changes of 0.25 may require a week of adaptation.<br>
       7. Maximum tolerance of SE Diff changes is 0.50 for majority of people.<br>
      8. More than that will require serious adaptation and may subject to adaptation failure.<br>
9. However, there is a correlation between SE Diff changes range and accommodation.<br>
10. That is why younger people have better tolerance.
      </i>
    </div>
  </td>
</tr>


<script>
document.querySelectorAll('.toggle-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const target = btn.getAttribute('data-target');
    document.querySelectorAll(`.${target}`).forEach(el => {
      el.style.display = (el.style.display === 'none' || el.style.display === '') ? 'table-row-group' : 'none';
    });
  });
});
</script>
<script>
function makeToggle(spanId) {
  const span = document.getElementById(spanId);
  let testDone = false; // initial state

  span.addEventListener("click", () => {
    testDone = !testDone; // toggle state

    if (testDone) {
      span.textContent = "‚úî Completed..";
      span.style.textDecoration = "none"; // underline when done
      span.style.fontStyle = "normal";         // normal font
    } else {
      span.textContent = "‚úñ N/A..";
      span.style.textDecoration = "none";      // remove underline
      span.style.fontStyle = "normal";         // 
    }
  });
}

// Apply to both spans
makeToggle("testToggle1");
makeToggle("testToggle2");
</script>


<!-- Deficit Rows (wrapped in toggle container) -->
<tbody id="deficit-rows-sharper" style="display:none;">


  <tr class="now">
    <td colspan="2">Error Margin & DX</td>
    <td>Sph to Bal DC</td>
    <td colspan="2">Cyl & Axis to Bal FC</td>
    <td>SE Diff</td>
    <td>DC</td>
  </tr>

  <tr class="now">
    <td rowspan="2">Mono Error<br>Margin</td>
<td>Right</td>

    <td><input id="dc-sph-od" placeholder="0.00"></td>
    <td><input id="c2_od" placeholder="+0.00"></td>
    <td><input id="a2_od" placeholder="0"></td>
    <td id="def-se-diff-od">‚Äî</td>
    <td id="now-dc-od">‚Äî</td> 
  </tr>

  <tr class="now">
<td>Left</td>

    <td><input id="dc-sph-os" placeholder="0.00"></td>
    <td><input id="c2_os" placeholder="+0.00"></td>
    <td><input id="a2_os" placeholder="0"></td>
    <td id="def-se-diff-os">‚Äî</td>
    <td id="now-dc-os">‚Äî</td> 
  </tr>

  <tr class="now">
    <td rowspan="2">DC & FC<br>Bal Mono</td>
<td>Right</td>

    <td id="final-sph-od">0.00</td>
    <td id="final-cyl-od">0.00</td>
    <td id="final-axis-od">0</td>
    <td id="final-se-od" style="display:none;">‚Äî</td>
    <td id="bypass-final-mono">‚Äî</td>
    <td id="final-dc-od" style="display:none;">BAL </td>
    <td>-</td>
  </tr>
  <tr class="now">
    <td>Left</td>
    <td id="final-sph-os">0.00</td>
    <td id="final-cyl-os">0.00</td>
    <td id="final-axis-os">0</td>
    <td id="final-se-os" style="display:none;">‚Äî</td>
    <td>‚Äî</td>
    <td id="final-dc-os" style="display:none;">BAL </td>
    <td>-</td>
  </tr>

  <tr class="now">
<td>
Adjustments
</td>
<td>Both</td>
<td colspan="5" style="padding:7px; text-align:left;">
 <!-- Clickable control to apply -0.25 x 180 -->

    <span class="addMinus025" role="button" 
          style="cursor:pointer; user-select:none; margin-right:15px; margin-left:15px;">
      Apply -0.25 √ó 180
    </span> 

<!-- SPH Controls -->
    <span class="sph-btn" data-group="mono" data-step="-0.25"
          style="cursor:pointer; text-decoration:none; color:green; margin-right:2px; margin-left:15px;">
      S-0.25..
   </span>
    <span class="sph-btn" data-group="mono" data-step="0.25"
          style="cursor:pointer; text-decoration:none; color:red; margin-right:15px; margin-left:2px;">
      S+0.25..
</span>
    </span>
<span class="testStatus" style="cursor:pointer; color: #101F01; user-select:none; text-decoration:none; margin-right:2px; margin-left:15px;">
  Test ongoing..
</span>



<script>
document.addEventListener("DOMContentLoaded", () => {

  // Shared state for all mirrors
  let testDone = false;

  // Function to update all mirrors
  function updateTestStatusMirrors() {
    document.querySelectorAll(".testStatus").forEach(el => {
      el.textContent = testDone ? "Test done" : "Test ongoing..";
      el.style.color = testDone ? "green" : "black";
    });
  }

  // Attach click listener to all current and future mirrors
  function attachMirrorListeners() {
    document.querySelectorAll(".testStatus").forEach(el => {
      if(!el.dataset.listenerAttached){
        el.addEventListener("click", () => {
          testDone = !testDone;
          updateTestStatusMirrors();
        });
        el.dataset.listenerAttached = "true";
      }
    });
  }

  // Initial setup
  attachMirrorListeners();
  updateTestStatusMirrors();

  // Optional: observe DOM changes to attach listeners to newly added mirrors
  const observer = new MutationObserver(() => {
    attachMirrorListeners();
  });
  observer.observe(document.body, { childList: true, subtree: true });

});
</script>
<script>
document.addEventListener("DOMContentLoaded", () => {

  let testDone = false; // shared state

  function updateMirrors() {
  document.querySelectorAll(".testStatus").forEach(el => {
    if (testDone) {
      el.textContent = "RX Finalized..";
      el.style.textDecoration = "none";  // 
      el.style.fontStyle = "normal";          // normal font
      el.style.color = "#285C00";
    } else {
      el.textContent = "RX Ongoing..";
      el.style.textDecoration = "none";       // remove underline
      el.style.fontStyle = "italic";          // italic for ongoing
      el.style.color = "#6E0900";
    }
  });
}

  // Mirror click behavior: toggle
  document.querySelectorAll(".testStatus").forEach(el => {
    el.addEventListener("click", () => {
      testDone = !testDone; // toggle on click
      updateMirrors();
    });
  });

  // Reset mirrors whenever a calculator input changes
  const inputIds = [
    "s1_od","c1_od","a1_od",
    "s1_os","c1_os","a1_os",
    "dc-sph-od","c2_od","a2_od",
    "dc-sph-os","c2_os","a2_os",
    "dc-sph-ou","c2_ou","a2_ou"
  ];

  inputIds.forEach(id => {
    const el = document.getElementById(id);
    if(el) el.addEventListener("input", () => {
      testDone = false; // revert
      updateMirrors();
    });
  });

  // Reset mirrors on adjustment buttons (Cyl -0.25, S -0.25, S +0.25)
  const adjustmentButtons = document.querySelectorAll(".addMinus025, .sph-btn");
  adjustmentButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      testDone = false; // revert
      updateMirrors();
    });
  });

  updateMirrors(); // initialize
});
</script>


</td>
</tr>

</tbody>


<tbody class="toggle-section-sharper-rx" style="display:none;">

  <tr class="table-headernow">
    <td rowspan="2">Prescribed<br>Mono</td>
<td>Right</td>
    <td id="res-sph-od-2">0.00</td>
    <td id="res-cyl-od-2">0.00</td>
    <td id="res-axis-od-2">0</td>
    <td id="res-se-od-2" style="display:none;">‚Äî</td>
    <td id="bypass">‚Äî</td>
    <td id="res-dc-od-2">BAL</td> 
  </tr>
  <tr class="table-headernow">
    <td>Left</td>
    <td id="res-sph-os-2">0.00</td>
    <td id="res-cyl-os-2">0.00</td>
    <td id="res-axis-os-2">0</td>
    <td>‚Äî</td>    
    <td id="res-se-os-2" style="display:none;">‚Äî</td>
    <td id="res-dc-os-2">BAL</td> 
  </tr>

</tbody>



</table>



<script>
document.addEventListener("DOMContentLoaded", () => {

// ---------- Toggle for extra -0.25 @ 180 (mirror buttons) ----------
let extraMinus025 = false;

// helper to update all mirror buttons' label + color so they stay in sync
function updateMinus025Buttons() {
  document.querySelectorAll('.addMinus025').forEach(b => {
    b.style.color = extraMinus025 ? 'red' : 'black';
    b.textContent = extraMinus025 ? 'Horizontal Sharpening..' : 'All Angles Even..';
  });
}

// attach listener to every mirror button
document.querySelectorAll('.addMinus025').forEach(btn => {
  btn.addEventListener('click', () => {
    extraMinus025 = !extraMinus025;
    updateMinus025Buttons();
    combineAll();
  });
});

// set initial text/color for any buttons (in case they exist on load)
updateMinus025Buttons();

  // ---------- Helpers ----------
function combineEyeWithout025(S_now, C_now, A_now, DC_S, C2, A2){
  const savedExtra = extraMinus025;       // save current state
  extraMinus025 = false;                  // temporarily disable -0.25
  const result = combineEyeWithDeficit(S_now, C_now, A_now, DC_S, C2, A2);
  extraMinus025 = savedExtra;             // restore state
  return result;
}

  // ---------- Helpers ----------
  function safeParseFloat(v){
    if(v === null || v === undefined) return 0;
    if(typeof v === "number") return Number.isFinite(v) ? v : 0;
    v = String(v).trim();
    if(v === "" || v === "‚Äî" || v === "‚Äì") return 0;
    v = v.replace(',', '.');
    const n = parseFloat(v);
    if(!Number.isNaN(n)) return n;
    const m = v.match(/[+-]?(?:\d+\.?\d*|\.\d+)/);
    return m ? parseFloat(m[0]) : 0;
  }

  function roundQuarterNumber(n){ return Math.round(safeParseFloat(n) * 4) / 4; }
  function formatValueForDisplay(n){ const val = roundQuarterNumber(n); return (val >= 0 ? "+" : "") + val.toFixed(2); }

  function calcSENumber(S, C){ S = safeParseFloat(S); C = safeParseFloat(C); return S + C/2; }
  function formatSEforDisplay(n){ return (n >= 0 ? "+" : "") + n.toFixed(2); }

  function formatSEDiffForDisplay(n){
    const num = safeParseFloat(n);
    if (isNaN(num)) return "‚Äî";
    return (num >= 0 ? "+" : "") + num.toFixed(2);
  }

  function deg2rad(d){ return d * Math.PI / 180; }
  function rad2deg(r){ return r * 180 / Math.PI; }

  function toMinusCyl({S, C, A}) {
    S = safeParseFloat(S); C = safeParseFloat(C); A = Math.round(safeParseFloat(A) || 0);
    if (C > 0) { S = S + C; C = -C; A = (A + 90) % 180; }
    A = ((A % 180) + 180) % 180;
    return { S, C, A };
  }

  function setIf(id, val){
    const el = document.getElementById(id);
    if(el) el.textContent = val;
  }

  function dcStatusText(val){
    let v = roundQuarterNumber(val);
    if(v === 0) return { text: "BAL", color: "black" };
    const absVal = Math.abs(v);
    const level = Math.max(Math.round(absVal / 0.25), 1);
    if(v > 0) return { text: `G${level} Over -${absVal.toFixed(2)}`, color: "green" };
    return { text: `R${level} Under -${absVal.toFixed(2)}`, color: "red" };
  }

  function updateDCSummaryForEye(dcInputId, dcDisplayId, nowDCId){
    const inputEl = document.getElementById(dcInputId);
    const displayEl = document.getElementById(dcDisplayId);
    const nowDCEl = document.getElementById(nowDCId);
    if(!inputEl) return;
    const val = safeParseFloat(inputEl.value);
    const info = dcStatusText(val);
    if(displayEl){ displayEl.textContent = info.text; displayEl.style.color = info.color; }
    if(nowDCEl){ nowDCEl.textContent = info.text.split(' ')[0]; nowDCEl.style.color = info.color; }
  }

  // ---------- Core vector combine function ----------
  // Combines NowRx (S1,C1,A1) with fan-chart cylinder (C2,A2) and DC sphere (DC_S)
  function combineEyeWithDeficit(S_now, C_now, A_now, DC_S, C2, A2){
    const rx1 = toMinusCyl({ S: S_now, C: C_now, A: A_now });
    const S2_from_FC = -safeParseFloat(C2) / 2;
    const rx2 = toMinusCyl({ S: S2_from_FC, C: C2, A: A2 });

    const M1 = rx1.S + rx1.C / 2;
    const J01 = -rx1.C/2 * Math.cos(2 * deg2rad(rx1.A));
    const J451 = -rx1.C/2 * Math.sin(2 * deg2rad(rx1.A));

    const M2 = rx2.S + rx2.C / 2;
    const J02 = -rx2.C/2 * Math.cos(2 * deg2rad(rx2.A));
    const J452 = -rx2.C/2 * Math.sin(2 * deg2rad(rx2.A));

    let M_total = M1 + M2 + safeParseFloat(DC_S);
    let J0_total = J01 + J02;
    let J45_total = J451 + J452;

    if (extraMinus025) {
    // Add cyl-only vector for -0.25 √ó 180 (J0 = +0.25)
    M_total -= 0.0625;
    J0_total += 0.125;
    }
    
    

    const C_total_raw = -2 * Math.sqrt(J0_total * J0_total + J45_total * J45_total);
    const S_total_raw = M_total - C_total_raw / 2;
    let A_total = 0.5 * rad2deg(Math.atan2(J45_total, J0_total));
    if(A_total < 0) A_total += 180;
    A_total = Math.round(A_total); // axis to nearest 1 degree

    const S_total_q = roundQuarterNumber(S_total_raw);
    const C_total_q = roundQuarterNumber(C_total_raw);

    const SE_numeric = S_total_q + C_total_q / 2;

    return { S: S_total_q, C: C_total_q, A: A_total, SE: SE_numeric };
  }

  // ---------- Main combine function (updates OU + Mono + SE diffs + DC summaries) ----------
  function combineAll(){
    try {


      // --- Read Now Rx ---
      const S_RE = safeParseFloat(document.getElementById("s1_od")?.value || 0);
      const C_RE = safeParseFloat(document.getElementById("c1_od")?.value || 0);
      const A_RE = Math.round(safeParseFloat(document.getElementById("a1_od")?.value || 0));

      const S_LE = safeParseFloat(document.getElementById("s1_os")?.value || 0);
      const C_LE = safeParseFloat(document.getElementById("c1_os")?.value || 0);
      const A_LE = Math.round(safeParseFloat(document.getElementById("a1_os")?.value || 0));

      // write Now SE (numeric) into any existing now-se ids
      const nowSE_RE_num = calcSENumber(S_RE, C_RE);
      const nowSE_LE_num = calcSENumber(S_LE, C_LE);
      setIf("now-se-od", formatSEforDisplay(nowSE_RE_num));
      setIf("now-se-os", formatSEforDisplay(nowSE_LE_num));
      setIf("now-se-od-2", formatSEforDisplay(nowSE_RE_num));
      setIf("now-se-os-2", formatSEforDisplay(nowSE_LE_num));

      // baseline now diff (RE - LE) ‚Äî high sensitivity (0.01)
      const nowDiff = nowSE_RE_num - nowSE_LE_num;
      setIf("now-se-diff", formatSEDiffForDisplay(nowDiff));
      setIf("now-se-diff-od", formatSEDiffForDisplay(nowDiff));
      setIf("now-se-diff-os", formatSEDiffForDisplay(nowDiff));

      // --- Read Deficit OU ---
      const DC_OU = safeParseFloat(document.getElementById("dc-sph-ou")?.value || 0);
      const C2_OU = safeParseFloat(document.getElementById("c2_ou")?.value || 0);
      const A2_OU = Math.round(safeParseFloat(document.getElementById("a2_ou")?.value || 0));

      // OU combine for each eye (Now Rx + OU deficit vectorially)
      const RE_ou = combineEyeWithDeficit(S_RE, C_RE, A_RE, DC_OU, C2_OU, A2_OU);
      const LE_ou = combineEyeWithDeficit(S_LE, C_LE, A_LE, DC_OU, C2_OU, A2_OU);

      // write OU result fields
      setIf("res-sph-ou-re", formatValueForDisplay(RE_ou.S));
      setIf("res-cyl-ou-re", formatValueForDisplay(RE_ou.C));
const axisRE_OU = (Math.abs(RE_ou.C) < 0.001) ? "‚Äî" : (RE_ou.A === 0 ? "180" : String(RE_ou.A));
setIf("res-axis-ou-re", axisRE_OU);
setIf("res-se-ou-re", formatSEforDisplay(RE_ou.SE));

      setIf("res-sph-ou-le", formatValueForDisplay(LE_ou.S));
      setIf("res-cyl-ou-le", formatValueForDisplay(LE_ou.C));
const axisLE_OU = (Math.abs(LE_ou.C) < 0.001) ? "‚Äî" : (LE_ou.A === 0 ? "180" : String(LE_ou.A));
setIf("res-axis-ou-le", axisLE_OU);
setIf("res-se-ou-le", formatSEforDisplay(LE_ou.SE));

// persist OU baseline sph so SPH buttons always reference the true base
const elResSphOuRe = document.getElementById("res-sph-ou-re");
if (elResSphOuRe) elResSphOuRe.dataset.base = String(RE_ou.S);
const elResSphOuLe = document.getElementById("res-sph-ou-le");
if (elResSphOuLe) elResSphOuLe.dataset.base = String(LE_ou.S);


      // OU SE diff ‚Äî high sensitivity (0.01)
      const ouDiff = RE_ou.SE - LE_ou.SE;
      setIf("res-se-diff-ou", formatSEDiffForDisplay(ouDiff));
      setIf("res-se-diff-ou-re", formatSEDiffForDisplay(ouDiff));
      setIf("res-se-diff-ou-le", formatSEDiffForDisplay(ouDiff));

      // --- Mono combines (per-eye deficits) ---
      const DC_RE = safeParseFloat(document.getElementById("dc-sph-od")?.value || 0);
      const C2_RE = safeParseFloat(document.getElementById("c2_od")?.value || 0);
      const A2_RE = Math.round(safeParseFloat(document.getElementById("a2_od")?.value || 0));

      const DC_LE = safeParseFloat(document.getElementById("dc-sph-os")?.value || 0);
      const C2_LE = safeParseFloat(document.getElementById("c2_os")?.value || 0);
      const A2_LE = Math.round(safeParseFloat(document.getElementById("a2_os")?.value || 0));

      const RE_mono = combineEyeWithDeficit(S_RE, C_RE, A_RE, DC_RE, C2_RE, A2_RE);
      const LE_mono = combineEyeWithDeficit(S_LE, C_LE, A_LE, DC_LE, C2_LE, A2_LE);

      // write Mono result fields
      setIf("res-sph-od-2", formatValueForDisplay(RE_mono.S));
      setIf("res-cyl-od-2", formatValueForDisplay(RE_mono.C));
const axisOD_MONO = (Math.abs(RE_mono.C) < 0.001) ? "‚Äî" : (RE_mono.A === 0 ? "180" : String(RE_mono.A));
setIf("res-axis-od-2", axisOD_MONO);
setIf("res-se-od-2", formatSEforDisplay(RE_mono.SE));

      setIf("res-sph-os-2", formatValueForDisplay(LE_mono.S));
      setIf("res-cyl-os-2", formatValueForDisplay(LE_mono.C));
const axisOS_MONO = (Math.abs(LE_mono.C) < 0.001) ? "‚Äî" : (LE_mono.A === 0 ? "180" : String(LE_mono.A));
setIf("res-axis-os-2", axisOS_MONO);
setIf("res-se-os-2", formatSEforDisplay(LE_mono.SE));

// persist Mono baseline sph
const elResSphOd2 = document.getElementById("res-sph-od-2");
if (elResSphOd2) elResSphOd2.dataset.base = String(RE_mono.S);
const elResSphOs2 = document.getElementById("res-sph-os-2");
if (elResSphOs2) elResSphOs2.dataset.base = String(LE_mono.S);

      // Mono SE diff ‚Äî high sensitivity (0.01)
      const monoDiff = RE_mono.SE - LE_mono.SE;
      setIf("res-se-diff-2", formatSEDiffForDisplay(monoDiff));
      setIf("res-se-diff-od-2", formatSEDiffForDisplay(monoDiff));
      setIf("res-se-diff-os-2", formatSEDiffForDisplay(monoDiff));

// ---------- Final OU (no -0.25) ----------
const final_RE_ou = combineEyeWithout025(S_RE, C_RE, A_RE, DC_OU, C2_OU, A2_OU);
const final_LE_ou = combineEyeWithout025(S_LE, C_LE, A_LE, DC_OU, C2_OU, A2_OU);

setIf("final-sph-ou-re", formatValueForDisplay(final_RE_ou.S));
setIf("final-cyl-ou-re", formatValueForDisplay(final_RE_ou.C));
setIf("final-axis-ou-re", (Math.abs(final_RE_ou.C)<0.001)?"‚Äî":(final_RE_ou.A===0?"180":final_RE_ou.A));
setIf("final-se-ou-re", formatSEforDisplay(final_RE_ou.SE));
setIf("final-dc-ou-re","BAL");

setIf("final-sph-ou-le", formatValueForDisplay(final_LE_ou.S));
setIf("final-cyl-ou-le", formatValueForDisplay(final_LE_ou.C));
setIf("final-axis-ou-le", (Math.abs(final_LE_ou.C)<0.001)?"‚Äî":(final_LE_ou.A===0?"180":final_LE_ou.A));
setIf("final-se-ou-le", formatSEforDisplay(final_LE_ou.SE));
setIf("final-dc-ou-le","BAL");

// ---------- Final Mono (no -0.25) ----------
const final_RE_mono = combineEyeWithout025(S_RE, C_RE, A_RE, DC_RE, C2_RE, A2_RE);
const final_LE_mono = combineEyeWithout025(S_LE, C_LE, A_LE, DC_LE, C2_LE, A2_LE);

setIf("final-sph-od", formatValueForDisplay(final_RE_mono.S));
setIf("final-cyl-od", formatValueForDisplay(final_RE_mono.C));
setIf("final-axis-od", (Math.abs(final_RE_mono.C)<0.001)?"‚Äî":(final_RE_mono.A===0?"180":final_RE_mono.A));
setIf("final-se-od", formatSEforDisplay(final_RE_mono.SE));
setIf("final-dc-od","BAL");

setIf("final-sph-os", formatValueForDisplay(final_LE_mono.S));
setIf("final-cyl-os", formatValueForDisplay(final_LE_mono.C));
setIf("final-axis-os", (Math.abs(final_LE_mono.C)<0.001)?"‚Äî":(final_LE_mono.A===0?"180":final_LE_mono.A));
setIf("final-se-os", formatSEforDisplay(final_LE_mono.SE));
setIf("final-dc-os","BAL");



// --- Bypass calculation (rounded to nearest 0.25 D) ---
// Mono (OD/OS)
const bypassRE = safeParseFloat(document.getElementById("res-se-od-2")?.textContent);
const bypassLE = safeParseFloat(document.getElementById("res-se-os-2")?.textContent);

if (!Number.isNaN(bypassRE) && !Number.isNaN(bypassLE)) {
  let bypassDiff = bypassRE - bypassLE;
  bypassDiff = Math.round(bypassDiff * 8) / 8; // round to nearest 0.125 D
  setIf("bypass", formatSEDiffForDisplay(bypassDiff));
}

// Final Mono (OD/OS)
const finalMonoRE = safeParseFloat(document.getElementById("final-se-od")?.textContent);
const finalMonoLE = safeParseFloat(document.getElementById("final-se-os")?.textContent);

if (!Number.isNaN(finalMonoRE) && !Number.isNaN(finalMonoLE)) {
  let bypassDiffMono = finalMonoRE - finalMonoLE;
  bypassDiffMono = Math.round(bypassDiffMono * 8) / 8; // nearest 0.125 D
  setIf("bypass-final-mono", formatSEDiffForDisplay(bypassDiffMono));
}

// Final OU (RE/LE)
const finalOuRE = safeParseFloat(document.getElementById("final-se-ou-re")?.textContent);
const finalOuLE = safeParseFloat(document.getElementById("final-se-ou-le")?.textContent);

if (!Number.isNaN(finalOuRE) && !Number.isNaN(finalOuLE)) {
  let bypassDiffOu = finalOuRE - finalOuLE;
  bypassDiffOu = Math.round(bypassDiffOu * 8) / 8; // nearest 0.125 D
  setIf("bypass-final-ou", formatSEDiffForDisplay(bypassDiffOu));
}



// Track offsets in 0.25 steps for OU and Mono
const sphOffsets = { ou: 0, mono: 0 };

document.querySelectorAll('.sph-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const group = btn.dataset.group;   // "ou" or "mono"
    const step = parseFloat(btn.dataset.step); // -0.25 or +0.25

    // Update offset
    sphOffsets[group] += step;

    // Reapply adjustment
    applySphOffset(group);
  });
});


// Call this after your main OU/Mono results are calculated
function applySphOffset(group) {
  const ids = (group === "ou")
    ? { right: "res-sph-ou-re", left: "res-sph-ou-le", dcr: "res-dc-ou-re", dcl: "res-dc-ou-le" }
    : { right: "res-sph-od-2", left: "res-sph-os-2", dcr: "res-dc-od-2", dcl: "res-dc-os-2" };

  const rightCell = document.getElementById(ids.right);
  const leftCell  = document.getElementById(ids.left);
  const dcRight   = document.getElementById(ids.dcr);
  const dcLeft    = document.getElementById(ids.dcl);

  if (!rightCell || !leftCell) return;

  // Preserve the original base (only set once)
  if (!rightCell.dataset.base) rightCell.dataset.base = rightCell.textContent.trim() || "0";
  if (!leftCell.dataset.base)  leftCell.dataset.base  = leftCell.textContent.trim() || "0";

  const baseRight = parseFloat(rightCell.dataset.base) || 0;
  const baseLeft  = parseFloat(leftCell.dataset.base) || 0;

// Formatter: always show + for positives
function formatSigned(value) {
  const num = parseFloat(value).toFixed(2);
  if (num > 0) return "+" + num;
  return num; // negatives already have -, zero stays 0.00
}

// Apply offset math (fixed so it doesn‚Äôt jump)
const newRight = baseRight + sphOffsets[group];
const newLeft  = baseLeft + sphOffsets[group];

rightCell.textContent = formatSigned(newRight);
leftCell.textContent  = formatSigned(newLeft);


  // Update DC label + color
  const label = getDcLabel(sphOffsets[group]);
  if (dcRight) {
    dcRight.textContent = label.text;
    dcRight.style.color = label.color;
    dcRight.style.fontWeight = "none";
  }
  if (dcLeft) {
    dcLeft.textContent = label.text;
    dcLeft.style.color = label.color;
    dcLeft.style.fontWeight = "none";
  }
}

function getDcLabel(offset) {
  if (offset === 0) return { text: "BAL", color: "black" };
  if (offset < 0) return { text: "G" + Math.abs(offset / 0.25), color: "green" };
  return { text: "R" + (offset / 0.25), color: "red" };
}


      // --- Update DC summary for eyes (ensure OU updates dc-ou) ---
      updateDCSummaryForEye("dc-sph-od", "dc-summary", "now-dc-od");
      updateDCSummaryForEye("dc-sph-os", "dc-summary", "now-dc-os");
      updateDCSummaryForEye("dc-sph-ou", "dc-summary", "dc-ou");

// --- RESET PRESCRIBED DC STATUS TO BAL ---
const prescribedDCEyes = [
  "res-dc-ou-re", "res-dc-ou-le",
  "res-dc-od-2", "res-dc-os-2"
];

prescribedDCEyes.forEach(id => {
  const el = document.getElementById(id);
  if(el) {
    el.textContent = "BAL";
    el.style.color = "black";
    el.style.fontWeight = "none";
  }
});




    } catch (err) {
      console.error("combineAll error:", err);
    }
  }

  // ---------- formatting on blur / axis handling ----------
  function isAxisId(id){
    if(!id) return false;
    return id.startsWith("a");
  }

  function autoFormatInput(el){
    if(!el) return;
    const id = el.id || "";
    let raw = String(el.value || "").trim();
    if(raw === "") return;
    if(isAxisId(id)){
      let num = parseInt(raw, 10);
      if(Number.isNaN(num)) num = 0;
      num = Math.max(0, Math.min(180, num));
      el.value = String(num);
    } else {
      let n = roundQuarterNumber(raw);
      el.value = (n >= 0 ? "+" : "") + n.toFixed(2);
    }
  }

  // ---------- Attach listeners ----------
  const inputIds = [
    "s1_od","c1_od","a1_od",
    "s1_os","c1_os","a1_os",
    "dc-sph-od","c2_od","a2_od",
    "dc-sph-os","c2_os","a2_os",
    "dc-sph-ou","c2_ou","a2_ou"
  ];

  inputIds.forEach(id => {
    const el = document.getElementById(id);
    if(!el) return;
    // live update as you type
    el.addEventListener("input", combineAll);
    // format on blur/enter
    el.addEventListener("blur", (e) => { autoFormatInput(e.target); combineAll(); });
    el.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){ e.preventDefault(); autoFormatInput(e.target); combineAll(); }
    });
  });

  // Also ensure duochrome inputs update summary live
  ["dc-sph-od","dc-sph-os","dc-sph-ou"].forEach(id => {
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener("input", () => {
      updateDCSummaryForEye("dc-sph-od","dc-summary","now-dc-od");
      updateDCSummaryForEye("dc-sph-os","dc-summary","now-dc-os");
      updateDCSummaryForEye("dc-sph-ou","dc-summary","dc-ou");
    });
  });

  // initial run
  combineAll();
});

</script>

<script>
// --- Parse DC input (same as before) ---
function parseDC(dc) {
  if (dc === null || dc === undefined) return null;
  let s = String(dc).trim();
  if (!s) return null;

  s = s.replace(/‚àí/g, '-').toUpperCase(); // normalize minus sign

  if (s === 'BAL') return { kind: 'BAL', diopter: 0, stepVal: 0, raw: s };

  const codeMatch = s.match(/^([RG])\s*(\d+)$/i);
  if (codeMatch) {
    const type = codeMatch[1].toUpperCase();
    const step = parseInt(codeMatch[2], 10);
    const diopter = (type === 'R') ? -(step * 0.25) : (step * 0.25);
    const stepVal = (type === 'R') ? -step : step;
    return { kind: 'CODE', type, step, stepVal, diopter, raw: s };
  }

  const numStr = s.replace(/[^\d\.\-+]/g, '');
  const n = parseFloat(numStr);
  if (!Number.isNaN(n)) {
    const stepVal = n / 0.25;
    return { kind: 'NUMERIC', diopter: n, stepVal, raw: s };
  }

  return { kind: 'UNKNOWN', raw: s };
}

// --- Consumer-friendly descriptions (unchanged except colour labels) ---
function describeDC(dc, label = 'Current') {
  if (!dc) return '';
  const parsed = parseDC(dc);
  if (!parsed) return `${label} RX: ${dc}`;

  if (parsed.kind === 'BAL') {
    return `${label} RX is true balance between far and near vision.`;
  }

  if (parsed.kind === 'CODE') {
    const absD = Math.abs(parsed.diopter).toFixed(2);
    const colourLabel = `<span style="color:${parsed.type === 'R' ? 'red' : 'green'}; font-weight:normal;">${parsed.raw}</span>`;

    if (parsed.type === 'R') {
      return `${label} RX under by -${absD} (${colourLabel}); perfect for near and room distance, but not able to see very far.`;
    } else {
      if (parsed.step === 1) {
        return `${label} RX over by +${absD} (${colourLabel}); perfect for seeing as far as possible.`;
      }
      return `${label} RX over by +${absD} (${colourLabel}); over the healthy limit of +0.25 (<span style="color: green; font-weight:normal;">G1</span>). Prolonged use may cause blurry vision, tiredness and headaches.`;
    }
  }

  if (parsed.kind === 'NUMERIC') {
    const d = parsed.diopter.toFixed(2);
    if (Math.abs(parsed.diopter) < 0.0001) return `${label} RX balances far & near vision.`;
    if (parsed.diopter < 0) return `${label} RX under by ${d}.`; 
    if (Math.abs(parsed.diopter - 0.25) < 0.0001) {
      return `${label} RX over by ${d}; perfect for seeing as far as possible.`;
    }
    return `${label} RX over by ${d}; Limit for healthy vision is +0.25 (<span style="color: green; font-weight:normal;">G1</span>); Unnecessary over will cause blurry vision & headaches.`;
  }

  return `${label} RX: ${dc}`;
}

// --- NEW: Deeper analysis of DC status based on your 4 rules ---
// Accepts optional parsed objects as 3rd/4th args for efficiency (getDCShiftText already passes them)
function getDeeperAnalysis(fromDC, toDC, prevParsed, toParsed) {
  const f = (prevParsed && typeof prevParsed === 'object') ? prevParsed : parseDC(fromDC);
  const t = (toParsed && typeof toParsed === 'object') ? toParsed : parseDC(toDC);
  if (!f || !t || f.kind === 'UNKNOWN' || t.kind === 'UNKNOWN') return '';

  // Numeric diopters and stepVal (safe fallbacks)
  const fromDiopter = (typeof f.diopter === 'number') ? f.diopter : ((typeof f.stepVal === 'number') ? f.stepVal * 0.25 : 0);
  const toDiopter = (typeof t.diopter === 'number') ? t.diopter : ((typeof t.stepVal === 'number') ? t.stepVal * 0.25 : 0);
  const fromStepVal = (typeof f.stepVal === 'number') ? f.stepVal : (typeof f.diopter === 'number' ? f.diopter / 0.25 : 0);
  const toStepVal = (typeof t.stepVal === 'number') ? t.stepVal : (typeof t.diopter === 'number' ? t.diopter / 0.25 : 0);

  // Collect messages (we may return multiple lines, separated by <br>)
  const parts = [];

  // ---- Exclusive "no change" cases (return immediately) ----
  if (f.kind === 'BAL' && t.kind === 'BAL') {
    return '- No changes in the far and near vision.';
  }
  if (f.type === 'R' && t.type === 'R' && typeof f.step === 'number' && typeof t.step === 'number' && f.step === t.step) {
    return `- No changes in the far and near vision.`;
  }

  // --- Rule 1: G ‚Üí G (handle when both are G codes) ---
  if (f.type === 'G' && t.type === 'G') {
    if (typeof f.step === 'number' && typeof t.step === 'number' && (f.step - t.step === 1)) {
      parts.push('- No loss of distance clarity. Near vision comfort improves slightly.');
    } else if (typeof f.step === 'number' && typeof t.step === 'number' && t.step < f.step) {
      parts.push('- No loss of distance clarity. Significant improvement in near vision comfort.');
    } else if (typeof f.step === 'number' && typeof t.step === 'number' && t.step > f.step) {
      parts.push('- No loss of distance clarity but worsening of near vision comfort. Not recommended to prescribe.');
    }
    // continue ‚Äî other rules below may also apply in borderline cases
  }



// --- Rule 4: Distance improvement (cases that increase distance clarity) ---
const distanceImprovementCond =
  (f.kind === 'BAL' && t.type === 'G') ||
  (f.type === 'R' && t.kind === 'BAL') ||
  (f.type === 'R' && t.type === 'R' && typeof t.step === 'number' && typeof f.step === 'number' && t.step < f.step) ||
  (f.type === 'R' && t.type === 'G' && t.step === 1); // NEW: R ‚Üí G1 improves distance


if (distanceImprovementCond) {
  // Special case: G1 or higher (G2, G3, ...)
  if (t.type === 'G' && typeof t.step === 'number' && t.step >= 1) {
    if (t.step === 1) {
      parts.push(`- Distance clarity is already maximized at G1; objects are as clear as possible.`);
    } else {
      parts.push(`- Distance clarity does not improve further beyond G1 (already maximized).`);
    }
  } else {
    let gainDist = 20; // default
    if (t.kind === 'BAL') gainDist = 20;
    if (t.type === 'R' && typeof t.step === 'number') {
      gainDist = 20 / Math.pow(2, t.step - 1); // R1=10, R2=5, ...
    }
    parts.push(`- However, distance clarity improves. Objects up to ${gainDist} feet will appear clearer.`);
  }
}


  // --- Rule 2: Any ‚Üí BAL or R (distance reduction) ---
  // Only add reduction when we did NOT already decide distance improves (to avoid contradiction)
  const distanceReductionCond = (t.kind === 'BAL' || t.type === 'R') && !distanceImprovementCond;
  if (distanceReductionCond) {
    let lossDist = 20; // default for BAL
    if (t.type === 'R' && typeof t.step === 'number') {
      lossDist = 20 / Math.pow(2, t.step - 1); // R1=10, R2=5...
    }
    parts.push(`- However, distance clarity will be reduced. Vision becomes blurry beyond ${lossDist} feet.`);
  }

  // Join lines with <br> for HTML display; or return empty if nothing matched
  return parts.length ? parts.join('<br>') : '';
}

// --- Deep analysis wrapper (uses both old shift + new deeper analysis) ---
function getDCShiftText(fromDC, toDC) {
  if (!fromDC || !toDC) return '';

  const f = parseDC(fromDC);
  const t = parseDC(toDC);
  if (!f || !t || f.kind === 'UNKNOWN' || t.kind === 'UNKNOWN') return '';

  const fromStepVal = (typeof f.stepVal === 'number') ? f.stepVal : (f.diopter / 0.25);
  const toStepVal = (typeof t.stepVal === 'number') ? t.stepVal : (t.diopter / 0.25);

  const stepDiff = toStepVal - fromStepVal;
  const diopterShift = stepDiff * 0.25;

  const line1 = describeDC(fromDC, '- Current');

  let line2 = '';
  if (Math.abs(diopterShift) < 0.0001) {
    line2 = '- There is no change of far and near vision.';
 } else {
  const mag = Math.abs(diopterShift).toFixed(2);
  const direction = (stepDiff < 0) ? '+' : '-';

  // Base message
  line2 = `- There is a change of ${direction}${mag}. `;

  // Adaptation analysis
  if (Math.abs(diopterShift) <= 0.25 + 0.001) {
    line2 += 'Adaptation is usually easy and takes less than 1 week. ';
  } else if (Math.abs(diopterShift) <= 0.50 + 0.001) {
    line2 += 'Takes 1‚Äì2 weeks to adapt. This is the max amount to adjust comfortably. ';
  } else {
    line2 += 'Takes more than 2 weeks to adapt because it is more than usual limit. ';
  }

  // Extra near-vision comfort analysis
  if (diopterShift > 0) {
    line2 += '<br>- With more minus, near vision comfort and range will reduce.';
  } else if (diopterShift < 0) {
    line2 += '<br>- With more plus, near vision comfort and range will improve.';
  }
}


  let line3 = '';
  if (t.kind === 'BAL') {
    line3 = '- New RX is true balance between distance and near vision.';
  } else {
    const newD = (typeof t.diopter === 'number') ? t.diopter : (t.stepVal * 0.25);
    const mag = Math.abs(newD).toFixed(2);

    let codeLabel = '';
    if (t.kind === 'CODE') {
      const color = (t.type === 'R') ? 'red' : 'green';
      codeLabel = `(<span style="color:${color}; font-weight:normal;">${t.type}${t.step}</span>)`;
    }

    if (newD < 0) {
      line3 = `- New RX prioritizes near vision; under by -${mag} ${codeLabel}.`;
    } else {
      line3 = `- New RX prioritizes distance vision; over by +${mag} ${codeLabel}.`;
    }
  }

  // pass parsed f/t in to avoid re-parsing internally
  const line4 = getDeeperAnalysis(fromDC, toDC, f, t);

  return [line1, line3, line2, line4].filter(Boolean).join('<br>');
}

// --- Update analysis in real-time ---
function updateDCAnalysis() {
  const binoErrorDC = document.getElementById('dc-ou')?.textContent.trim();
  const prescribedDC = document.getElementById('res-dc-ou-re')?.textContent.trim();
  if (!binoErrorDC || !prescribedDC) return;

  const analysisEl = document.getElementById('analysis-ou');
  if (!analysisEl) return;

  const text = getDCShiftText(binoErrorDC, prescribedDC);
  analysisEl.innerHTML = text;
  analysisEl.style.textAlign = 'left';
}

setInterval(updateDCAnalysis, 300);
</script>


<!-- Spacer at the bottom for scrolling -->
<div style="height:700px;"></div>


</body>
</html>






